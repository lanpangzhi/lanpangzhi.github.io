<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝胖纸</title>
  
  <subtitle>哆啦A梦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.langpz.com/"/>
  <updated>2018-05-17T05:09:39.336Z</updated>
  <id>http://blog.langpz.com/</id>
  
  <author>
    <name>lanpangzhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用travis-ci自动构建Hexo</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo.html"/>
    <id>http://blog.langpz.com/使用travis-ci自动构建Hexo.html</id>
    <published>2018-05-15T16:30:49.000Z</published>
    <updated>2018-05-17T05:09:39.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用travis-ci自动构建Hexo"><a href="#使用travis-ci自动构建Hexo" class="headerlink" title="使用travis-ci自动构建Hexo"></a>使用travis-ci自动构建Hexo</h1><p>持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。<br><a id="more"></a><br>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。</p><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>本地写完文章  =&gt;  push github  =&gt;  GitHub触发Travis CI构建  =&gt;  执行命令  =&gt;  部署  =&gt;   完成。</p><h2 id="用github登陆travis-ci"><a href="#用github登陆travis-ci" class="headerlink" title="用github登陆travis-ci"></a>用github登陆travis-ci</h2><p><a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a>然后添加到你要激活的存储库。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180515180738.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后选择你要使用的仓库，我这里选择的是lanpangzhi.github.io，我放hexo博客的仓库。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180515180908.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后生成SSH公钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure></p><p>然后找到 C:\Users\windows.ssh  下的 id_rsa.pub， 把内容添加到github和coding的hexo仓库的部署公钥里面。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180516144527.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180516144704.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后在git仓库根目录 添加 .travis.yml 文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">- 8.9.0</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - node_modules</span><br><span class="line">before_install:</span><br><span class="line">- git config --global user.name &quot;lanpangzhi&quot;</span><br><span class="line">- git config --global user.email 875727617@qq.com</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">install:</span><br><span class="line">- npm install</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate</span><br><span class="line">- hexo deploy</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - indigo</span><br></pre></td></tr></table></figure></p><p>下载ruby(如果你电脑有就不需要下载了)  注：不要使用Windows 系统机器否则构建的时候会报错<br><a href="https://rubyinstaller.org/downloads/" target="_blank" rel="noopener">下载地址</a>，选择你需要的版本下载，我直接下载最新版64位了。</p><p>安装travis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure></p><p>安装完后登陆travis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis login --auto</span><br></pre></td></tr></table></figure></p><p>输入你github的登陆账号和密码。如下图就登陆成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180516152543.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>下一步开始用travis提供的工具加密刚才生成SSH公钥,并上传到travis供日常使用。<br>把之前生成的id_rsa.pub文件放到项目根目录，然后执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis encrypt-file id_rsa.pub --add -r github用户名/hexo仓库  // 不要使用Windows 系统机器否则构建的时候会报错</span><br></pre></td></tr></table></figure></p><p>成功后会生成一个id_rsa.pub.enc 并且 .travis.yml 会自动添加一些内容，不要去改内容。 然后把id_rsa.pub 文件删除。</p><p>然后新建文件夹 .travis 然后把id_rsa.pub.enc 文件移到 .travis 文件夹里面， 在里面再新建  ssh_config 文件添加如下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure></p><p>.travis.yml 文件最终版本，可以参考。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">- 8.9.0</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - node_modules</span><br><span class="line">before_install:</span><br><span class="line">  - openssl aes-256-cbc -K $encrypted_43f1702cd897_key -iv $encrypted_43f1702cd897_iv</span><br><span class="line">    -in .travis/id_rsa_github.enc -out ~/.ssh/id_rsa -d</span><br><span class="line">  - chmod 600 ~/.ssh/id_rsa</span><br><span class="line">  - eval $(ssh-agent)</span><br><span class="line">  - ssh-add ~/.ssh/id_rsa</span><br><span class="line">  - cp .travis/ssh_config ~/.ssh/config</span><br><span class="line">  - git config --global user.name &quot;lanpangzhi&quot;</span><br><span class="line">  - git config --global user.email 875727617@qq.com</span><br><span class="line">  - npm install hexo-cli -g</span><br><span class="line">install:</span><br><span class="line">  - npm install</span><br><span class="line">script:</span><br><span class="line">  - hexo clean</span><br><span class="line">  - hexo generate</span><br><span class="line">  - hexo deploy</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - indigo</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.travis-ci.com/user/for-beginners" target="_blank" rel="noopener">https://docs.travis-ci.com/user/for-beginners</a><br><a href="https://zh.wikipedia.org/wiki/Travis_CI" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Travis_CI</a><br><a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744</a><br><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="noopener">https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用travis-ci自动构建Hexo&quot;&gt;&lt;a href=&quot;#使用travis-ci自动构建Hexo&quot; class=&quot;headerlink&quot; title=&quot;使用travis-ci自动构建Hexo&quot;&gt;&lt;/a&gt;使用travis-ci自动构建Hexo&lt;/h1&gt;&lt;p&gt;持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://blog.langpz.com/tags/Hexo/"/>
    
      <category term="travis-ci" scheme="http://blog.langpz.com/tags/travis-ci/"/>
    
      <category term="自动构建" scheme="http://blog.langpz.com/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="持续集成" scheme="http://blog.langpz.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>使用express-generator快速生成express应用</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8express-generator%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90express%E5%BA%94%E7%94%A8.html"/>
    <id>http://blog.langpz.com/使用express-generator快速生成express应用.html</id>
    <published>2018-05-14T16:08:03.000Z</published>
    <updated>2018-05-17T05:09:39.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用express-generator快速生成express应用"><a href="#使用express-generator快速生成express应用" class="headerlink" title="使用express-generator快速生成express应用"></a>使用express-generator快速生成express应用</h1><p>express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure><p>需要全局安装。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在要创建应用的文件夹下面执。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express -e myapp</span><br></pre></td></tr></table></figure></p><p>-e： 使用ejs模板<br>myapp： 应用名字</p><p>然后安装依赖项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myapp</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>执行应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set DEBUG=myapp:* &amp; npm start</span><br></pre></td></tr></table></figure></p><p>生成完应用的时候会有提示因为我是Windows系统所以提示set。<br>MacOS 或 Linux 上不用使用set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=myapp:* npm start</span><br></pre></td></tr></table></figure></p><p>然后在浏览器中输入 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 以访问此应用程序。<br>可以根据自己的需要修改文件，来满足自己项目的需要。</p><h2 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    --version        输出版本号</span><br><span class="line">-e, --ejs            添加ejs引擎支持</span><br><span class="line">    --pug            添加pug引擎支持</span><br><span class="line">    --hbs            添加handlebars引擎支持</span><br><span class="line">-H, --hogan          添加hogan.js引擎支持</span><br><span class="line">-v, --view &lt;engine&gt;  添加以下模板引擎支持(dust|ejs|hbs|hjs|jade|pug|twig|vash) 默认jade  </span><br><span class="line">    --no-view        使用静态HTML代替视图模板引擎</span><br><span class="line">-c, --css &lt;engine&gt;   添加样式扩展语言 (less|stylus|compass|sass) 默认css  </span><br><span class="line">    --git            添加 .gitignore 忽略文件</span><br><span class="line">-h, --help           输出帮助信息</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/expressjs/generator" target="_blank" rel="noopener">https://github.com/expressjs/generator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用express-generator快速生成express应用&quot;&gt;&lt;a href=&quot;#使用express-generator快速生成express应用&quot; class=&quot;headerlink&quot; title=&quot;使用express-generator快速生成express应用&quot;&gt;&lt;/a&gt;使用express-generator快速生成express应用&lt;/h1&gt;&lt;p&gt;express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="express-generator" scheme="http://blog.langpz.com/tags/express-generator/"/>
    
  </entry>
  
  <entry>
    <title>node爬虫</title>
    <link href="http://blog.langpz.com/node%E7%88%AC%E8%99%AB.html"/>
    <id>http://blog.langpz.com/node爬虫.html</id>
    <published>2018-05-12T15:37:42.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node爬虫"><a href="#node爬虫" class="headerlink" title="node爬虫"></a>node爬虫</h1><p>什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。<br><a id="more"></a></p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>爬取<a href="http://top.zhaopin.com" target="_blank" rel="noopener">http://top.zhaopin.com</a>  智联网站上的全国的竞争最激烈三个月内前十的岗位。不需要定时爬取。使用request和cheerio模块。node版本7.6.0、npm版本4.1.2</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install request cheerio -S</span><br></pre></td></tr></table></figure><p>request 模块是一个简化的HTTP客户端。<br>cheerio 模块专为服务器设计的核心jQuery的快速，灵活和精益的实现。可以把爬到的内容和jQuery一样使用。</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line">const cheerio = require(&apos;cheerio&apos;);</span><br><span class="line"></span><br><span class="line">// 发起请求</span><br><span class="line">request(&apos;http://top.zhaopin.com&apos;, (error, response, body) =&gt; &#123;</span><br><span class="line">    if(error)&#123;</span><br><span class="line">        console.error(error);</span><br><span class="line">    &#125;</span><br><span class="line">    let json = &#123;&#125;;</span><br><span class="line">    // 获取到的内容放到cheerio模块</span><br><span class="line">    const $ = cheerio.load(body);</span><br><span class="line"></span><br><span class="line">    // jQuery 遍历  #hotJobTop .topList li  是通过http://top.zhaopin.com 分析页面结构得到的</span><br><span class="line">    $(&apos;#hotJobTop .topList li&apos;).each(function (index) &#123;</span><br><span class="line">        let obj = json[index] = &#123;&#125;;</span><br><span class="line">        obj.name = $(this).find(&apos;.title&apos;).text().trim();</span><br><span class="line">        obj.num = $(this).find(&apos;.paddingR10&apos;).text().trim();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    console.log(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行 node app.js 就会得到如下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; name: &apos;Java开发工程师&apos;, num: &apos;340538人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;软件工程师&apos;, num: &apos;220873人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;销售代表&apos;, num: &apos;175053人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;会计/会计师&apos;, num: &apos;168225人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;行政专员/助理&apos;, num: &apos;150913人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;WEB前端开发&apos;, num: &apos;140979人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;助理/秘书/文员&apos;, num: &apos;139098人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;软件测试&apos;, num: &apos;136399人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;人力资源专员/助理&apos;, num: &apos;123482人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;用户界面（UI）设计&apos;, num: &apos;107505人/天&apos; &#125; ]</span><br></pre></td></tr></table></figure></p><p>一个简单的爬虫就写好了，看看前十有没有你从事的岗位吧！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/request/request" target="_blank" rel="noopener">https://github.com/request/request</a><br><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node爬虫&quot;&gt;&lt;a href=&quot;#node爬虫&quot; class=&quot;headerlink&quot; title=&quot;node爬虫&quot;&gt;&lt;/a&gt;node爬虫&lt;/h1&gt;&lt;p&gt;什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="爬虫" scheme="http://blog.langpz.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>node连接MySQL</title>
    <link href="http://blog.langpz.com/node%E8%BF%9E%E6%8E%A5MySQL.html"/>
    <id>http://blog.langpz.com/node连接MySQL.html</id>
    <published>2018-05-10T15:40:04.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node连接MySQL"><a href="#node连接MySQL" class="headerlink" title="node连接MySQL"></a>node连接MySQL</h1><p>之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;);</span><br><span class="line"></span><br><span class="line">let connection = mysql.createConnection(&#123;</span><br><span class="line">    host : &apos;localhost&apos;,</span><br><span class="line">    user : &apos;root&apos;,</span><br><span class="line">    password : &apos;password&apos;,</span><br><span class="line">    database : &apos;test&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect(function(err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(&apos;连接出错: &apos; + err.stack);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;连接成功 id &apos; + connection.threadId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>host：连接的服务器<br>user：用户名默认是root<br>password：之前设置的MySQL密码<br>database： 要连接的库</p><h2 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h2><p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。</p><p>增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (username, pass) VALUES (&apos;blog.langpz.com&apos;, &apos;123456&apos;);</span><br></pre></td></tr></table></figure></p><p>INSERT INTO 表名称 VALUES (值1, 值2,….)<br>指定所要插入数据的列<br>INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)</p><p>删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM user  WHERE id = 0</span><br></pre></td></tr></table></figure></p><p>DELETE FROM 表名称 WHERE 列名称 = 值<br>不加WHERE会删除所有行<br>WHERE子句用于规定选择的标准。</p><p>改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET pass = &apos;bbb&apos; WHERE username = &apos;张三&apos;</span><br></pre></td></tr></table></figure></p><p>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p><p>查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user</span><br></pre></td></tr></table></figure></p><p>SELECT 列名 FROM 表名 注： * 代表全部</p><h2 id="node操作MySQL"><a href="#node操作MySQL" class="headerlink" title="node操作MySQL"></a>node操作MySQL</h2><p>查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;SELECT * FROM user WHERE username = &quot;blog.langpz.com&quot;&apos;, (err, results, fields) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;DELETE FROM user  WHERE id = 1&apos;, (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;INSERT INTO user(username, pass) VALUES(?, ?)&apos;,[&apos;lan&apos;, &apos;abc&apos;], (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;UPDATE user SET pass = &quot;bbb&quot; WHERE username = &quot;lan&quot;&apos;, (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>终止连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connection.end(function(err) &#123;</span><br><span class="line">  // The connection is terminated now</span><br><span class="line">&#125;);</span><br><span class="line">connection.destroy();</span><br></pre></td></tr></table></figure></p><p>调用这两个方法都可以。<br>基本操作就是这个流程，可以通过路由封装接口，写一个CRUD应用，mysql模块更多参数可以去看github。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">https://github.com/mysqljs/mysql</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node连接MySQL&quot;&gt;&lt;a href=&quot;#node连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;node连接MySQL&quot;&gt;&lt;/a&gt;node连接MySQL&lt;/h1&gt;&lt;p&gt;之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="MySQL" scheme="http://blog.langpz.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装MongoDB</title>
    <link href="http://blog.langpz.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB.html"/>
    <id>http://blog.langpz.com/Windows下安装MongoDB.html</id>
    <published>2018-05-08T15:30:32.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下安装MongoDB"><a href="#Windows下安装MongoDB" class="headerlink" title="Windows下安装MongoDB"></a>Windows下安装MongoDB</h1><p>MongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。<br><a id="more"></a></p><h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>和关系型数据库比较，面向文档的数据库不再有“行”（row）的概念，取而代之的是更为灵活的“文档”（document）模型。通过再文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系。<br>另外，不再有预定义模式，文档的键（key）和值（value）不再是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易。可以进行快速迭代，所以开发进程得到加快。</p><h2 id="MongoDB基本概念"><a href="#MongoDB基本概念" class="headerlink" title="MongoDB基本概念"></a>MongoDB基本概念</h2><p>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行。<br>集合(collection)可以看作是一个拥有动态模式(dynamic schema)的表。<br>MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合。<br>每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。</p><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p><a href="https://www.mongodb.com/download-center#atlas" target="_blank" rel="noopener">下载地址</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/QQ%E5%9B%BE%E7%89%8720180508155317.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击下载，下载完安装，用默认设置。</p><h2 id="运行MongoDB"><a href="#运行MongoDB" class="headerlink" title="运行MongoDB"></a>运行MongoDB</h2><p>命令提示符（cmd）执行，具体路径需要看安装的版本，我的是3.6版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\MongoDB\Server\3.6\bin</span><br><span class="line">mongod --dbpath d:\db</span><br></pre></td></tr></table></figure></p><p>控制台会输出一些东西，没有报错MongoDB就启动了。<br>这样启动比较麻烦，每次都要启动，所以可以把它注册成windows 的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用管理员权限运行</span><br><span class="line">mongod --install --dbpath d:\data\db --logpath d:\data\log\log.txt</span><br><span class="line">net start MongoDB  // 启动服务</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services.msc // 查看服务</span><br><span class="line">net stop mongodb   // 停止服务</span><br></pre></td></tr></table></figure><p>删除服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --remove --serviceName MongoDB  // MongoDB是服务名</span><br></pre></td></tr></table></figure></p><p>MongoDB 还可以通过配置文件启动<br>可以去官网查看<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/configuration-options/</a></p><h2 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h2><p>在打开一个命令提示符（cmd）之前运行的MongoDB那个不要关闭，因为没有注册成windows的服务，关闭就找不到数据库了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\MongoDB\Server\3.6\bin</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure></p><p>这样就链接上数据库了，当然还会输出一大堆东西。</p><h2 id="操作MongoDB"><a href="#操作MongoDB" class="headerlink" title="操作MongoDB"></a>操作MongoDB</h2><p>我们先创建一个数据库，再刚才连接MongoDB的cmd执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test02</span><br></pre></td></tr></table></figure></p><p>创建一个test02的数据库并切换过去。<br>db变量指向当前数据库。<br>向集合里插入文档，之前也讲了MongoDB没有预定义模式，所以不用新建表和表结构了。<br>insert方法 把一条文档保存到集合里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.insert(&#123;&quot;name&quot;, &quot;lanpangzhi&quot;, &quot;age&quot;: 18&#125;)</span><br></pre></td></tr></table></figure></p><p>查看集合里面的文档。<br>find和findOne方法可以用于查询集合里的文档。只想查看一个文件，可以用findOne<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.find()</span><br><span class="line">db.user_table.findOne()</span><br></pre></td></tr></table></figure></p><p>find和findOne还可以接受一个查询文档作为限定条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.find(&#123;&quot;name&quot;: &quot;lanpangzhi&quot;&#125;)</span><br></pre></td></tr></table></figure></p><p>更新集合里面的文档<br>update方法接受（至少）两个参数：第一个是限定条件（用于匹配待更新的文档），第二个是新的文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.update(&#123;name: lanpangzhi&#125;,&#123;&quot;name&quot;: &quot;lanpangzhi&quot;, &quot;age&quot;: 18, &quot;sex&quot;: 1&#125;);</span><br></pre></td></tr></table></figure></p><p>删除集合里面的文档<br>remove方法可将数据库的集合永久删除，如果不加参数默认把集合里面所有的文档删除。它可以接受一个限定条件的文档作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.remove(&#123;&quot;name&quot;: &quot;aaa&quot;&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows下安装MongoDB&quot;&gt;&lt;a href=&quot;#Windows下安装MongoDB&quot; class=&quot;headerlink&quot; title=&quot;Windows下安装MongoDB&quot;&gt;&lt;/a&gt;Windows下安装MongoDB&lt;/h1&gt;&lt;p&gt;MongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://blog.langpz.com/tags/MongoDB/"/>
    
      <category term="Windows" scheme="http://blog.langpz.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装MySQL</title>
    <link href="http://blog.langpz.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL.html"/>
    <id>http://blog.langpz.com/Windows下安装MySQL.html</id>
    <published>2018-05-08T11:02:20.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下安装MySQL"><a href="#Windows下安装MySQL" class="headerlink" title="Windows下安装MySQL"></a>Windows下安装MySQL</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载地址</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508112259.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击，进入页面。注：MySQL安装程序是32位的，但会安装32位和64位二进制文件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508113607.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击download然后跳转到页面。可以不需要登陆和注册也可以下载。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508113906.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>再点击，安装程序就下载了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开安装程序，勾选同意协议，点击下一步(Next)<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508115626.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在只安装MySQL的服务端，点击下一步然后安装。<br>设置MySQL密码，继续下一步。然后完成，其余配置都是用默认配置。</p><h2 id="使用Navicat-for-MySQL-管理MySQL"><a href="#使用Navicat-for-MySQL-管理MySQL" class="headerlink" title="使用Navicat for MySQL 管理MySQL"></a>使用Navicat for MySQL 管理MySQL</h2><p><a href="https://www.navicat.com.cn/download/navicat-for-mysql" target="_blank" rel="noopener">下载地址</a><br>可以用它去管理MySQL。新建库，新建表，修改数据删除数据。</p><h2 id="MySQL基本概念"><a href="#MySQL基本概念" class="headerlink" title="MySQL基本概念"></a>MySQL基本概念</h2><p>库： 文件夹-用来管理，无法存放数据，一个库可以存放很多张表。<br>表： 文件-存放数据用的。<br>列: 一列(数据元素) 包含了相同的数据, 例如用户的数据。<br>行：一行是一组相关的数据，例如一条用户名和密码的数据。<br>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。<br>外键：外键用于关联两个表。</p><h2 id="MySQL常用数据类型"><a href="#MySQL常用数据类型" class="headerlink" title="MySQL常用数据类型"></a>MySQL常用数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INT</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">DATE</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">变长字符串</td></tr><tr><td style="text-align:center">CHAR</td><td style="text-align:center">定长字符串</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md" target="_blank" rel="noopener">https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows下安装MySQL&quot;&gt;&lt;a href=&quot;#Windows下安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;Windows下安装MySQL&quot;&gt;&lt;/a&gt;Windows下安装MySQL&lt;/h1&gt;&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;br&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://blog.langpz.com/tags/Windows/"/>
    
      <category term="MySQL" scheme="http://blog.langpz.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Express路由</title>
    <link href="http://blog.langpz.com/Express%E8%B7%AF%E7%94%B1.html"/>
    <id>http://blog.langpz.com/Express路由.html</id>
    <published>2018-05-07T17:50:08.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express路由"><a href="#Express路由" class="headerlink" title="Express路由"></a>Express路由</h1><p>之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。<br><a id="more"></a></p><p>一个网站下面可能有很多地址例如:<br>www.langpz.com/aaa<br>user/<br>www.langpz.com/user/aaa<br>www.langpz.com/user/bbb<br>www.langpz.com/user/ccc<br>vip/<br>www.langpz.com/vip/aaa<br>www.langpz.com/vip/bbb<br>www.langpz.com/vip/ccc<br>等等。。。<br>咱们可以拆分成vip和user两个目录目录下再放子路由。<br>先安装express 然后在项目根目录建一个app.js和routers文件夹，routers文件夹里面再建一个index.js文件和vip、user两个目录，两个目录下面分别建立index.js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const routers = require(&apos;./routers&apos;);  //引入路由</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/vip&apos;, routers.vip);   // 设置/vip路由中间件</span><br><span class="line">app.use(&apos;/user&apos;, routers.user);  // 设置/user路由中间件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// routers/index.js</span><br><span class="line">let vip = require(&apos;./vip&apos;); // 引入vip文件下面的路由</span><br><span class="line">let user = require(&apos;./user&apos;);   // 引入user文件下面的路由</span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    vip,</span><br><span class="line">    user</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// routers/vip/index.js</span><br><span class="line">const express = require(&apos;express&apos;); // 必须要引入express</span><br><span class="line"></span><br><span class="line">let routerVip = express.Router();   // 创建router实例</span><br><span class="line"></span><br><span class="line">// 添加路由配置</span><br><span class="line">routerVip.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip根目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerVip.get(&apos;/aaa&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip/aaa目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerVip.get(&apos;/bbb&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip/bbb目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = routerVip;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// routers/user/index.js</span><br><span class="line">const express = require(&apos;express&apos;); // 必须要引入express</span><br><span class="line"></span><br><span class="line">let routerUser = express.Router();  // 创建router实例</span><br><span class="line"></span><br><span class="line">// 添加路由配置</span><br><span class="line">routerUser.get(&apos;/&apos;, (req, res) =&gt;&#123;</span><br><span class="line">    res.send(&apos;我是user根目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerUser.get(&apos;/aaa&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是user/aaa目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerUser.get(&apos;/bbb&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是user/bbb目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = routerUser;</span><br></pre></td></tr></table></figure><p>然后执行 node app.js 再浏览器输入<a href="http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。" target="_blank" rel="noopener">http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express路由&quot;&gt;&lt;a href=&quot;#Express路由&quot; class=&quot;headerlink&quot; title=&quot;Express路由&quot;&gt;&lt;/a&gt;Express路由&lt;/h1&gt;&lt;p&gt;之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="路由" scheme="http://blog.langpz.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Express框架cookie和session</title>
    <link href="http://blog.langpz.com/Express%E6%A1%86%E6%9E%B6cookie%E5%92%8Csession.html"/>
    <id>http://blog.langpz.com/Express框架cookie和session.html</id>
    <published>2018-05-06T17:32:54.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express框架cookie和session"><a href="#Express框架cookie和session" class="headerlink" title="Express框架cookie和session"></a>Express框架cookie和session</h1><p>HTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。<br><a id="more"></a></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie存在浏览器端，每次请求都会带上。<br>    缺点：不安全(用户可以随便串改)，大小（4k）。</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session只存在服务器端。<br>    优点：容量不限，比较安全（用户接触不到）。<br>    session实现是基于cookie的。<br>风险：session_id 被泄露漏 session劫持。<br>    提醒用户不在在控制台输入(console)输入代码。<br>    session_id 足够复杂，定期更换。</p><h2 id="Express操作cookie"><a href="#Express操作cookie" class="headerlink" title="Express操作cookie"></a>Express操作cookie</h2><p>先安装cookie-parser。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cookie-parser -S</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser()); // 设置cookieParser 中间件</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.cookies); // 获取cookie</span><br><span class="line">    res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;); // 设置cookie</span><br><span class="line">    res.send(&apos;OK&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在cmd执行 node app.js 浏览器输入<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 第一次控制台输出{}，再刷新就输出{user: ‘lanpangzhi’ }。<br>现在就能获取和设置cookie了，但是有个问题，浏览器执行document.cookie = “user=aaa”,浏览器再刷新控制台就会输出{user: ‘aaa’ }。<br>这样使用cookie不安全，敏感信息容易被篡改，所以要使用带签名的cookie。</p><p>带签名的cookie<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(&apos;abc123456abc&apos;)); // 设置cookieParser 中间件  使用签名必须要设置字符串。</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.cookies); // 获取cookie</span><br><span class="line">    console.log(req.signedCookies); // 获取带签名的cookie</span><br><span class="line">    res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;, &#123;</span><br><span class="line">        signed: true // 设置带签名的cookie</span><br><span class="line">    &#125;); </span><br><span class="line">    res.send(&apos;OK&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><p>再执行，就会发现浏览器cookie的值变成了s%3Alanpangzhi.i6hEUuhD%2Fd0miBMsGyRdktiDFmi%2BYfiJhQTcqKpQqIc ，再修改cookie的值，控制台就会输出{ user: false }，这样cookie就不会被简单的篡改了。</p><p>req.cookies 获取cookie。<br>res.cookie(name, value [, options]);<br>    name: cookie的名称(string)。<br>    value: cookie的值，(string or object)。<br>    options：options参数是一个可以具有以下属性的对象。</p><h3 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h3><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">domain</td><td style="text-align:center">String</td><td style="text-align:left">cookie的域名。 默认为网站的域名。</td></tr><tr><td style="text-align:center">encode</td><td style="text-align:center">Function</td><td style="text-align:left">用于cookie值编码的同步函数。 默认为encodeURIComponent。</td></tr><tr><td style="text-align:center">expires</td><td style="text-align:center">Date</td><td style="text-align:left">cookie的有效期（如果未指定或设置为0），则创建会话cookie。</td></tr><tr><td style="text-align:center">httpOnly</td><td style="text-align:center">Boolean</td><td style="text-align:left">将cookie标记为仅可由Web服务器访问。默认false</td></tr><tr><td style="text-align:center">maxAge</td><td style="text-align:center">Number</td><td style="text-align:left">设置cookie的到期时间、相对于当前时间的到期时间（以毫秒为单位）。</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">String</td><td style="text-align:left">cookie的路径。 默认为“/”</td></tr><tr><td style="text-align:center">secure</td><td style="text-align:center">Boolean</td><td style="text-align:left">将cookie标记为仅与HTTPS一起使用。默认false</td></tr><tr><td style="text-align:center">signed</td><td style="text-align:center">Boolean</td><td style="text-align:left">对cookie进行签名。默认false</td></tr></tbody></table><h2 id="Express操作session"><a href="#Express操作session" class="headerlink" title="Express操作session"></a>Express操作session</h2><p>先安装cookie-session。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cookie-session -S</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieSession = require(&apos;cookie-session&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieSession(&#123;</span><br><span class="line">    secret: &apos;aaaa&apos;</span><br><span class="line">&#125;));  // 设置cookieSession中间件</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    if (req.session[&apos;num&apos;]) &#123;</span><br><span class="line">        req.session[&apos;num&apos;]++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        req.session[&apos;num&apos;] = 1; // 设置session</span><br><span class="line">    &#125;</span><br><span class="line">    res.send(`访问$&#123;req.session[&quot;num&quot;]&#125;次`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在cmd执行 node app.js 浏览器输入<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a>  刷新浏览器就可以看到访问几次，把所有浏览器都关闭session就失效了，再进入页面就从第一次开始了。<br>更多方法还有详细参数可以去github自行参考。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://expressjs.com/en/4x/api.html" target="_blank" rel="noopener">http://expressjs.com/en/4x/api.html</a><br><a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="noopener">https://github.com/expressjs/cookie-parser</a><br><a href="https://github.com/expressjs/cookie-session" target="_blank" rel="noopener">https://github.com/expressjs/cookie-session</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express框架cookie和session&quot;&gt;&lt;a href=&quot;#Express框架cookie和session&quot; class=&quot;headerlink&quot; title=&quot;Express框架cookie和session&quot;&gt;&lt;/a&gt;Express框架cookie和session&lt;/h1&gt;&lt;p&gt;HTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="cookie" scheme="http://blog.langpz.com/tags/cookie/"/>
    
      <category term="session" scheme="http://blog.langpz.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据类型转换</title>
    <link href="http://blog.langpz.com/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://blog.langpz.com/javascript数据类型转换.html</id>
    <published>2018-05-05T17:14:25.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript数据类型转换"><a href="#javascript数据类型转换" class="headerlink" title="javascript数据类型转换"></a>javascript数据类型转换</h1><p>在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。<br><a id="more"></a></p><h2 id="默认是false的五个值"><a href="#默认是false的五个值" class="headerlink" title="默认是false的五个值"></a>默认是false的五个值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null undefined NaN 0 &apos;&apos;</span><br></pre></td></tr></table></figure><p>记住只有这五个值是假的剩下的全部是真的。</p><h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><ol><li>如果是一个值判断是否是真假，除了默认是false的五个值剩下的全部是true。</li><li>如果是两个值比较是否相等，遵循如下规则。<br> val1 == val2 如果两个值可能不是同一数据类型，如果是==比较的话，会默认进行数据转换。<br> 2.1 object == object，比较永远不相等。<br> 2.2 object == string 先将对象转换成字符串（调用toString方法），然后再比较。<pre><code>[] 转换成字符串 &quot;&quot;{} 转换成字符串 &quot;[object Object]&quot;</code></pre> 2.3 object == boolean 先将对象转换成字符串（toString），再把字符串转换成数字（Number）、布尔值转换成数字（true 转换成 1 false 换成成 0）然后让两个数字进行比较。<pre><code>Number(&quot;&quot;) 会输出 0</code></pre> 2.4 object == number  先将对象转换成字符串（toString），再把字符串转换成数字（Number），再进行比较。<br> 2.5 number == boolean 布尔值转换成数字，然后再比较。<br> 2.6 number == string  字符串转换成数字，然后再比较。<br> 2.7 string == boolean 都转换成数字，，然后再比较。<br> 2.8 null == undefined 结果是true。<br> 2.9 null 或者 undefined 比较另外的所有值，结果都是false，不相等。</li></ol><p>例如：<br>    [] == false 返回 true 2.3规则。<br>     [] == []  返回 false 2.1规则。<br>     2 == true 返回 false 2.5规则。<br>=== 三个等号还会比较数据类型。<br>这些规则背下来，就能完美的应该这样的面试题了，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript数据类型转换&quot;&gt;&lt;a href=&quot;#javascript数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;javascript数据类型转换&quot;&gt;&lt;/a&gt;javascript数据类型转换&lt;/h1&gt;&lt;p&gt;在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.langpz.com/tags/javascript/"/>
    
      <category term="数据类型转换" scheme="http://blog.langpz.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="面试题" scheme="http://blog.langpz.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Git生成SSH公钥</title>
    <link href="http://blog.langpz.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5.html"/>
    <id>http://blog.langpz.com/Git生成SSH公钥.html</id>
    <published>2018-05-05T16:40:31.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git生成SSH公钥"><a href="#Git生成SSH公钥" class="headerlink" title="Git生成SSH公钥"></a>Git生成SSH公钥</h1><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。<br><a id="more"></a></p><h2 id="查看公钥是否生成过"><a href="#查看公钥是否生成过" class="headerlink" title="查看公钥是否生成过"></a>查看公钥是否生成过</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls  # 在Git bash下执行</span><br></pre></td></tr></table></figure><p>或者 C:\Users\Administrator.ssh 访问这个目录。<br>看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。如果有公钥直接打开 id_rsa.pub 文件添加到GitHub和coding的SSH公钥里面，建议coding有效期选永久。</p><h2 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h2><p>执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p><p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。<br>直接回车就行。<br>然后去C:\Users\Administrator.ssh目录 找到id_rsa.pub 文件就是生成好的公钥，添加到GitHub和coding。<br>公钥的大概样子，全部复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@agadorlaptop.local</span><br></pre></td></tr></table></figure></p><h2 id="测试公钥是否添加成功"><a href="#测试公钥是否添加成功" class="headerlink" title="测试公钥是否添加成功"></a>测试公钥是否添加成功</h2><p>测试GitHub。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5/QQ%E5%9B%BE%E7%89%8720180505165306.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在就添加成功了。</p><p>测试Coding<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5/QQ%E5%9B%BE%E7%89%8720180505170650.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git生成SSH公钥&quot;&gt;&lt;a href=&quot;#Git生成SSH公钥&quot; class=&quot;headerlink&quot; title=&quot;Git生成SSH公钥&quot;&gt;&lt;/a&gt;Git生成SSH公钥&lt;/h1&gt;&lt;p&gt;大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.langpz.com/tags/Git/"/>
    
      <category term="SSH公钥" scheme="http://blog.langpz.com/tags/SSH%E5%85%AC%E9%92%A5/"/>
    
  </entry>
  
  <entry>
    <title>Express文件上传</title>
    <link href="http://blog.langpz.com/Express%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.html"/>
    <id>http://blog.langpz.com/Express文件上传.html</id>
    <published>2018-05-04T15:58:58.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express文件上传"><a href="#Express文件上传" class="headerlink" title="Express文件上传"></a>Express文件上传</h1><p>在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。<br><a id="more"></a></p><h2 id="安装Multer"><a href="#安装Multer" class="headerlink" title="安装Multer"></a>安装Multer</h2><p>第一步先安装Multer到你的项目里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save multer</span><br></pre></td></tr></table></figure></p><h2 id="创建一个form表单"><a href="#创建一个form表单" class="headerlink" title="创建一个form表单"></a>创建一个form表单</h2><p>这里就不用ajax去上传了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="form表单enctype属性"><a href="#form表单enctype属性" class="headerlink" title="form表单enctype属性"></a>form表单enctype属性</h2><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">application/x-www-form-urlencoded</td><td style="text-align:center">在发送前编码所有字符（默认）</td></tr><tr><td style="text-align:center">multipart/form-data</td><td style="text-align:center">不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</td></tr><tr><td style="text-align:center">text/plain</td><td style="text-align:center">空格转换为 “+” 加号，但不对特殊字符编码。</td></tr></tbody></table><h2 id="引用配置multer"><a href="#引用配置multer" class="headerlink" title="引用配置multer"></a>引用配置multer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const multer = require(&apos;multer&apos;);</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">const uploda = multer(&#123;</span><br><span class="line">    dest: &apos;./uploads/&apos; // 服务接收文件的路径</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(uploda.any()); // multer放到express中间件里</span><br><span class="line"></span><br><span class="line">app.post(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.files); // req.files接收到的文件信息一个数组</span><br><span class="line">    // 添加后缀名，只支持一个文件上加后缀名，多文件改成递归</span><br><span class="line">    let newName = req.files[0].path + path.extname(req.files[0].originalname);</span><br><span class="line">    console.log(newName, req.files[0].path);</span><br><span class="line">    fs.rename(req.files[0].path, newName, (err) =&gt; &#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            res.sendStatus(500).send(&apos;error&apos;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.send(&apos;OK，上传成功。&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在cmd执行 node app.js 打开index.html 选择文件上传，服务端就可以成功接收文件了。<br>multer 还有一些别的方法和参数，可自行去github查看。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/expressjs/multer" target="_blank" rel="noopener">https://github.com/expressjs/multer</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express文件上传&quot;&gt;&lt;a href=&quot;#Express文件上传&quot; class=&quot;headerlink&quot; title=&quot;Express文件上传&quot;&gt;&lt;/a&gt;Express文件上传&lt;/h1&gt;&lt;p&gt;在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="文件上传" scheme="http://blog.langpz.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>javascript数组去重(ES6版)</title>
    <link href="http://blog.langpz.com/javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D-ES6%E7%89%88.html"/>
    <id>http://blog.langpz.com/javascript数组去重-ES6版.html</id>
    <published>2018-05-02T16:49:44.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript数组去重-ES6版"><a href="#javascript数组去重-ES6版" class="headerlink" title="javascript数组去重(ES6版)"></a>javascript数组去重(ES6版)</h1><p>之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。<br>今天就利用 Set 来去重。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3,4,5,&apos;1&apos;,&apos;2&apos;,3,3,&apos;1&apos;];</span><br><span class="line">arr = Array.from(new Set(arr));</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><p>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</p><p><a href="https://jsbin.com/buyowuk/edit?js,console" target="_blank" rel="noopener">jsBin 地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript数组去重-ES6版&quot;&gt;&lt;a href=&quot;#javascript数组去重-ES6版&quot; class=&quot;headerlink&quot; title=&quot;javascript数组去重(ES6版)&quot;&gt;&lt;/a&gt;javascript数组去重(ES6版)&lt;/h1&gt;&lt;p&gt;之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。&lt;br&gt;今天就利用 Set 来去重。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.langpz.com/tags/javascript/"/>
    
      <category term="数组" scheme="http://blog.langpz.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="ES6" scheme="http://blog.langpz.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>css实现元素垂直水平居中-包括未知宽高的元素</title>
    <link href="http://blog.langpz.com/css%E5%AE%9E%E7%8E%B0%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD-%E5%8C%85%E6%8B%AC%E6%9C%AA%E7%9F%A5%E5%AE%BD%E9%AB%98%E7%9A%84%E5%85%83%E7%B4%A0.html"/>
    <id>http://blog.langpz.com/css实现元素垂直居中-包括未知宽高的元素.html</id>
    <published>2018-04-28T13:14:04.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css实现元素垂直水平居中-包括未知宽高的元素"><a href="#css实现元素垂直水平居中-包括未知宽高的元素" class="headerlink" title="css实现元素垂直水平居中-包括未知宽高的元素"></a>css实现元素垂直水平居中-包括未知宽高的元素</h1><p>这个一道很经典的面试题，做项目中也常会出现这样的需求。<br>现在我就用几种比较常用的方法。兼容性也列出来。<br><a id="more"></a></p><h2 id="第一种已知宽高（定位加负边距解决）兼容到IE6"><a href="#第一种已知宽高（定位加负边距解决）兼容到IE6" class="headerlink" title="第一种已知宽高（定位加负边距解决）兼容到IE6"></a>第一种已知宽高（定位加负边距解决）兼容到IE6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">z-index: 8;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">margin-left: -100px;</span><br><span class="line">margin-top: -100px;</span><br><span class="line">background: red;</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/xabolah/1/edit?html,output" target="_blank" rel="noopener">demo地址 JSBin</a></p><h2 id="第二种未知宽高-定位加margin解决-兼容到IE8-移动端推荐使用"><a href="#第二种未知宽高-定位加margin解决-兼容到IE8-移动端推荐使用" class="headerlink" title="第二种未知宽高 (定位加margin解决) 兼容到IE8 移动端推荐使用"></a>第二种未知宽高 (定位加margin解决) 兼容到IE8 移动端推荐使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">z-index: 8;</span><br><span class="line">left: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: 0;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">margin: auto;</span><br><span class="line">background: red;</span><br></pre></td></tr></table></figure><p>如果改变宽度和高度还是垂直水平居中的。<br><a href="http://jsbin.com/pulamek/edit?html,css,output" target="_blank" rel="noopener">demo地址 JSBin</a></p><h2 id="第三种未知宽高-定位加transform解决-兼容到IE9-移动端推荐使用"><a href="#第三种未知宽高-定位加transform解决-兼容到IE9-移动端推荐使用" class="headerlink" title="第三种未知宽高 (定位加transform解决) 兼容到IE9 移动端推荐使用"></a>第三种未知宽高 (定位加transform解决) 兼容到IE9 移动端推荐使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">z-index: 8;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">background: red;</span><br></pre></td></tr></table></figure><p>如果改变宽度和高度还是垂直水平居中的。<br><a href="http://jsbin.com/noyise/edit?html,css,output" target="_blank" rel="noopener">demo地址 JSBin</a></p><h2 id="第四种未知宽高-弹性盒子模型解决-兼容到IE10"><a href="#第四种未知宽高-弹性盒子模型解决-兼容到IE10" class="headerlink" title="第四种未知宽高 (弹性盒子模型解决) 兼容到IE10"></a>第四种未知宽高 (弹性盒子模型解决) 兼容到IE10</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">display: -webkit-flex;</span><br><span class="line">align-items:center;</span><br><span class="line">justify-content: center;</span><br></pre></td></tr></table></figure><p>如果改变宽度和高度还是垂直水平居中的。<br><a href="http://jsbin.com/zimalig/edit?html,css,output" target="_blank" rel="noopener">demo地址 JSBin</a></p><h2 id="第五种未知宽高-table特性解决的-兼容到IE6-PC端推荐使用"><a href="#第五种未知宽高-table特性解决的-兼容到IE6-PC端推荐使用" class="headerlink" title="第五种未知宽高 (table特性解决的) 兼容到IE6 PC端推荐使用"></a>第五种未知宽高 (table特性解决的) 兼容到IE6 PC端推荐使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#box&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">height:100px;</span><br><span class="line">text-align:center;</span><br><span class="line">font-size:0;</span><br><span class="line">    background: red</span><br><span class="line">&#125;</span><br><span class="line">#box:after,#box span&#123;</span><br><span class="line">display:inline-block;</span><br><span class="line">*display:inline;</span><br><span class="line">*zoom:1;</span><br><span class="line">width:0;</span><br><span class="line">height:100%;</span><br><span class="line">vertical-align:middle;</span><br><span class="line">&#125;</span><br><span class="line">#box:after&#123;</span><br><span class="line">content:&apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">#box p&#123;</span><br><span class="line">display:inline-block;</span><br><span class="line">*display:inline;</span><br><span class="line">*zoom:1;</span><br><span class="line">vertical-align:middle;</span><br><span class="line">font-size:16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://jsbin.com/pipasoq/edit?html,css,output" target="_blank" rel="noopener">demo地址 JSBin</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://demo.doyoe.com/css/alignment/" target="_blank" rel="noopener">http://demo.doyoe.com/css/alignment/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;css实现元素垂直水平居中-包括未知宽高的元素&quot;&gt;&lt;a href=&quot;#css实现元素垂直水平居中-包括未知宽高的元素&quot; class=&quot;headerlink&quot; title=&quot;css实现元素垂直水平居中-包括未知宽高的元素&quot;&gt;&lt;/a&gt;css实现元素垂直水平居中-包括未知宽高的元素&lt;/h1&gt;&lt;p&gt;这个一道很经典的面试题，做项目中也常会出现这样的需求。&lt;br&gt;现在我就用几种比较常用的方法。兼容性也列出来。&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://blog.langpz.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>EJS模板引擎</title>
    <link href="http://blog.langpz.com/ejs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.html"/>
    <id>http://blog.langpz.com/ejs模板引擎.html</id>
    <published>2018-04-27T13:36:44.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EJS模板引擎"><a href="#EJS模板引擎" class="headerlink" title="EJS模板引擎"></a>EJS模板引擎</h1><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。<br>Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。<br><a id="more"></a></p><h2 id="安装EJS"><a href="#安装EJS" class="headerlink" title="安装EJS"></a>安装EJS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ejs</span><br></pre></td></tr></table></figure><h2 id="Express设置EJS模板"><a href="#Express设置EJS模板" class="headerlink" title="Express设置EJS模板"></a>Express设置EJS模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);   # views, 放模板文件的目录</span><br></pre></td></tr></table></figure><h2 id="将值输出到模板（HTML转义）"><a href="#将值输出到模板（HTML转义）" class="headerlink" title="将值输出到模板（HTML转义）"></a>将值输出到模板（HTML转义）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.ejs</span><br><span class="line">&lt;%= arr %&gt;</span><br><span class="line"></span><br><span class="line">// Node</span><br><span class="line">res.render(&apos;index&apos;, &#123;arr: [1,2,3,4]&#125;);</span><br></pre></td></tr></table></figure><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  if (user) &#123; %&gt;</span><br><span class="line">    &lt;p&gt; &lt;%= user %&gt; &lt;/p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% for (var i = 0; i &lt; arr.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= arr[i] %&gt;&lt;/li&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h2 id="include（不转义）"><a href="#include（不转义）" class="headerlink" title="include（不转义）"></a>include（不转义）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- include(&apos;./common/header.ejs&apos;) %&gt;</span><br></pre></td></tr></table></figure><h2 id="EJS标签"><a href="#EJS标签" class="headerlink" title="EJS标签"></a>EJS标签</h2><ul><li>&lt;%    ‘脚本’ 标签，用于流程控制，无输出。</li><li>&lt;%_   删除其前面的空格符</li><li>&lt;%=   输出数据到模板（输出是转义 HTML 标签）</li><li>&lt;%-   输出非转义的数据到模板</li><li>&lt;%#   注释标签，不执行、不输出内容</li><li>&lt;%%   输出字符串 ‘&lt;%’</li><li>%&gt;    一般结束标签</li><li>-%&gt;   删除紧随其后的换行符</li><li>_%&gt;   将结束标签后面的空格符删除</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;EJS模板引擎&quot;&gt;&lt;a href=&quot;#EJS模板引擎&quot; class=&quot;headerlink&quot; title=&quot;EJS模板引擎&quot;&gt;&lt;/a&gt;EJS模板引擎&lt;/h1&gt;&lt;p&gt;模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。&lt;br&gt;Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。&lt;br&gt;
    
    </summary>
    
    
      <category term="EJS" scheme="http://blog.langpz.com/tags/EJS/"/>
    
  </entry>
  
  <entry>
    <title>Express中间件body-parser简单实现</title>
    <link href="http://blog.langpz.com/Express%E4%B8%AD%E9%97%B4%E4%BB%B6body-parser%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://blog.langpz.com/Express中间件body-parser简单实现.html</id>
    <published>2018-04-18T11:49:16.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express中间件body-parser简单实现"><a href="#Express中间件body-parser简单实现" class="headerlink" title="Express中间件body-parser简单实现"></a>Express中间件body-parser简单实现</h1><p>之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。<br><a id="more"></a><br>首先通过命令提示输入 mkdir lib &amp;&amp; cd lib。<br>再输入touch body-parser.js。<br>把下面的代码在body-parser.js 敲一遍。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// lib/body-parser.js</span><br><span class="line">const querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">module.exports.urlencoded = function (req, res, next) &#123;</span><br><span class="line">    let chunks = [];</span><br><span class="line">    req.on(&apos;data&apos;, data =&gt; &#123;</span><br><span class="line">        chunks.push(data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">        // 合并Buffer。</span><br><span class="line">        let buf = Buffer.concat(chunks).toString();</span><br><span class="line">        // 把querystring解析过的json 放到 req.body上。</span><br><span class="line">        req.body = querystring.parse(buf);</span><br><span class="line">        next();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是主程序代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const bodyParser = require(&apos;./lib/body-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.post(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><p>现在就完成和body-parser中间件类似的功能了，req.body上面有请求过来的post数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express中间件body-parser简单实现&quot;&gt;&lt;a href=&quot;#Express中间件body-parser简单实现&quot; class=&quot;headerlink&quot; title=&quot;Express中间件body-parser简单实现&quot;&gt;&lt;/a&gt;Express中间件body-parser简单实现&lt;/h1&gt;&lt;p&gt;之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Express处理数据请求</title>
    <link href="http://blog.langpz.com/Express%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82.html"/>
    <id>http://blog.langpz.com/Express处理数据请求.html</id>
    <published>2018-04-02T17:28:39.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express处理数据请求"><a href="#Express处理数据请求" class="headerlink" title="Express处理数据请求"></a>Express处理数据请求</h1><p>之前文章里面介绍了如何用原生Node处理数据请求。<br>现在通过Express框架处理post和get请求。<br><a id="more"></a></p><h2 id="处理get请求"><a href="#处理get请求" class="headerlink" title="处理get请求"></a>处理get请求</h2><p>这个比较简单(不需要使用中间件)直接req.query就能获取到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.query);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 客户端代码</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000&quot; method=&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。<br>就可以获取到一个json对象如 { user: ‘123’, pass: ‘abc’ } 方便操作。</p><h2 id="处理post请求"><a href="#处理post请求" class="headerlink" title="处理post请求"></a>处理post请求</h2><p>处理post请求需要用到body-parser这个中间件。<br>这个中间件可以解析JSON、Raw、文本、URL-encoded格式的请求体。<br>先安装中间件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install body-parser</span><br></pre></td></tr></table></figure></p><p>在项目中引用body-parser中间件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const bodyParser = require(&apos;body-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">// 引用body-parser中间件</span><br><span class="line">app.use(bodyParser.urlencoded());</span><br><span class="line"></span><br><span class="line">app.post(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    // req.body post 提交过来的数据</span><br><span class="line">    console.log(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 客户端代码</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。<br>就可以获取到一个json对象如 { user: ‘lanpangzhi’, pass: ‘123456’ } 方便操作。<br>这样我们就通过Express获取到get和post提交过来的数据了。</p><p>urlencoded() 方法配置参数 (options)</p><ul><li>extended 设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true。但使用默认已被弃用。 请研究qs和querystring之间的差异并选择适当的设置。</li><li>inflate  设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。</li><li>limit 设置最大请求头大小， 如果这是一个数字，那么该值指定字节数; 如果它是一个字符串，则将该值传递给字节库解析。默认为100kb。</li><li>parameterLimit  用于设置URL编码值的最大参数数量， 如果请求包含的参数多于此值，那么413将返回给客户端。默认为1000。</li><li>type  用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。</li><li>verify  这个选项仅在verify(req, res, buf, encoding)时受支持。</li></ul><p>body-parser里面还有另外几个方法，可以自行去github看下。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[<a href="https://github.com/expressjs/body-parser" target="_blank" rel="noopener">https://github.com/expressjs/body-parser</a>]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express处理数据请求&quot;&gt;&lt;a href=&quot;#Express处理数据请求&quot; class=&quot;headerlink&quot; title=&quot;Express处理数据请求&quot;&gt;&lt;/a&gt;Express处理数据请求&lt;/h1&gt;&lt;p&gt;之前文章里面介绍了如何用原生Node处理数据请求。&lt;br&gt;现在通过Express框架处理post和get请求。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>express简单入坑</title>
    <link href="http://blog.langpz.com/express%E7%AE%80%E5%8D%95%E5%85%A5%E5%9D%91.html"/>
    <id>http://blog.langpz.com/express简单入坑.html</id>
    <published>2018-03-19T13:38:00.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express简单入坑"><a href="#express简单入坑" class="headerlink" title="express简单入坑"></a>express简单入坑</h1><p>Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init </span><br><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><h2 id="创建第一个应用"><a href="#创建第一个应用" class="headerlink" title="创建第一个应用"></a>创建第一个应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;express&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在命令行执行 node app.js 浏览器输入 <a href="http://localhost:8000/就可以访问了。" target="_blank" rel="noopener">http://localhost:8000/就可以访问了。</a></p><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><h3 id="app-get-path-request-response-gt"><a href="#app-get-path-request-response-gt" class="headerlink" title="app.get(path, (request, response) =&gt; {})"></a>app.get(path, (request, response) =&gt; {})</h3><p>根据path处理客户端发过来的GET请求。<br>第一个参数：path请求的路径。<br>第二个参数：回调函数，request(请求),response(响应)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;home&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&apos;/hello&apos;,(req,res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="app-post-path-request-response-gt"><a href="#app-post-path-request-response-gt" class="headerlink" title="app.post(path, (request, response) =&gt; {})"></a>app.post(path, (request, response) =&gt; {})</h3><p>根据path处理客户端发过来的POST请求。<br>参数和app.get()方法一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.post(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;home&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.post(&apos;/hello&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="app-all-path-request-response-gt"><a href="#app-all-path-request-response-gt" class="headerlink" title="app.all(path, (request, response) =&gt; {})"></a>app.all(path, (request, response) =&gt; {})</h3><p>根据path处理客户端发过来的所有http(GET,POST,PUT,DELETE,HEAD)请求。<br>参数和app.get()方法一样。</p><p>res.send()  发送各种类型的响应。<br>res.download() 提示下载文件。<br>res.redirect() 重定向请求。<br>res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</p><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。<br>只需要把文件目录作为参数传给express.static，之后就可以访问到静态文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&apos;./public&apos;))</span><br></pre></td></tr></table></figure></p><p>注： 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Express应用就是在调用各种中间件完成功能的，如cookie解析、文件上传、静态文件等。<br>中间件（Middleware） 是一个函数。它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。<br>如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(&apos;aaa&apos;);</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(&apos;bbb&apos;);</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">    console.log(&apos;ccc&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以看到next 的作用，把控制器交给下一个中间件。<br>可以利用中间件特性来处理登陆用户。</p><ol><li>检查数据是否合法。</li><li>检查数据是否存在。</li><li>检查数据密码是否正确。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    if(合法)&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(&apos;用户名不合法&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    if(存在)&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(&apos;用户名不存在&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    if(密码正确)&#123;</span><br><span class="line">        res.send(&apos;登陆成功&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(&apos;密码不正确&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>中间件的大概用法就是这样。</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>先安装ejs模板<br>npm install ejs -S<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);   # views, 放模板文件的目录</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const ejs = require(&apos;ejs&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.render(&apos;index&apos;,&#123;title: &apos;hello&apos;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// index.ejs</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%= title %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在命令行里执行node index.js，就可以看到模板了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;express简单入坑&quot;&gt;&lt;a href=&quot;#express简单入坑&quot; class=&quot;headerlink&quot; title=&quot;express简单入坑&quot;&gt;&lt;/a&gt;express简单入坑&lt;/h1&gt;&lt;p&gt;Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>node处理前台get请求</title>
    <link href="http://blog.langpz.com/node%E5%A4%84%E7%90%86%E5%89%8D%E5%8F%B0get%E8%AF%B7%E6%B1%82.html"/>
    <id>http://blog.langpz.com/node处理前台get请求.html</id>
    <published>2018-03-02T10:07:32.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js处理前台get请求"><a href="#node-js处理前台get请求" class="headerlink" title="node.js处理前台get请求"></a>node.js处理前台get请求</h1><p>下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。<br><a id="more"></a></p><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">let app = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    let getUrl = url.parse(req.url, true);</span><br><span class="line">    if (getUrl.pathname === &apos;/getUser&apos;)&#123;</span><br><span class="line">        console.log(url.parse(req.url, true).query);</span><br><span class="line">        res.end(url.parse(req.url, true).query.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>先搭一个服务器监听8000端口，再把请求的链接用URL模块解析成对象，判断请求路径，返回user。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000/getUser&quot; method=&quot;get&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在命令行执行 node http.js。<br>打开index.html 输入数据，点击提交按钮。<br>node输出 { user: ‘123’, pass: ‘abc’ }  123和abc 就是你输入的数据。<br>前台页面会显示你输入的user。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node-js处理前台get请求&quot;&gt;&lt;a href=&quot;#node-js处理前台get请求&quot; class=&quot;headerlink&quot; title=&quot;node.js处理前台get请求&quot;&gt;&lt;/a&gt;node.js处理前台get请求&lt;/h1&gt;&lt;p&gt;下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>url模块</title>
    <link href="http://blog.langpz.com/url%E6%A8%A1%E5%9D%97.html"/>
    <id>http://blog.langpz.com/url模块.html</id>
    <published>2018-03-01T16:03:22.000Z</published>
    <updated>2018-05-17T05:09:39.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h1><p>url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。<br>模块只有三个方法，用起来也简单。<br><a id="more"></a></p><h2 id="url结构说明"><a href="#url结构说明" class="headerlink" title="url结构说明"></a>url结构说明</h2><p>网址：<a href="http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash" target="_blank" rel="noopener">http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/url%E6%A8%A1%E5%9D%97/QQ%E5%9B%BE%E7%89%8720180301164245.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>从node.js 中文网拿的图。</p><h2 id="url-parse-urlString-parseQueryString-slashesDenoteHost"><a href="#url-parse-urlString-parseQueryString-slashesDenoteHost" class="headerlink" title="url.parse(urlString[, parseQueryString[, slashesDenoteHost]])"></a>url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">console.log(url.parse(&apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;))</span><br></pre></td></tr></table></figure><p>把url字符串解析成url对象。输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  protocol: &apos;http:&apos;,</span><br><span class="line">  slashes: true,</span><br><span class="line">  auth: &apos;user:pass&apos;,</span><br><span class="line">  host: &apos;langpz.com:80&apos;,</span><br><span class="line">  port: &apos;80&apos;,</span><br><span class="line">  hostname: &apos;langpz.com&apos;,</span><br><span class="line">  hash: &apos;#top&apos;,</span><br><span class="line">  search: &apos;?callback=fn&apos;,</span><br><span class="line">  query: &apos;callback=fn&apos;,</span><br><span class="line">  pathname: &apos;/aaa/ccc/ddd&apos;,</span><br><span class="line">  path: &apos;/aaa/ccc/ddd?callback=fn&apos;,</span><br><span class="line">  href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos; &#125;</span><br></pre></td></tr></table></figure></p><ul><li>protocol: 请求协议。</li><li>slashes: slashes 属性是一个 boolean，如果 协议 中的冒号后面跟着两个 ASCII 斜杠字符（/），则值为 true。</li><li>auth： URL的用户名与密码部分。</li><li>host: URL的主机部分包括端口号。</li><li>port：主机的端口号。</li><li>hostname：主机名部分。</li><li>hash： 锚点部分。</li><li>search： 整个查询字符串部分，包括前面的?号</li><li>query: 查询字符串部分，不包括前面的?号</li><li>pathname：URL 的整个路径部分。</li><li>path： pathname 与 search 组成部分的串接。</li><li>href： 解析后的完整的 URL 字符串，protocol 和 host 都会被转换为小写的。</li></ul><p>第二个参数是布尔值，如果是 true，query值是一个对象。 默认为 false。<br>第三个参数是布尔值，如果是 true，则 // 之后至下一个 / 之前的字符串会被解析作为 host。 例如，//foo/bar 会被解析为 {host: ‘foo’, pathname: ‘/bar’} 而不是 {pathname: ‘//foo/bar’}。 默认为 false。</p><h2 id="url-format-urlObject"><a href="#url-format-urlObject" class="headerlink" title="url.format(urlObject)"></a>url.format(urlObject)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">console.log(url.format(&#123;</span><br><span class="line">    protocol: &apos;http:&apos;,</span><br><span class="line">    slashes: true,</span><br><span class="line">    auth: &apos;user:pass&apos;,</span><br><span class="line">    host: &apos;langpz.com:80&apos;,</span><br><span class="line">    port: &apos;80&apos;,</span><br><span class="line">    hostname: &apos;langpz.com&apos;,</span><br><span class="line">    hash: &apos;#top&apos;,</span><br><span class="line">    search: &apos;?callback=fn&apos;,</span><br><span class="line">    query: &apos;callback=fn&apos;,</span><br><span class="line">    pathname: &apos;/aaa/ccc/ddd&apos;,</span><br><span class="line">    path: &apos;/aaa/ccc/ddd?callback=fn&apos;,</span><br><span class="line">    href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>url.parse()的反向操作，把url对象解析成url字符串</p><h2 id="url-resolve-from-to"><a href="#url-resolve-from-to" class="headerlink" title="url.resolve(from, to)"></a>url.resolve(from, to)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let url = require(&apos;url&apos;);</span><br><span class="line"></span><br><span class="line">console.log(url.resolve(&apos;/one/two/three&apos;,&apos;four&apos;))  # 输出 /one/two/four</span><br><span class="line">console.log(url.resolve(&apos;http://blog.langpz.com/&apos;, &apos;aaa&apos;))  # 输出  http://blog.langpz.com/aaa</span><br><span class="line">console.log(url.resolve(&apos;http://blog.langpz.com/aaa&apos;, &apos;bbb&apos;))  # 输出 http://blog.langpz.com/bbb</span><br></pre></td></tr></table></figure><p>把最后一个/没有内容后面追加to参数，有内容则替换。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://nodejs.cn/api/url.html" target="_blank" rel="noopener">http://nodejs.cn/api/url.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;url模块&quot;&gt;&lt;a href=&quot;#url模块&quot; class=&quot;headerlink&quot; title=&quot;url模块&quot;&gt;&lt;/a&gt;url模块&lt;/h1&gt;&lt;p&gt;url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。&lt;br&gt;模块只有三个方法，用起来也简单。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>node处理前台post请求</title>
    <link href="http://blog.langpz.com/node%E5%A4%84%E7%90%86%E5%89%8D%E5%8F%B0post%E8%AF%B7%E6%B1%82.html"/>
    <id>http://blog.langpz.com/node处理前台post请求.html</id>
    <published>2018-03-01T10:29:37.000Z</published>
    <updated>2018-05-17T05:09:39.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-js处理前台post请求"><a href="#node-js处理前台post请求" class="headerlink" title="node.js处理前台post请求"></a>node.js处理前台post请求</h1><p>下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。<br><a id="more"></a></p><h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// http.js</span><br><span class="line">let http = require(&apos;http&apos;);</span><br><span class="line">let querystring = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">let app = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    let str = &apos;&apos;;</span><br><span class="line">    if (req.url === &apos;/post&apos;)&#123;</span><br><span class="line">        req.on(&apos;data&apos;, (data) =&gt; &#123;</span><br><span class="line">            str += data;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        req.on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">            console.log(querystring.parse(str));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000)</span><br></pre></td></tr></table></figure><p>先搭一个服务器监听8000端口，判断请求路径，再绑定data事件接收客户端发过来的post请求，接受用querystring模块处理接收的数据。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;http://localhost:8000/post&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在命令行执行 node http.js。<br>打开index.html 输入数据，点击提交按钮。<br>node输出 { user: ‘123’, pass: ‘abc’ }  123和abc 就是你输入的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node-js处理前台post请求&quot;&gt;&lt;a href=&quot;#node-js处理前台post请求&quot; class=&quot;headerlink&quot; title=&quot;node.js处理前台post请求&quot;&gt;&lt;/a&gt;node.js处理前台post请求&lt;/h1&gt;&lt;p&gt;下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
  </entry>
  
</feed>
