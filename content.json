{"meta":{"title":"蓝胖纸","subtitle":"哆啦A梦","description":"我的大雄呢","author":"lanpangzhi","url":"http://blog.langpz.com"},"pages":[{"title":"","date":"2018-05-17T05:09:39.332Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"404.html","permalink":"http://blog.langpz.com/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/hibiki.model.json\"},\"display\":{\"position\":\"right\",\"width\":150,\"height\":320,\"hOffset\":1200,\"vOffset\":50},\"mobile\":{\"show\":false},\"react\":{\"opacityDefault\":1,\"opacityOnHover\":0.2}});"},{"title":"","date":"2018-05-17T05:09:39.336Z","updated":"2018-05-17T05:09:39.336Z","comments":false,"path":"tags/index.html","permalink":"http://blog.langpz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用travis-ci自动构建Hexo","slug":"使用travis-ci自动构建Hexo","date":"2018-05-15T16:30:49.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"使用travis-ci自动构建Hexo.html","link":"","permalink":"http://blog.langpz.com/使用travis-ci自动构建Hexo.html","excerpt":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。","text":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。 构建流程本地写完文章 =&gt; push github =&gt; GitHub触发Travis CI构建 =&gt; 执行命令 =&gt; 部署 =&gt; 完成。 用github登陆travis-cihttps://travis-ci.com然后添加到你要激活的存储库。 然后选择你要使用的仓库，我这里选择的是lanpangzhi.github.io，我放hexo博客的仓库。 然后生成SSH公钥1ssh-keygen -t rsa -C &quot;你的邮箱&quot; 然后找到 C:\\Users\\windows.ssh 下的 id_rsa.pub， 把内容添加到github和coding的hexo仓库的部署公钥里面。 然后在git仓库根目录 添加 .travis.yml 文件。12345678910111213141516171819language: node_jsnode_js:- 8.9.0cache: directories: - node_modulesbefore_install:- git config --global user.name &quot;lanpangzhi&quot;- git config --global user.email 875727617@qq.com- npm install hexo-cli -ginstall:- npm installscript:- hexo clean- hexo generate- hexo deploybranches: only: - indigo 下载ruby(如果你电脑有就不需要下载了) 注：不要使用Windows 系统机器否则构建的时候会报错下载地址，选择你需要的版本下载，我直接下载最新版64位了。 安装travis1gem install travis 安装完后登陆travis1travis login --auto 输入你github的登陆账号和密码。如下图就登陆成功了。 下一步开始用travis提供的工具加密刚才生成SSH公钥,并上传到travis供日常使用。把之前生成的id_rsa.pub文件放到项目根目录，然后执行。1travis encrypt-file id_rsa.pub --add -r github用户名/hexo仓库 // 不要使用Windows 系统机器否则构建的时候会报错 成功后会生成一个id_rsa.pub.enc 并且 .travis.yml 会自动添加一些内容，不要去改内容。 然后把id_rsa.pub 文件删除。 然后新建文件夹 .travis 然后把id_rsa.pub.enc 文件移到 .travis 文件夹里面， 在里面再新建 ssh_config 文件添加如下内容。12345Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes .travis.yml 文件最终版本，可以参考。12345678910111213141516171819202122232425language: node_jsnode_js:- 8.9.0cache: directories: - node_modulesbefore_install: - openssl aes-256-cbc -K $encrypted_43f1702cd897_key -iv $encrypted_43f1702cd897_iv -in .travis/id_rsa_github.enc -out ~/.ssh/id_rsa -d - chmod 600 ~/.ssh/id_rsa - eval $(ssh-agent) - ssh-add ~/.ssh/id_rsa - cp .travis/ssh_config ~/.ssh/config - git config --global user.name &quot;lanpangzhi&quot; - git config --global user.email 875727617@qq.com - npm install hexo-cli -ginstall: - npm installscript: - hexo clean - hexo generate - hexo deploybranches: only: - indigo 参考https://docs.travis-ci.com/user/for-beginnershttps://zh.wikipedia.org/wiki/Travis_CIhttps://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"},{"name":"travis-ci","slug":"travis-ci","permalink":"http://blog.langpz.com/tags/travis-ci/"},{"name":"自动构建","slug":"自动构建","permalink":"http://blog.langpz.com/tags/自动构建/"},{"name":"持续集成","slug":"持续集成","permalink":"http://blog.langpz.com/tags/持续集成/"}]},{"title":"使用express-generator快速生成express应用","slug":"使用express-generator快速生成express应用","date":"2018-05-14T16:08:03.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"使用express-generator快速生成express应用.html","link":"","permalink":"http://blog.langpz.com/使用express-generator快速生成express应用.html","excerpt":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。","text":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。 安装1npm install -g express-generator 需要全局安装。 使用在要创建应用的文件夹下面执。1express -e myapp -e： 使用ejs模板myapp： 应用名字 然后安装依赖项：12cd myappnpm install 执行应用1set DEBUG=myapp:* &amp; npm start 生成完应用的时候会有提示因为我是Windows系统所以提示set。MacOS 或 Linux 上不用使用set1DEBUG=myapp:* npm start 然后在浏览器中输入 http://localhost:3000/ 以访问此应用程序。可以根据自己的需要修改文件，来满足自己项目的需要。 更多参数12345678910 --version 输出版本号-e, --ejs 添加ejs引擎支持 --pug 添加pug引擎支持 --hbs 添加handlebars引擎支持-H, --hogan 添加hogan.js引擎支持-v, --view &lt;engine&gt; 添加以下模板引擎支持(dust|ejs|hbs|hjs|jade|pug|twig|vash) 默认jade --no-view 使用静态HTML代替视图模板引擎-c, --css &lt;engine&gt; 添加样式扩展语言 (less|stylus|compass|sass) 默认css --git 添加 .gitignore 忽略文件-h, --help 输出帮助信息 参考https://github.com/expressjs/generator","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"express-generator","slug":"express-generator","permalink":"http://blog.langpz.com/tags/express-generator/"}]},{"title":"node爬虫","slug":"node爬虫","date":"2018-05-12T15:37:42.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"node爬虫.html","link":"","permalink":"http://blog.langpz.com/node爬虫.html","excerpt":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。","text":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。 项目分析爬取http://top.zhaopin.com 智联网站上的全国的竞争最激烈三个月内前十的岗位。不需要定时爬取。使用request和cheerio模块。node版本7.6.0、npm版本4.1.2 安装1npm install request cheerio -S request 模块是一个简化的HTTP客户端。cheerio 模块专为服务器设计的核心jQuery的快速，灵活和精益的实现。可以把爬到的内容和jQuery一样使用。 核心代码1234567891011121314151617181920212223// app.jsconst request = require(&apos;request&apos;);const cheerio = require(&apos;cheerio&apos;);// 发起请求request(&apos;http://top.zhaopin.com&apos;, (error, response, body) =&gt; &#123; if(error)&#123; console.error(error); &#125; let json = &#123;&#125;; // 获取到的内容放到cheerio模块 const $ = cheerio.load(body); // jQuery 遍历 #hotJobTop .topList li 是通过http://top.zhaopin.com 分析页面结构得到的 $(&apos;#hotJobTop .topList li&apos;).each(function (index) &#123; let obj = json[index] = &#123;&#125;; obj.name = $(this).find(&apos;.title&apos;).text().trim(); obj.num = $(this).find(&apos;.paddingR10&apos;).text().trim(); &#125;); // 打印数据 console.log(json);&#125;); 执行 node app.js 就会得到如下结果。12345678910[ &#123; name: &apos;Java开发工程师&apos;, num: &apos;340538人/天&apos; &#125;, &#123; name: &apos;软件工程师&apos;, num: &apos;220873人/天&apos; &#125;, &#123; name: &apos;销售代表&apos;, num: &apos;175053人/天&apos; &#125;, &#123; name: &apos;会计/会计师&apos;, num: &apos;168225人/天&apos; &#125;, &#123; name: &apos;行政专员/助理&apos;, num: &apos;150913人/天&apos; &#125;, &#123; name: &apos;WEB前端开发&apos;, num: &apos;140979人/天&apos; &#125;, &#123; name: &apos;助理/秘书/文员&apos;, num: &apos;139098人/天&apos; &#125;, &#123; name: &apos;软件测试&apos;, num: &apos;136399人/天&apos; &#125;, &#123; name: &apos;人力资源专员/助理&apos;, num: &apos;123482人/天&apos; &#125;, &#123; name: &apos;用户界面（UI）设计&apos;, num: &apos;107505人/天&apos; &#125; ] 一个简单的爬虫就写好了，看看前十有没有你从事的岗位吧！ 参考https://github.com/request/requesthttps://github.com/cheeriojs/cheerio","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"爬虫","slug":"爬虫","permalink":"http://blog.langpz.com/tags/爬虫/"}]},{"title":"node连接MySQL","slug":"node连接MySQL","date":"2018-05-10T15:40:04.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"node连接MySQL.html","link":"","permalink":"http://blog.langpz.com/node连接MySQL.html","excerpt":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。","text":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。 安装1npm install mysql 连接1234567891011121314151617const mysql = require(&apos;mysql&apos;);let connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;password&apos;, database : &apos;test&apos;&#125;);connection.connect(function(err) &#123; if (err) &#123; console.error(&apos;连接出错: &apos; + err.stack); return; &#125; console.log(&apos;连接成功 id &apos; + connection.threadId);&#125;); host：连接的服务器user：用户名默认是rootpassword：之前设置的MySQL密码database： 要连接的库 常用的SQL语句SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。 增1INSERT INTO user (username, pass) VALUES (&apos;blog.langpz.com&apos;, &apos;123456&apos;); INSERT INTO 表名称 VALUES (值1, 值2,….)指定所要插入数据的列INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….) 删1DELETE FROM user WHERE id = 0 DELETE FROM 表名称 WHERE 列名称 = 值不加WHERE会删除所有行WHERE子句用于规定选择的标准。 改1UPDATE user SET pass = &apos;bbb&apos; WHERE username = &apos;张三&apos; UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 查1SELECT * FROM user SELECT 列名 FROM 表名 注： * 代表全部 node操作MySQL查询123456connection.query(&apos;SELECT * FROM user WHERE username = &quot;blog.langpz.com&quot;&apos;, (err, results, fields) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 删除123456connection.query(&apos;DELETE FROM user WHERE id = 1&apos;, (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 增加123456connection.query(&apos;INSERT INTO user(username, pass) VALUES(?, ?)&apos;,[&apos;lan&apos;, &apos;abc&apos;], (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 修改123456connection.query(&apos;UPDATE user SET pass = &quot;bbb&quot; WHERE username = &quot;lan&quot;&apos;, (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 终止连接1234connection.end(function(err) &#123; // The connection is terminated now&#125;);connection.destroy(); 调用这两个方法都可以。基本操作就是这个流程，可以通过路由封装接口，写一个CRUD应用，mysql模块更多参数可以去看github。 参考https://github.com/mysqljs/mysql","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Windows下安装MongoDB","slug":"Windows下安装MongoDB","date":"2018-05-08T15:30:32.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Windows下安装MongoDB.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MongoDB.html","excerpt":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。","text":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。 MongoDB特点和关系型数据库比较，面向文档的数据库不再有“行”（row）的概念，取而代之的是更为灵活的“文档”（document）模型。通过再文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系。另外，不再有预定义模式，文档的键（key）和值（value）不再是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易。可以进行快速迭代，所以开发进程得到加快。 MongoDB基本概念文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行。集合(collection)可以看作是一个拥有动态模式(dynamic schema)的表。MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合。每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。 下载和安装下载地址 点击下载，下载完安装，用默认设置。 运行MongoDB命令提示符（cmd）执行，具体路径需要看安装的版本，我的是3.6版本。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongod --dbpath d:\\db 控制台会输出一些东西，没有报错MongoDB就启动了。这样启动比较麻烦，每次都要启动，所以可以把它注册成windows 的服务123// 使用管理员权限运行mongod --install --dbpath d:\\data\\db --logpath d:\\data\\log\\log.txtnet start MongoDB // 启动服务 12services.msc // 查看服务net stop mongodb // 停止服务 删除服务1mongod --remove --serviceName MongoDB // MongoDB是服务名 MongoDB 还可以通过配置文件启动可以去官网查看https://docs.mongodb.com/manual/reference/configuration-options/ 连接MongoDB在打开一个命令提示符（cmd）之前运行的MongoDB那个不要关闭，因为没有注册成windows的服务，关闭就找不到数据库了。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongo 这样就链接上数据库了，当然还会输出一大堆东西。 操作MongoDB我们先创建一个数据库，再刚才连接MongoDB的cmd执行1use test02 创建一个test02的数据库并切换过去。db变量指向当前数据库。向集合里插入文档，之前也讲了MongoDB没有预定义模式，所以不用新建表和表结构了。insert方法 把一条文档保存到集合里。1db.user_table.insert(&#123;&quot;name&quot;, &quot;lanpangzhi&quot;, &quot;age&quot;: 18&#125;) 查看集合里面的文档。find和findOne方法可以用于查询集合里的文档。只想查看一个文件，可以用findOne12db.user_table.find()db.user_table.findOne() find和findOne还可以接受一个查询文档作为限定条件。1db.user_table.find(&#123;&quot;name&quot;: &quot;lanpangzhi&quot;&#125;) 更新集合里面的文档update方法接受（至少）两个参数：第一个是限定条件（用于匹配待更新的文档），第二个是新的文档。1db.user_table.update(&#123;name: lanpangzhi&#125;,&#123;&quot;name&quot;: &quot;lanpangzhi&quot;, &quot;age&quot;: 18, &quot;sex&quot;: 1&#125;); 删除集合里面的文档remove方法可将数据库的集合永久删除，如果不加参数默认把集合里面所有的文档删除。它可以接受一个限定条件的文档作为参数。1db.user_table.remove(&#123;&quot;name&quot;: &quot;aaa&quot;&#125;)","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.langpz.com/tags/MongoDB/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"}]},{"title":"Windows下安装MySQL","slug":"Windows下安装MySQL","date":"2018-05-08T11:02:20.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Windows下安装MySQL.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MySQL.html","excerpt":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。","text":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 下载下载地址 点击，进入页面。注：MySQL安装程序是32位的，但会安装32位和64位二进制文件。 点击download然后跳转到页面。可以不需要登陆和注册也可以下载。 再点击，安装程序就下载了。 安装打开安装程序，勾选同意协议，点击下一步(Next) 现在只安装MySQL的服务端，点击下一步然后安装。设置MySQL密码，继续下一步。然后完成，其余配置都是用默认配置。 使用Navicat for MySQL 管理MySQL下载地址可以用它去管理MySQL。新建库，新建表，修改数据删除数据。 MySQL基本概念库： 文件夹-用来管理，无法存放数据，一个库可以存放很多张表。表： 文件-存放数据用的。列: 一列(数据元素) 包含了相同的数据, 例如用户的数据。行：一行是一组相关的数据，例如一条用户名和密码的数据。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。 MySQL常用数据类型 数据类型 说明 INT 整数 FLOAT 浮点数 DATE 日期值 DATETIME 混合日期和时间值 TIME 时间值或持续时间 VARCHAR 变长字符串 CHAR 定长字符串 参考https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Express路由","slug":"Express路由","date":"2018-05-07T17:50:08.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Express路由.html","link":"","permalink":"http://blog.langpz.com/Express路由.html","excerpt":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。","text":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。 一个网站下面可能有很多地址例如:www.langpz.com/aaauser/www.langpz.com/user/aaawww.langpz.com/user/bbbwww.langpz.com/user/cccvip/www.langpz.com/vip/aaawww.langpz.com/vip/bbbwww.langpz.com/vip/ccc等等。。。咱们可以拆分成vip和user两个目录目录下再放子路由。先安装express 然后在项目根目录建一个app.js和routers文件夹，routers文件夹里面再建一个index.js文件和vip、user两个目录，两个目录下面分别建立index.js文件。1234567891011// app.jsconst express = require(&apos;express&apos;);const routers = require(&apos;./routers&apos;); //引入路由let app = express();app.use(&apos;/vip&apos;, routers.vip); // 设置/vip路由中间件app.use(&apos;/user&apos;, routers.user); // 设置/user路由中间件app.listen(8000); 12345678// routers/index.jslet vip = require(&apos;./vip&apos;); // 引入vip文件下面的路由let user = require(&apos;./user&apos;); // 引入user文件下面的路由// 导出路由module.exports = &#123; vip, user&#125;; 12345678910111213141516171819// routers/vip/index.jsconst express = require(&apos;express&apos;); // 必须要引入expresslet routerVip = express.Router(); // 创建router实例// 添加路由配置routerVip.get(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip根目录&apos;)&#125;);routerVip.get(&apos;/aaa&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip/aaa目录&apos;)&#125;);routerVip.get(&apos;/bbb&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip/bbb目录&apos;)&#125;);// 导出路由module.exports = routerVip; 1234567891011121314151617181920// routers/user/index.jsconst express = require(&apos;express&apos;); // 必须要引入expresslet routerUser = express.Router(); // 创建router实例// 添加路由配置routerUser.get(&apos;/&apos;, (req, res) =&gt;&#123; res.send(&apos;我是user根目录&apos;)&#125;);routerUser.get(&apos;/aaa&apos;, (req, res) =&gt; &#123; res.send(&apos;我是user/aaa目录&apos;)&#125;);routerUser.get(&apos;/bbb&apos;, (req, res) =&gt; &#123; res.send(&apos;我是user/bbb目录&apos;)&#125;);// 导出路由module.exports = routerUser; 然后执行 node app.js 再浏览器输入http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"路由","slug":"路由","permalink":"http://blog.langpz.com/tags/路由/"}]},{"title":"Express框架cookie和session","slug":"Express框架cookie和session","date":"2018-05-06T17:32:54.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Express框架cookie和session.html","link":"","permalink":"http://blog.langpz.com/Express框架cookie和session.html","excerpt":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。","text":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。 cookiecookie存在浏览器端，每次请求都会带上。 缺点：不安全(用户可以随便串改)，大小（4k）。 sessionsession只存在服务器端。 优点：容量不限，比较安全（用户接触不到）。 session实现是基于cookie的。风险：session_id 被泄露漏 session劫持。 提醒用户不在在控制台输入(console)输入代码。 session_id 足够复杂，定期更换。 Express操作cookie先安装cookie-parser。1npm install cookie-parser -S 123456789101112131415// app.jsconst express = require(&apos;express&apos;);const cookieParser = require(&apos;cookie-parser&apos;);let app = express();app.use(cookieParser()); // 设置cookieParser 中间件app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;); // 设置cookie res.send(&apos;OK&apos;);&#125;);app.listen(8000); 在cmd执行 node app.js 浏览器输入http://localhost:8000/ 第一次控制台输出{}，再刷新就输出{user: ‘lanpangzhi’ }。现在就能获取和设置cookie了，但是有个问题，浏览器执行document.cookie = “user=aaa”,浏览器再刷新控制台就会输出{user: ‘aaa’ }。这样使用cookie不安全，敏感信息容易被篡改，所以要使用带签名的cookie。 带签名的cookie123456789101112131415161718// app.jsconst express = require(&apos;express&apos;);const cookieParser = require(&apos;cookie-parser&apos;);let app = express();app.use(cookieParser(&apos;abc123456abc&apos;)); // 设置cookieParser 中间件 使用签名必须要设置字符串。app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie console.log(req.signedCookies); // 获取带签名的cookie res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;, &#123; signed: true // 设置带签名的cookie &#125;); res.send(&apos;OK&apos;);&#125;);app.listen(8000); 再执行，就会发现浏览器cookie的值变成了s%3Alanpangzhi.i6hEUuhD%2Fd0miBMsGyRdktiDFmi%2BYfiJhQTcqKpQqIc ，再修改cookie的值，控制台就会输出{ user: false }，这样cookie就不会被简单的篡改了。 req.cookies 获取cookie。res.cookie(name, value [, options]); name: cookie的名称(string)。 value: cookie的值，(string or object)。 options：options参数是一个可以具有以下属性的对象。 如下 值 类型 说明 domain String cookie的域名。 默认为网站的域名。 encode Function 用于cookie值编码的同步函数。 默认为encodeURIComponent。 expires Date cookie的有效期（如果未指定或设置为0），则创建会话cookie。 httpOnly Boolean 将cookie标记为仅可由Web服务器访问。默认false maxAge Number 设置cookie的到期时间、相对于当前时间的到期时间（以毫秒为单位）。 path String cookie的路径。 默认为“/” secure Boolean 将cookie标记为仅与HTTPS一起使用。默认false signed Boolean 对cookie进行签名。默认false Express操作session先安装cookie-session。1npm install cookie-session -S 1234567891011121314151617181920// app.jsconst express = require(&apos;express&apos;);const cookieSession = require(&apos;cookie-session&apos;);let app = express();app.use(cookieSession(&#123; secret: &apos;aaaa&apos;&#125;)); // 设置cookieSession中间件app.get(&apos;/&apos;, (req, res) =&gt; &#123; if (req.session[&apos;num&apos;]) &#123; req.session[&apos;num&apos;]++; &#125;else&#123; req.session[&apos;num&apos;] = 1; // 设置session &#125; res.send(`访问$&#123;req.session[&quot;num&quot;]&#125;次`);&#125;);app.listen(8000); 在cmd执行 node app.js 浏览器输入http://localhost:8000/ 刷新浏览器就可以看到访问几次，把所有浏览器都关闭session就失效了，再进入页面就从第一次开始了。更多方法还有详细参数可以去github自行参考。 参考http://expressjs.com/en/4x/api.htmlhttps://github.com/expressjs/cookie-parserhttps://github.com/expressjs/cookie-session","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"cookie","slug":"cookie","permalink":"http://blog.langpz.com/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://blog.langpz.com/tags/session/"}]},{"title":"javascript数据类型转换","slug":"javascript数据类型转换","date":"2018-05-05T17:14:25.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"javascript数据类型转换.html","link":"","permalink":"http://blog.langpz.com/javascript数据类型转换.html","excerpt":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。","text":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。 默认是false的五个值1null undefined NaN 0 &apos;&apos; 记住只有这五个值是假的剩下的全部是真的。 转换规则 如果是一个值判断是否是真假，除了默认是false的五个值剩下的全部是true。 如果是两个值比较是否相等，遵循如下规则。 val1 == val2 如果两个值可能不是同一数据类型，如果是==比较的话，会默认进行数据转换。 2.1 object == object，比较永远不相等。 2.2 object == string 先将对象转换成字符串（调用toString方法），然后再比较。[] 转换成字符串 &quot;&quot; {} 转换成字符串 &quot;[object Object]&quot; 2.3 object == boolean 先将对象转换成字符串（toString），再把字符串转换成数字（Number）、布尔值转换成数字（true 转换成 1 false 换成成 0）然后让两个数字进行比较。Number(&quot;&quot;) 会输出 0 2.4 object == number 先将对象转换成字符串（toString），再把字符串转换成数字（Number），再进行比较。 2.5 number == boolean 布尔值转换成数字，然后再比较。 2.6 number == string 字符串转换成数字，然后再比较。 2.7 string == boolean 都转换成数字，，然后再比较。 2.8 null == undefined 结果是true。 2.9 null 或者 undefined 比较另外的所有值，结果都是false，不相等。 例如： [] == false 返回 true 2.3规则。 [] == [] 返回 false 2.1规则。 2 == true 返回 false 2.5规则。=== 三个等号还会比较数据类型。这些规则背下来，就能完美的应该这样的面试题了，加油！","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"http://blog.langpz.com/tags/数据类型转换/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.langpz.com/tags/面试题/"}]},{"title":"Git生成SSH公钥","slug":"Git生成SSH公钥","date":"2018-05-05T16:40:31.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Git生成SSH公钥.html","link":"","permalink":"http://blog.langpz.com/Git生成SSH公钥.html","excerpt":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。","text":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。 查看公钥是否生成过12cd ~/.sshls # 在Git bash下执行 或者 C:\\Users\\Administrator.ssh 访问这个目录。看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。如果有公钥直接打开 id_rsa.pub 文件添加到GitHub和coding的SSH公钥里面，建议coding有效期选永久。 生成公钥执行下面的命令。1ssh-keygen 它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。直接回车就行。然后去C:\\Users\\Administrator.ssh目录 找到id_rsa.pub 文件就是生成好的公钥，添加到GitHub和coding。公钥的大概样子，全部复制。123456ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local 测试公钥是否添加成功测试GitHub。1ssh git@github.com 现在就添加成功了。 测试Coding1ssh -T git@git.coding.net 参考https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"},{"name":"SSH公钥","slug":"SSH公钥","permalink":"http://blog.langpz.com/tags/SSH公钥/"}]},{"title":"Express文件上传","slug":"Express文件上传","date":"2018-05-04T15:58:58.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Express文件上传.html","link":"","permalink":"http://blog.langpz.com/Express文件上传.html","excerpt":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。","text":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。 安装Multer第一步先安装Multer到你的项目里。1npm install --save multer 创建一个form表单这里就不用ajax去上传了。12345678910111213141516// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; form表单enctype属性 值 说明 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 引用配置multer123456789101112131415161718192021222324252627282930// app.jsconst express = require(&apos;express&apos;);const multer = require(&apos;multer&apos;);const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const uploda = multer(&#123; dest: &apos;./uploads/&apos; // 服务接收文件的路径&#125;);let app = express();app.use(uploda.any()); // multer放到express中间件里app.post(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.files); // req.files接收到的文件信息一个数组 // 添加后缀名，只支持一个文件上加后缀名，多文件改成递归 let newName = req.files[0].path + path.extname(req.files[0].originalname); console.log(newName, req.files[0].path); fs.rename(req.files[0].path, newName, (err) =&gt; &#123; if(err)&#123; console.log(err); res.sendStatus(500).send(&apos;error&apos;); &#125;else&#123; res.send(&apos;OK，上传成功。&apos;); &#125; &#125;);&#125;);app.listen(8000); 在cmd执行 node app.js 打开index.html 选择文件上传，服务端就可以成功接收文件了。multer 还有一些别的方法和参数，可自行去github查看。 参考https://github.com/expressjs/multer","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"文件上传","slug":"文件上传","permalink":"http://blog.langpz.com/tags/文件上传/"}]},{"title":"javascript数组去重(ES6版)","slug":"javascript数组去重-ES6版","date":"2018-05-02T16:49:44.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"javascript数组去重-ES6版.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重-ES6版.html","excerpt":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。","text":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。 123var arr = [1,2,3,4,5,&apos;1&apos;,&apos;2&apos;,3,3,&apos;1&apos;];arr = Array.from(new Set(arr));console.log(arr); Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。 jsBin 地址","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"},{"name":"ES6","slug":"ES6","permalink":"http://blog.langpz.com/tags/ES6/"}]},{"title":"css实现元素垂直水平居中-包括未知宽高的元素","slug":"css实现元素垂直居中-包括未知宽高的元素","date":"2018-04-28T13:14:04.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"css实现元素垂直居中-包括未知宽高的元素.html","link":"","permalink":"http://blog.langpz.com/css实现元素垂直居中-包括未知宽高的元素.html","excerpt":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。","text":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。 第一种已知宽高（定位加负边距解决）兼容到IE6123456789position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;margin-left: -100px;margin-top: -100px;background: red; demo地址 JSBin 第二种未知宽高 (定位加margin解决) 兼容到IE8 移动端推荐使用12345678910position: absolute;z-index: 8;left: 0;top: 0;bottom: 0;right: 0;width: 200px;height: 200px;margin: auto;background: red; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第三种未知宽高 (定位加transform解决) 兼容到IE9 移动端推荐使用12345678position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;transform: translate(-50%, -50%);background: red; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第四种未知宽高 (弹性盒子模型解决) 兼容到IE101234display: flex;display: -webkit-flex;align-items:center;justify-content: center; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第五种未知宽高 (table特性解决的) 兼容到IE6 PC端推荐使用12345678910111213141516171819202122232425#box&#123; width: 100px; height:100px; text-align:center; font-size:0; background: red&#125;#box:after,#box span&#123; display:inline-block; *display:inline; *zoom:1; width:0; height:100%; vertical-align:middle;&#125;#box:after&#123; content:&apos;&apos;;&#125;#box p&#123; display:inline-block; *display:inline; *zoom:1; vertical-align:middle; font-size:16px;&#125; demo地址 JSBin 参考http://demo.doyoe.com/css/alignment/","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"EJS模板引擎","slug":"ejs模板引擎","date":"2018-04-27T13:36:44.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"ejs模板引擎.html","link":"","permalink":"http://blog.langpz.com/ejs模板引擎.html","excerpt":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。","text":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。 安装EJS1npm install ejs Express设置EJS模板12app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎app.set(&apos;views&apos;, &apos;./views&apos;); # views, 放模板文件的目录 将值输出到模板（HTML转义）12345// index.ejs&lt;%= arr %&gt;// Noderes.render(&apos;index&apos;, &#123;arr: [1,2,3,4]&#125;); 判断123&lt;% if (user) &#123; %&gt; &lt;p&gt; &lt;%= user %&gt; &lt;/p&gt;&lt;% &#125; %&gt; 循环123&lt;% for (var i = 0; i &lt; arr.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= arr[i] %&gt;&lt;/li&gt;&lt;% &#125; %&gt; include（不转义）1&lt;%- include(&apos;./common/header.ejs&apos;) %&gt; EJS标签 &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除","categories":[],"tags":[{"name":"EJS","slug":"EJS","permalink":"http://blog.langpz.com/tags/EJS/"}]},{"title":"Express中间件body-parser简单实现","slug":"Express中间件body-parser简单实现","date":"2018-04-18T11:49:16.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Express中间件body-parser简单实现.html","link":"","permalink":"http://blog.langpz.com/Express中间件body-parser简单实现.html","excerpt":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。","text":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。首先通过命令提示输入 mkdir lib &amp;&amp; cd lib。再输入touch body-parser.js。把下面的代码在body-parser.js 敲一遍。1234567891011121314151617// lib/body-parser.jsconst querystring = require(&apos;querystring&apos;);module.exports.urlencoded = function (req, res, next) &#123; let chunks = []; req.on(&apos;data&apos;, data =&gt; &#123; chunks.push(data); &#125;); req.on(&apos;end&apos;, () =&gt; &#123; // 合并Buffer。 let buf = Buffer.concat(chunks).toString(); // 把querystring解析过的json 放到 req.body上。 req.body = querystring.parse(buf); next(); &#125;);&#125; 下面是主程序代码。1234567891011121314// app.jsconst express = require(&apos;express&apos;);const bodyParser = require(&apos;./lib/body-parser&apos;);let app = express();app.use(bodyParser.urlencoded);app.post(&apos;/&apos;, (req, res) =&gt; &#123; res.send(req.body);&#125;);app.listen(8000); 现在就完成和body-parser中间件类似的功能了，req.body上面有请求过来的post数据。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"Express处理数据请求","slug":"Express处理数据请求","date":"2018-04-02T17:28:39.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Express处理数据请求.html","link":"","permalink":"http://blog.langpz.com/Express处理数据请求.html","excerpt":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。","text":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。 处理get请求这个比较简单(不需要使用中间件)直接req.query就能获取到。1234567891011// 服务端代码const express = require(&apos;express&apos;);let app = express();app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.query);&#125;);app.listen(8000); 1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘123’, pass: ‘abc’ } 方便操作。 处理post请求处理post请求需要用到body-parser这个中间件。这个中间件可以解析JSON、Raw、文本、URL-encoded格式的请求体。先安装中间件1npm install body-parser 在项目中引用body-parser中间件。123456789101112131415// 服务端代码const express = require(&apos;express&apos;);const bodyParser = require(&apos;body-parser&apos;);let app = express();// 引用body-parser中间件app.use(bodyParser.urlencoded());app.post(&apos;/&apos;, (req, res) =&gt; &#123; // req.body post 提交过来的数据 console.log(req.body);&#125;);app.listen(8000); 1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘lanpangzhi’, pass: ‘123456’ } 方便操作。这样我们就通过Express获取到get和post提交过来的数据了。 urlencoded() 方法配置参数 (options) extended 设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true。但使用默认已被弃用。 请研究qs和querystring之间的差异并选择适当的设置。 inflate 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit 设置最大请求头大小， 如果这是一个数字，那么该值指定字节数; 如果它是一个字符串，则将该值传递给字节库解析。默认为100kb。 parameterLimit 用于设置URL编码值的最大参数数量， 如果请求包含的参数多于此值，那么413将返回给客户端。默认为1000。 type 用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify 这个选项仅在verify(req, res, buf, encoding)时受支持。 body-parser里面还有另外几个方法，可以自行去github看下。 参考[https://github.com/expressjs/body-parser]","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"express简单入坑","slug":"express简单入坑","date":"2018-03-19T13:38:00.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"express简单入坑.html","link":"","permalink":"http://blog.langpz.com/express简单入坑.html","excerpt":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。","text":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 安装12npm init npm install express --save 创建第一个应用12345678910// app.jsconst express = require(&apos;express&apos;);let app = express();app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;express&apos;);&#125;);app.listen(8000); 在命令行执行 node app.js 浏览器输入 http://localhost:8000/就可以访问了。 路由控制app.get(path, (request, response) =&gt; {})根据path处理客户端发过来的GET请求。第一个参数：path请求的路径。第二个参数：回调函数，request(请求),response(响应)123456app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;home&apos;);&#125;);app.get(&apos;/hello&apos;,(req,res) =&gt; &#123; res.send(&apos;hello&apos;);&#125;); app.post(path, (request, response) =&gt; {})根据path处理客户端发过来的POST请求。参数和app.get()方法一样。123456app.post(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;home&apos;);&#125;);app.post(&apos;/hello&apos;, (req, res) =&gt; &#123; res.send(&apos;hello&apos;);&#125;); app.all(path, (request, response) =&gt; {})根据path处理客户端发过来的所有http(GET,POST,PUT,DELETE,HEAD)请求。参数和app.get()方法一样。 res.send() 发送各种类型的响应。res.download() 提示下载文件。res.redirect() 重定向请求。res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 静态文件Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。只需要把文件目录作为参数传给express.static，之后就可以访问到静态文件。1app.use(express.static(&apos;./public&apos;)) 注： 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。 中间件Express应用就是在调用各种中间件完成功能的，如cookie解析、文件上传、静态文件等。中间件（Middleware） 是一个函数。它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。12345678910111213app.use((req, res, next) =&gt; &#123; console.log(&apos;aaa&apos;); next();&#125;)app.use((req, res, next) =&gt; &#123; console.log(&apos;bbb&apos;); next()&#125;)app.use((req, res, next) =&gt; &#123; console.log(&apos;ccc&apos;);&#125;) 可以看到next 的作用，把控制器交给下一个中间件。可以利用中间件特性来处理登陆用户。 检查数据是否合法。 检查数据是否存在。 检查数据密码是否正确。1234567891011121314151617181920212223app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(合法)&#123; next() &#125;else&#123; res.send(&apos;用户名不合法&apos;) &#125;&#125;)app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(存在)&#123; next() &#125;else&#123; res.send(&apos;用户名不存在&apos;) &#125;&#125;)app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(密码正确)&#123; res.send(&apos;登陆成功&apos;) &#125;else&#123; res.send(&apos;密码不正确&apos;) &#125;&#125;) 中间件的大概用法就是这样。 模板引擎先安装ejs模板npm install ejs -S12app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎app.set(&apos;views&apos;, &apos;./views&apos;); # views, 放模板文件的目录 1234567891011121314// index.jsconst express = require(&apos;express&apos;);const ejs = require(&apos;ejs&apos;);let app = express();app.set(&apos;view engine&apos;, &apos;ejs&apos;);app.set(&apos;views&apos;, &apos;./views&apos;);app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.render(&apos;index&apos;,&#123;title: &apos;hello&apos;&#125;);&#125;);app.listen(8000); 12345678910111213// index.ejs&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= title %&gt;&lt;/body&gt;&lt;/html&gt; 在命令行里执行node index.js，就可以看到模板了。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"node处理前台get请求","slug":"node处理前台get请求","date":"2018-03-02T10:07:32.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"node处理前台get请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台get请求.html","excerpt":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。","text":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。 服务端代码123456789101112const http = require(&apos;http&apos;);const url = require(&apos;url&apos;);let app = http.createServer((req, res) =&gt; &#123; let getUrl = url.parse(req.url, true); if (getUrl.pathname === &apos;/getUser&apos;)&#123; console.log(url.parse(req.url, true).query); res.end(url.parse(req.url, true).query.user); &#125;&#125;);app.listen(8000); 先搭一个服务器监听8000端口，再把请求的链接用URL模块解析成对象，判断请求路径，返回user。 客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000/getUser&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。前台页面会显示你输入的user。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"url模块","slug":"url模块","date":"2018-03-01T16:03:22.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"url模块.html","link":"","permalink":"http://blog.langpz.com/url模块.html","excerpt":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。","text":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。 url结构说明网址：http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash 从node.js 中文网拿的图。 url.parse(urlString[, parseQueryString[, slashesDenoteHost]])123let url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;)) 把url字符串解析成url对象。输出:12345678910111213&#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;langpz.com:80&apos;, port: &apos;80&apos;, hostname: &apos;langpz.com&apos;, hash: &apos;#top&apos;, search: &apos;?callback=fn&apos;, query: &apos;callback=fn&apos;, pathname: &apos;/aaa/ccc/ddd&apos;, path: &apos;/aaa/ccc/ddd?callback=fn&apos;, href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos; &#125; protocol: 请求协议。 slashes: slashes 属性是一个 boolean，如果 协议 中的冒号后面跟着两个 ASCII 斜杠字符（/），则值为 true。 auth： URL的用户名与密码部分。 host: URL的主机部分包括端口号。 port：主机的端口号。 hostname：主机名部分。 hash： 锚点部分。 search： 整个查询字符串部分，包括前面的?号 query: 查询字符串部分，不包括前面的?号 pathname：URL 的整个路径部分。 path： pathname 与 search 组成部分的串接。 href： 解析后的完整的 URL 字符串，protocol 和 host 都会被转换为小写的。 第二个参数是布尔值，如果是 true，query值是一个对象。 默认为 false。第三个参数是布尔值，如果是 true，则 // 之后至下一个 / 之前的字符串会被解析作为 host。 例如，//foo/bar 会被解析为 {host: ‘foo’, pathname: ‘/bar’} 而不是 {pathname: ‘//foo/bar’}。 默认为 false。 url.format(urlObject)12345678910111213141516let url = require(&apos;url&apos;);console.log(url.format(&#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;langpz.com:80&apos;, port: &apos;80&apos;, hostname: &apos;langpz.com&apos;, hash: &apos;#top&apos;, search: &apos;?callback=fn&apos;, query: &apos;callback=fn&apos;, pathname: &apos;/aaa/ccc/ddd&apos;, path: &apos;/aaa/ccc/ddd?callback=fn&apos;, href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;&#125;)); url.parse()的反向操作，把url对象解析成url字符串 url.resolve(from, to)12345let url = require(&apos;url&apos;);console.log(url.resolve(&apos;/one/two/three&apos;,&apos;four&apos;)) # 输出 /one/two/fourconsole.log(url.resolve(&apos;http://blog.langpz.com/&apos;, &apos;aaa&apos;)) # 输出 http://blog.langpz.com/aaaconsole.log(url.resolve(&apos;http://blog.langpz.com/aaa&apos;, &apos;bbb&apos;)) # 输出 http://blog.langpz.com/bbb 把最后一个/没有内容后面追加to参数，有内容则替换。 参考http://nodejs.cn/api/url.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"node处理前台post请求","slug":"node处理前台post请求","date":"2018-03-01T10:29:37.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"node处理前台post请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台post请求.html","excerpt":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。","text":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。 服务端代码123456789101112131415161718// http.jslet http = require(&apos;http&apos;);let querystring = require(&apos;querystring&apos;);let app = http.createServer((req, res) =&gt; &#123; let str = &apos;&apos;; if (req.url === &apos;/post&apos;)&#123; req.on(&apos;data&apos;, (data) =&gt; &#123; str += data; &#125;); req.on(&apos;end&apos;, () =&gt; &#123; console.log(querystring.parse(str)); &#125;); &#125;&#125;);app.listen(8000) 先搭一个服务器监听8000端口，判断请求路径，再绑定data事件接收客户端发过来的post请求，接受用querystring模块处理接收的数据。 客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000/post&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"stream模块","slug":"stream模块","date":"2018-02-27T13:27:30.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"stream模块.html","link":"","permalink":"http://blog.langpz.com/stream模块.html","excerpt":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。","text":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。 为什么使用stream我们之前读文件用的是readFile()把整个文件读入到内存，如果文件小还可以，假如你读取的文件有几个G就会把内存撑爆，这个时候就需要stream(流)了，收到一块数据，就读取一块。这样占用内存就会小很多。 流的类型Node.js 中有四种基本的流类型：Readable - 可读的流Writable - 可写的流Duplex - 可读写的流Transform - 在读写过程中可以修改和变换数据的 Duplex 流 可读流的常用事件data 当有数据可读时触发end 没有更多的数据可读时触发。error 在接收和写入过程中发生错误时触发。 可读流12345678910111213let fs = require(&apos;fs&apos;);let rs = fs.createReadStream(&apos;./hello.txt&apos;,&#123; encoding: &apos;utf8&apos;&#125;);rs.on(&apos;data&apos;, data =&gt; &#123; console.log(&apos;读取中--------&apos; + data +&apos;--------&apos;) # 如果文件过大会分几次输出数据。&#125;);rs.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;读取完毕&apos;); # data读取完触发 end 事件。&#125;) 第一个参数是路径。第二个参数是可配置对象。 flags: 读取模式默认为r（只读） encoding: 设置编码默认null mode: 设置文件模式默认0o666 start: 用整数表示文件开始读取字节数的索引位置 end: 用整数表示文件结束读取字节数的索引位置 highWaterMark: 最高水位线，停止从底层资源读取前，内部缓存区最多存放的字节数。默认64kb 暂停流对象触发 ‘data’ 事件1rs.pause() 重新流对象触发 ‘data’ 事件1rs.resume() 可写流12345678910let fs = require(&apos;fs&apos;);let stream = fs.createWriteStream(&apos;./1.txt&apos;)stream.write(&apos;lan&apos;) # 写入数据stream.write(&apos;pang&apos;) # 写入数据stream.end(&apos;zi&apos;) # 写入数据stream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;); 第一个参数是路径。第二个参数是可配置对象。 flags: 读取模式默认为w encoding: 设置编码默认utf8 mode: 设置文件模式默认0o666 start: 用整数表示文件开始写入字节数的索引位置 highWaterMark: 最高水位线，内部缓存区最多存放的字节数。默认16kb stream.write(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。返回一个boolean值。写入数据的时候内部缓冲区的大小小于创建流时设定的 highWaterMark 阈值，函数将返回 true 。如果返回值为 false ，应该停止向流中写入数据，直到 ‘drain’ 事件被触发。 123456789101112131415161718192021let fs = require(&apos;fs&apos;);let stream = fs.createWriteStream(&apos;./1.txt&apos;,&#123; highWaterMark: 10&#125;);let i = 0;let max = 100;let write = () =&gt; &#123; let flag = true; while (i &lt; max &amp;&amp; flag)&#123; console.log(&apos;写入&apos; + i); i++; flag = stream.write(String(i)); &#125;&#125;write();stream.on(&apos;drain&apos;,() =&gt; &#123; console.log(&apos;继续写入&apos;+ i); write();&#125;); drain事件如果调用 stream.write(chunk) 方法返回 false，’drain’ 事件会在适合恢复写入数据到流的时候触发。 stream.end(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。调用 writable.end() 方法表明接下来没有数据要被写入 Writable。通过传入可选的 chunk 和 encoding 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 callback 函数，它将作为 ‘finish’ 事件的回调函数。在调用了 stream.end() 方法之后，再调用 stream.write() 方法将会导致错误。 pipe()12345let fs = require(&apos;fs&apos;);let rs = fs.createReadStream(&apos;./1.txt&apos;);let ws = fs.createWriteStream(&apos;./2.txt&apos;);rs.pipe(ws) readable.pipe(destination[, options])readable 可读流对象destination 可写流对象readable.pipe() 绑定一个 Writable 到 readable 上， 将可写流自动切换到 flowing 模式并将所有数据传给绑定的 Writable。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。pipe 方法是使用流最简单的方式。通常的建议是要么使用 pipe 方法、要么使用事件来读取流，要避免混合使用两者。一般情况下使用 pipe 方法时你就不必再使用事件了。但如果你想以一种更加自定义的方式读取流，就要用到事件了。 参考http://nodejs.cn/api/stream.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"path模块","slug":"path模块","date":"2018-02-26T11:17:42.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"path模块.html","link":"","permalink":"http://blog.langpz.com/path模块.html","excerpt":"path模块path模块是Node.js提供用于处理文件与目录的路径。","text":"path模块path模块是Node.js提供用于处理文件与目录的路径。 连接路径123let path = require(&apos;path&apos;);console.log(path.join(__dirname,&apos;lan&apos;,&apos;pang&apos;,&apos;zi&apos;)) # 输出c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi 为什么要使用这个方法，因为Windows和liunx系统路径分隔符不一样，liunx系统是”/“，Windows系统是”\\”，path.join()会正确使用当前系统的路径分隔符。 获取路径扩展名123let path = require(&apos;path&apos;);console.log(path.extname(__filename)) # 输出 .js 从 path 的最后一部分中的最后一个 . 字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名的第一个字符是 .，则返回一个空字符串。1234console.log(path.extname(&apos;.lanpangzhi&apos;)) # 输出空字符串console.log(path.extname(&apos;lanpangzhi.github.exe&apos;)) # 输出 .execonsole.log(path.extname(&apos;lanpangzhi.&apos;)) # 输出 .console.log(path.extname(&apos;lanpangzhi&apos;)) # 输出空字符串 获取绝对路径123let path = require(&apos;path&apos;);console.log(path.resolve(&apos;lan/pang&apos;,&apos;zi&apos;)) # 输出 c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi 路径的序列是从右往左被处理的。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。如果不传参数会得到当前所在的目录 判断是否是绝对路径1234let path = require(&apos;path&apos;);console.log(path.isAbsolute(&apos;/lanpangzhi&apos;)) # 输出 trueconsole.log(path.isAbsolute(&apos;lanpangzhi/&apos;)) # 输出 false 如果 path 不是一个字符串，则抛出 TypeError。 获取路径中的文件名1234let path = require(&apos;path&apos;);console.log(path.basename(__filename)) # 输出 http.jsconsole.log(path.basename(__filename,&apos;.js&apos;)) # 输出 http 第一个参数是路径。第二个参数是文件扩展名，如果加上只返回文件名。 path.sep 文件路径分隔符path.delimiter 环境变量路径分隔符参考http://nodejs.cn/api/path.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"fs模块","slug":"fs模块","date":"2018-02-22T14:32:19.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"fs模块.html","link":"","permalink":"http://blog.langpz.com/fs模块.html","excerpt":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。","text":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。 读取文件同步方法 readFileSync()12345678let fs = require(&apos;fs&apos;);try&#123; let buf = fs.readFileSync(&apos;./hello.txt&apos;, &#123; encoding: &apos;utf-8&apos; &#125;); console.log(buf); # 输出: 入坑了..&#125;catch(err)&#123; console.log(&apos;读取失败了: &apos; + err.message)&#125; readFileSync方法的第一个参数是文件路径可以是（string|Buffer|URL|integer）类型，第二个参数可以是一个表示配置的对象。默认的配置对象是{ encoding: null, flag: ‘r’ }，encoding：文件编码默认为null，flag：读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回原始的 buffer。 异步方法 readFile()1234567let fs = require(&apos;fs&apos;);fs.readFile(&apos;./hello.txt&apos;, &#123; encoding: &apos;utf-8&apos; &#125;, (err,data) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(data); # 输出: 入坑了..&#125;); 和readFileSync方法参数一样，只多了一个回调函数。回调有两个参数 (err, data)，其中 data 是文件的内容。 写入文件同步方法 writeFileSync()123let fs = require(&apos;fs&apos;);fs.writeFileSync(&apos;./1.txt&apos;,&apos;node入坑指南...&apos;,&#123;encoding: &apos;utf8&apos;&#125;) 第一个参数是路径第二的参数是写入的数据第三个参数是一个可配置的对象{encoding：utf8, mode: 0o666, flag: ‘w’} encoding: 文件编码默认为utf8 mode： 设置文件模式(权限)，文件创建默认权限为 0o666(可读，可写)。 flag： 文件打开模式默认为w(写入) 如果 options 是一个字符串，则它指定了字符编码。例如：1fs.writeFileSync(&apos;./1.txt&apos;, &apos;111...&apos;, &apos;utf8&apos;) 异步方法 writeFile()12345678let fs = require(&apos;fs&apos;);fs.writeFile(&apos;./2.txt&apos;,&apos;蓝胖纸&apos;,(err) =&gt; &#123; if(err)&#123; throw err; &#125; console.log(&apos;写入成功&apos;);&#125;) 异步地写入数据到文件，如果文件已经存在，则替代文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。和writeFileSync方法参数一样，只多了一个回调函数。 创建目录同步方法 mkdirSync()1fs.mkdirSync(&apos;./hello&apos;,0o777); 在当前目录下面创建一个hello的文件夹。第一个参数是路径。第二个参数是设置文件模式(权限)，默认为0o777。 异步方法 mkdir()123fs.mkdir(&apos;./lanpangzhi&apos;, 0o777, function (err) &#123; if (err) throw err;&#125;); 和mkdirSync方法参数一样，只多了一个回调函数。注： 所有的异步方法最后一个参数都是回调函数，回调函数的第一个参数都是异常。 读取目录同步方法 readdirSync()12let a = fs.readdirSync(process.cwd())console.log(a) 输出当前工作目录下的文件数组列表。第一个参数是路径。第二个参数是设置编码。 异步方法 readdir()123456fs.readdir(process.cwd(),(err, files) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(files)&#125;) 和readdirSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是文件数组列表。 查看文件信息同步方法 statSync()12let stats = fs.statSync(&apos;./a.js&apos;);console.log(stats) 接受一个路径参数，返回一个 fs.Stats 实例。 fs.Stats 实例的方法 方法 描述 stats.isFile() 如果是文件返回 true，否则返回 false。 stats.isDirectory() 如果是目录返回 true，否则返回 false。 stats.isBlockDevice() 如果是块设备返回 true，否则返回 false。 stats.isCharacterDevice() 如果是字符设备返回 true，否则返回 false。 stats.isSymbolicLink() 如果是软链接返回 true，否则返回 false。 stats.isFIFO() 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 stats.isSocket() 如果是 Socket 返回 true，否则返回 false。 Stat 时间值 属性 描述 atime “访问时间” - 文件数据最近被访问的时间。 mtime “修改时间” - 文件数据最近被修改的时间。 ctime “变化时间” - 文件状态最近更改的时间。 birthtime “创建时间” - 文件创建的时间。 异步方法 stat()12345678let fs = require(&apos;fs&apos;);fs.stat(&apos;./hello&apos;, (err, stats)=&gt;&#123; if(err)&#123; throw err; &#125; console.log(stats);&#125;); 和statSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是fs.Stats实例。 删除文件同步方法 unlinkSync()123let fs = require(&apos;fs&apos;);fs.unlinkSync(&apos;./1.txt&apos;); 删除当前目录下的1.txt文件，返回undefined。第一个参数是路径。 异步方法 unlink()1234567let fs = require(&apos;fs&apos;);fs.unlink(&apos;./2.txt&apos;, (err) =&gt; &#123; if(err)&#123; console.log(err) &#125;&#125;) 和unlinkSync方法参数一样。 参考http://nodejs.cn/api/fs.htmlhttp://www.runoob.com/nodejs/nodejs-fs.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"querystring模块","slug":"querystring模块","date":"2018-02-09T13:10:53.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"querystring模块.html","link":"","permalink":"http://blog.langpz.com/querystring模块.html","excerpt":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。","text":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。 把字符串转换成对象 querystring.parse(str[, sep[, eq[, options]]])12345678910111213141516171819202122232425262728let querystring = require(&apos;querystring&apos;);let query = querystring.parse(&apos;name=lanpangzhi&amp;age=18&apos;);console.log(query); # 输出&#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;// 添加第二个参数 seplet query2 = querystring.parse(&apos;name=lanpangzhi@age=18&apos;,&apos;@&apos;);console.log(query2); # 输出&#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 &apos;&amp;&apos;。// 添加第三个参数 eqlet query3 = querystring.parse(&apos;name|lanpangzhi@age|18&apos;,&apos;@&apos;,&apos;|&apos;);console.log(query3); // eq: 用于界定查询字符串中的键与值的子字符串。默认为 &apos;=&apos;。// sep eq 可以替换割分字符串的关键字，在某些特定的场景会用的。// 第四个参数用得比较少let query = querystring.parse(&apos;name|lanpangzhi@age|18@age2|20@age3|21@age4|555&apos;,&apos;@&apos;,&apos;|&apos;,&#123; decodeURIComponent: function test(str) &#123; return str+= &apos;1&apos; &#125;, maxKeys: 4&#125;);console.log(query); # 输出 &#123; name1: &apos;lanpangzhi1&apos;, age1: &apos;181&apos;, age21: &apos;201&apos;, age31: &apos;211&apos; &#125;// 第四个参数是一个对象， 里面有 decodeURIComponent 和 maxKeys 两个参数。// decodeURIComponent: 解码查询字符串的字符时使用的函数。默认为 querystring.unescape()。// maxKeys: 指定要解析的键的最大数量。默认为 1000。指定为 0 则不限制。// 我刚才指定是4 所以 age4 这个参数没输出。 把对象转换成字符串 querystring.stringify(obj[, sep[, eq[, options]]])1234567891011121314151617181920let querystring = require(&apos;querystring&apos;);let obj = &#123; name: &apos;lanpangzhi&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], age: &apos;18&apos; &#125;;let str = querystring.stringify(obj);console.log(str); # 输出 name=lanpangzhi&amp;baz=qux&amp;baz=quux&amp;age=18// 添加第二个参数 seplet obj = &#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;;let str = querystring.stringify(obj,&apos;@&apos;);console.log(str); # 输出 name=lanpangzhi@age=18// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 &apos;&amp;&apos;。// 添加第三个参数 eqlet obj = &#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;;let str = querystring.stringify(obj,&apos;@&apos;,&apos;|&apos;);console.log(str);// eq: 用于界定查询字符串中的键与值的子字符串。默认为 &apos;=&apos;。// 第四个参数 options 基本上用不到// encodeURIComponent &lt;Function&gt; : 把对象中的字符转换成查询字符串时使用的函数。默认为 querystring.escape()。 querystring.stringify 和 querystring.parse 功能正好是对应的， 基本上第四个参数用不到，第二和第三个参数只有在某些特定的场景才会使用，指定切割默写字符，或者输出某些字符。querystring 这个模块还有两个方法，但是基本上不会用到，更多可以去node中文网或者官网查看。新年快乐2018 参考http://nodejs.cn/api/querystring.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Buffer对象","slug":"Buffer对象","date":"2018-02-06T13:43:40.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Buffer对象.html","link":"","permalink":"http://blog.langpz.com/Buffer对象.html","excerpt":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。","text":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。 创建一个Buffer对象Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。 Buffer.from(array) 返回一个新建的包含所提供的字节数组的副本的 Buffer。 Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer) 返回一个新建的包含所提供的 Buffer 的内容的副本的 Buffer。 Buffer.from(string[, encoding]) 返回一个新建的包含所提供的字符串的副本的 Buffer。 Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的被填满的 Buffer 实例。这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝不会包含旧的和潜在的敏感数据。 Buffer.allocUnsafe(size)与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。123456789101112131415161718192021// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);buf3.fill(0)// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。数组里一定是0-255的数，否则会不识别，返回00const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from(&apos;tést&apos;);// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;); 在 Node.js v6 之前的版本中Buffer 实例是通过 new Buffer 构造函数创建的，因为 new Buffer() 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 new Buffer() 的参数、或未能正确地初始化新分配的 Buffer 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。为了使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被 废弃，并由 Buffer.from()、Buffer.alloc()、和 Buffer.allocUnsafe() 方法替代。 Node.js 建议开发者们应当把所有正在使用的 new Buffer() 构造函数迁移到这些新的 API 上。 Buffer 的转换Buffer对象与普通的 JavaScript 字符串的互相转换，需要指定编码格式。目前Node.js 目前支持以下的字符编码。 ‘ascii’ - 仅支持 7 位 ASCII 数据。 ‘utf8’ ‘utf16le’ ‘ucs2’ ‘base64’ ‘latin1’ ‘binary’ ‘hex’ 12345678// 字符串转Bufferconst buf = Buffer.from(&apos;node&apos;, &apos;ascii&apos;); // Buffer转hex编码字符串 - 输出 6e6f6465console.log(buf.toString(&apos;hex&apos;));// Buffer转base64编码字符串 - 输出 bm9kZQ==console.log(buf.toString(&apos;base64&apos;)); 字符串转BufferBuffer.from(string[, encoding])encoding 不传参数会默认utf8编码进行转码和存储。 字符串转Buffer实例方法buf.toString([encoding[, start[, end]]])encoding 解码使用的字符编码。默认: ‘utf8’。start 开始解码的字节偏移量。默认: 0。end 结束解码的字节偏移量（不包含）。 默认: buf.length。注：如果Buffer对象由多种编码写入，就需要在局部指定定不同的编码，才能转换回正常的编码。 判断一个对象是否是Buffer对象Buffer.isBuffer(obj)如果 obj 是一个 Buffer 则返回 true ，否则返回 false 。12const buf1 = Buffer.alloc(10);console.log(Buffer.isBuffer(buf1)) # 返回true 合并BufferBuffer.concat(list[, totalLength])list &lt;Array&gt; 要合并的 Buffer 或 Uint8Array 实例的数组totalLength &lt;integer&gt; 合并时 list 中 Buffer 实例的总长度返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。12345678const buf1 = Buffer.from(&apos;蓝&apos;);const buf2 = Buffer.from(&apos;胖&apos;);const buf3 = Buffer.from(&apos;纸&apos;);const len = buf1.length + buf2.length + buf3.length;console.log(len) # 输出9 一个汉字三个字节console.log(Buffer.concat([buf1, buf2, buf3], len).toString()) 获取字符长度Buffer.byteLength(string[, encoding])encoding 不传参数会默认utf8编码1console.log(Buffer.byteLength(&apos;蓝胖&apos;)) # 输出6 一个汉字三个字节 参考http://nodejs.cn/api/buffer.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"global对象","slug":"global对象","date":"2018-02-02T14:33:27.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"global对象.html","link":"","permalink":"http://blog.langpz.com/global对象.html","excerpt":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。","text":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。 全局变量在所有模块中均可使用。 但以下变量的作用域只在模块内12345__dirname__filenameexportsmodulerequire() __dirname1console.log(__dirname) # 获取当前模块的文件所在的文件夹名称的绝对路径 __filename1console.log(__filename) # 获取当前模块的文件名称-解析后的绝对路径 setImmediate(callback[, …args])123setImmediate(() =&gt; &#123; console.log(&apos;坑呀&apos;) # 把参数函数放到下一个时间环中执行&#125;); clearImmediate(immediate)1234let a = setImmediate(() =&gt; &#123; console.log(&apos;坑呀&apos;) # 取消一个由 setImmediate() 创建的 Immediate 对象&#125;);clearImmediate(a) process 进程process.cwd()1console.log(process.cwd()) # 方法返回 Node.js 进程当前工作的目录。 process.argv1234567891011// a.jsconsole.log(process.argv) // 执行node a.js a=1 b=2// 输出[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;c:\\\\Users\\\\windows\\\\Desktop\\\\新建文件夹\\\\a.js&apos;, &apos;a=1&apos;, &apos;b=2&apos; ] process.argv 属性返回一个数组，这个数组包含了启动Node.js进程时的命令行参数。第一个元素为process.execPath。如果需要获取argv[0]的值请参见 process.argv0。第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。 process.env1console.log(process.env) # 返回一个包含用户环境信息的对象 可以修改这个对象12process.env.foo = &apos;bar&apos;;console.log(process.env.foo); # 输出bar 但是不可以用这种方法去修改1node http.js &apos;process.env.foo = &quot;bar&quot;&apos; 用 delete从process.env中删除一个属性123process.env.foo = &apos;bar&apos;;delete process.env.foo;console.log(process.env.foo); # 输出 undefined 注: 在process.env中新增一个属性，会将属性值转换成字符串、 在Windows系统下，环境变量是不区分大小写的。 process.memoryUsage()1234567console.log(process.memoryUsage()) # 返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。// 输出&#123; rss: 23588864, heapTotal: 7708672, heapUsed: 4430656, external: 8224 &#125; rss（resident set size）：所有内存占用，包括指令区和堆栈。heapTotal：”堆”占用的内存，包括用到的和没用到的。heapUsed：用到的堆的部分。external： V8 引擎内部的 C++ 对象占用的内存。 process.chdir(directory)1234567console.log(process.cwd())process.chdir(&apos;..&apos;) # 方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。console.log(process.cwd())// 输出 &apos;..&apos;切换到上一级目录C:\\Users\\windows\\Desktop\\新建文件夹C:\\Users\\windows\\Desktop process.nextTick(callback[, …args])123process.nextTick(function()&#123; console.log(&apos;nextTick&apos;); # 放到当前任务末尾执行&#125;) 参考http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttp://nodejs.cn/api/process.html#process_processhttp://nodejs.cn/api/globals.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"http模块","slug":"http模块","date":"2018-01-15T17:05:37.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"http模块.html","link":"","permalink":"http://blog.langpz.com/http模块.html","excerpt":"http模块http模块是node提供搭建http客户端和服务端的核心模块。","text":"http模块http模块是node提供搭建http客户端和服务端的核心模块。 什么是客户端和什么是服务端客户端（Client），是指与服务器相对应，为客户提供本地服务的程序。一般安装在普通的用户机上，需要与服务端互相配合运行。互联网发展以后，较常用的客户端包括了如万维网使用的网页浏览器，收寄电子邮件时的电子邮件客户端，以及即时通信的客户端软件等。服务端(Server)，是为客户端服务的，服务的内容诸如向客户端提供资源，保存客户端数据。是实现游戏特色化的重要途径，也是最直接可以通过游戏表现出来的技术，比如你要修改某个NPC的参数，重加载后，在游戏内立刻体现出来。 搭建一个服务器123456789var http = require(&apos;http&apos;);var app = http.createServer(function(request,response)&#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&apos;入坑了...&apos;); response.end();&#125;);app.listen(8000); http.createServer() 创建一个服务器的实例，它的参数是一个函数，函数里有两个参数request和response，request是从客户端的请求、response是服务端的响应。输入 http://localhost:8000 就可以看到（入坑了…）这几个字。代表创建成功。response.writeHead() 发送一个http响应头给请求。response.write() 向客户端发送响应体。response.end() 结束响应。listen() 监听的端口。 客户端向HTTP服务器发起请求http.request(options[, callback])12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// request.jsvar http = require(&apos;http&apos;);var querystring = require(&apos;querystring&apos;);const postData = querystring.stringify(&#123; &apos;msg&apos;: &apos;Hello World!&apos;&#125;);const options = &#123; hostname: &apos;localhost&apos;, port: 80, path: &apos;/&apos;, method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;: Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`状态码: $&#123;res.statusCode&#125;`); console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding(&apos;utf8&apos;); res.on(&apos;data&apos;, (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;响应中已无数据。&apos;); &#125;);&#125;);req.on(&apos;error&apos;, (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`);&#125;);// 写入数据到请求主体req.write(postData);req.end();// sever.jslet http = require(&apos;http&apos;);let querystring = require(&apos;querystring&apos;);let app = http.createServer( (res,req) =&gt; &#123; let str = &apos;&apos;; res.on(&apos;data&apos;, (data) =&gt; &#123; str += data &#125;); res.on(&quot;end&quot;, () =&gt; &#123; str = querystring.parse(str) console.log(str) // 向客户端返回数据 req.end(`提交成功了: $&#123;str.msg&#125;`) &#125;) &#125;);app.listen(80); 客户端会输出1234状态码: 200响应头: &#123;&quot;date&quot;:&quot;Fri, 02 Feb 2018 03:37:39 GMT&quot;,&quot;connection&quot;:&quot;close&quot;,&quot;content-length&quot;:&quot;29&quot;&#125;响应主体: 提交成功了: Hello World!响应中已无数据。 我们可以写个定时器用request方法，一直向某个网站提交信息。 options: Object | string | URL protocol &lt;string&gt; 使用的协议。默认为 http:。 host &lt;string&gt; 请求发送至的服务器的域名或 IP 地址。默认为 localhost。 hostname &lt;string&gt; host 的别名。为了支持 url.parse()，hostname 优先于 host。 family &lt;number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。 port &lt;number&gt; 远程服务器的端口。默认为 80。 localAddress &lt;string&gt; 为网络连接绑定的本地接口。 socketPath &lt;string&gt; Unix 域 Socket（使用 host:port 或 socketPath）。 method &lt;string&gt; 指定 HTTP 请求方法的字符串。默认为 ‘GET’。 path &lt;string&gt; 请求的路径。默认为 ‘/‘。 应包括查询字符串（如有的话）。如 ‘/index.html?page=12’。 当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。 headers &lt;Object&gt; 包含请求头的对象。 auth &lt;string&gt; 基本身份验证，如 ‘user:password’ 用来计算 Authorization 请求头。 agent &lt;http.Agent&gt; | &lt;boolean&gt; 控制 Agent 的行为。 可能的值有：undefined (默认): 对该主机和端口使用 http.globalAgent。 Agent 对象：显式地使用传入的 Agent。false: 创建一个新的使用默认值的 Agent。 createConnection &lt;Function&gt; 当不使用 agent 选项时，为请求创建一个 socket 或流。 这可以用于避免仅仅创建一个自定义的 Agent 类来覆盖默认的 createConnection 函数。详见 agent.createConnection()。 timeout &lt;number&gt;: 指定 socket 超时的毫秒数。 它设置了 socket 等待连接的超时时间。 发起get请求 http.get(options[, callback])123456789101112131415161718192021222324252627var http = require(&apos;http&apos;);http.get(&apos;http://blog.langpz.com&apos;, (res) =&gt; &#123; const &#123; statusCode &#125; = res; let str = &quot;&quot;; let error; if (statusCode !== 200) &#123; error = new Error(&apos;请求失败。\\n&apos; + `状态码: $&#123;statusCode&#125;`); &#125; res.on(&quot;data&quot;, (data) =&gt; &#123; str += data &#125;); if (error) &#123; console.error(error.message); // 消耗响应数据以释放内存 res.resume(); return; &#125; res.on(&quot;end&quot;, () =&gt; &#123; console.log(str) &#125;) &#125;).on(&apos;error&apos;, (e) =&gt; &#123; console.error(`出错了: $&#123;e.message&#125;`);&#125;); 网站内容就爬下来了。该方法与 http.request() 唯一的区别是它设置请求方法为 GET 且自动调用 req.end()。 参考https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AFhttps://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AFhttp://nodejs.cn/api/http.html#http_http_request_options_callback","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Node模块机制","slug":"Node模块机制","date":"2018-01-08T16:11:02.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Node模块机制.html","link":"","permalink":"http://blog.langpz.com/Node模块机制.html","excerpt":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。","text":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。一个Node应用由模块组成，每个js文件就是一个独立模块。npm基于commonjs实现包的管理使我们开发Node.js更方便。 commonjs规范引用模块在commonjs规范中，定义了 require() 方法，这个方法接受一个模块的标识。1var math = require(&apos;math&apos;); 定义模块模块有自己的作用域。在模块里面定义的变量、函数、类，都是私有的，对其他文件不可见。 上下文中提供了一个 exports 对象可以导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表当前模块，exports 是 module 的属性。12345// math.jsfunction add(a,b)&#123; return a + b;&#125;exports.add = add; # 导出一个add的方法 再新建一个文件就可以用 require()引用这个模块了123// app.jsvar math = require(&apos;math&apos;);console.log(math.add(1,2)); # 3 模块标识模块标识就是传递给 require() 方法的参数，它必须是符合小驼峰命名的规范，或者以 .. 开头的相对路径，或者绝对路径。它可以没有文件后缀名.js。 模块缓存加载模块后会被缓存,多次加载还是同一个对象。查看模块缓存 require.cache查看模块绝对路径 require.resolve(./math.js)删除模块的缓存 require.cache[require.resolve(./math.js)] 模块的循环加载123456789101112131415161718192021// a.jsconsole.log(&apos;a 开始&apos;);exports.done = false;const b = require(&apos;./b.js&apos;);console.log(&apos;在 a 中，b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a 结束&apos;);// b.jsconsole.log(&apos;b 开始&apos;);exports.done = false;const a = require(&apos;./a.js&apos;);console.log(&apos;在 b 中，a.done = %j&apos;, a.done);exports.done = true;console.log(&apos;b 结束&apos;);// main.jsconsole.log(&apos;main 开始&apos;);const a = require(&apos;./a.js&apos;);const b = require(&apos;./b.js&apos;);console.log(&apos;在 main 中，a.done=%j，b.done=%j&apos;, a.done, b.done); 当 main.js 加载 a.js 时，a.js 又加载 b.js。 此时，b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。 当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是： 123456789node main.jsmain 开始a 开始b 开始在 b 中，a.done = falseb 结束在 a 中，b.done = truea 结束在 main 中，a.done=true，b.done=true module对象module.children 被该模块引用的模块对象。module.id 模块的标识符。 通常是完全解析后的文件名。module.parent 最先引用该模块的模块。module.paths 模块的搜索路径。… 更多去官网查询 Node的模块在Node中，模块分为两类：一类是Node提供的模块，称为核心模块。另外一类是用户编写的模块，称为文件模块。核心模块定义在 Node.js 源代码的 lib/ 目录下。require() 总是会优先加载核心模块。 例如，require(‘http’) 始终返回内置的 HTTP 模块，即使有同名文件。 module.exports和exports区别exports是module.exports对象的引用12345678910111213function require(/* ... */) &#123; const module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // 模块代码在这。在这个例子中，定义了一个函数。 function someFunc() &#123;&#125; exports = someFunc; // 此时，exports 不再是一个 module.exports 的快捷方式， // 且这个模块依然导出一个空的默认对象。 module.exports = someFunc; // 此时，该模块导出 someFunc，而不是默认对象。 &#125;)(module, module.exports); return module.exports;&#125; 参考http://nodejs.cn/api/modules.html#modules_cycles","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"什么是Node.js","slug":"什么是Node-js","date":"2018-01-08T13:29:21.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"什么是Node-js.html","link":"","permalink":"http://blog.langpz.com/什么是Node-js.html","excerpt":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。","text":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 I/O输入(Input)： 从系统写入文件输出(Output)： 从系统读取文件 同步和异步同步是指发起一个调用之后主线程挂起，调用者主动等待调用返回结果。异步是指发起一个调用之后主线程还可以发起别的调用，被调用者通知调用者返回结果。 阻塞式和非阻塞式非阻塞式是指发起一个调用不会阻塞主线程的执行，非阻塞式是实现异步的前提。阻塞式是指发起一个调用主线程是被挂起，调用完成后才可以执行其他操作。 单线程和多线程单线程是指程序按顺序执行,前面的程序执行完后面才程序可以执行。多线程是指同时执行多个程序，当前程序执行不影响其他程序执行。 事件驱动这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"VSCode 配置Node调试环境","slug":"VSCode-配置Node调试环境","date":"2018-01-05T17:17:59.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"VSCode-配置Node调试环境.html","link":"","permalink":"http://blog.langpz.com/VSCode-配置Node调试环境.html","excerpt":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。","text":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。 首先下载VSCodehttps://code.visualstudio.com/下载对应系统的安装包 下载VSCode 新建文件打开VSCode新建一个文件夹hello，在里面再新建一个app.js 新建文件 app.js的代码12345for (let index = 0; index &lt; 5; index++) &#123; console.log(index) &#125;console.log(&apos;Hello Word&apos;) 开始调试再点调试，快捷键（Ctrl+Shift+D）,添加配置选择Node.js。注： “program”: “${workspaceFolder}/app.js” /app.js 可以是任何名字，但是一定要是你入口文件。 调试 打断点开始打断点。 打断点 执行app.js操作和浏览器调试类似。 执行app.js","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://blog.langpz.com/tags/VSCode/"}]},{"title":"Git配置https免用户名和密码提交","slug":"Git配置https免用户名和密码提交","date":"2018-01-03T14:15:36.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Git配置https免用户名和密码提交.html","link":"","permalink":"http://blog.langpz.com/Git配置https免用户名和密码提交.html","excerpt":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。","text":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。 在Git Bash 里面输入命令。1git config --global credential.helper store 然后再提交输入用户名和密码提交完成后，用户名和密码就被保存了，下次再提交就不用再输入了。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"javascript数组去重","slug":"javascript数组去重","date":"2018-01-02T10:25:35.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"javascript数组去重.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重.html","excerpt":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。","text":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。 1234567891011Array.prototype.removal = function removal()&#123; var hash = &#123;&#125;, arr = []; for(var i = 0; i &lt; this.length; i++)&#123; if(!hash[this[i]])&#123; arr.push(this[i]); &#125; hash[this[i]] = 1; &#125; return arr;&#125; javascript数组去重","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"}]},{"title":"Hexo博客多端同步问题","slug":"Hexo博客多端同步问题","date":"2017-12-29T16:38:22.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Hexo博客多端同步问题.html","link":"","permalink":"http://blog.langpz.com/Hexo博客多端同步问题.html","excerpt":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。","text":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。 博客源文件同步在博客根目录执行 123456git initgit remote add origin git@github.com:lanpangzhi/lanpangzhi.github.io.git # 添加远程仓库 注意这里要添加你自己的仓库 lanpangzhi 换成你自己的用户名git checkout -b hexo # 新建hexo分支并切换到hexo分支git add . # 所有变化提交到暂存区git commit -m &quot;解决同步问题&quot; # 提交文件git push origin hexo # 推送hexo分支 这就成功了，github上已经有博客的源文件了。 github查看提交成功 推荐把hexo设置为默认分支。 hexo设置为默认分支 git submodule 实现第三方主题同步因为之前是直接把第三方主题克隆到博客目录，有什么改动是无法推送到作者Git仓库的，这个时候需要把第三方主题的项目Fork到自己仓库，自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下仓库的url。 Fork第三方主题 执行如下操作。1git submodule add git@github.com:lanpangzhi/hexo-theme-next.git themes/next 把自己仓库下面第三方主题添加到Git子模块， 注 : themes/next 这里的目录是因为我用的next主题才会写themes/next 如果你用的不是next请把next替换成你的第三方主题文件夹名字。 博客的根目录会多一个.gitmodules文件,这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录。 .gitmodules文件 这就添加成功了，然后执行如下操作。123git add . # 所有变化提交到暂存区git commit -m &quot;添加第三方主题Git子模块&quot; # 提交文件git push origin hexo # 推送hexo分支 更换电脑同步博客和第三方主题同步博客电脑上一定要先node和git，执行如下操作。 1234npm install hexo-cli -g # 先安装hexo的脚手架git clone git@github.com:lanpangzhi/lanpangzhi.github.io.git # 下载项目，因为hexo 是默认分支，所以这里直接会下载hexo分支npm i # 安装依赖hexo s # 启动服务器 剩下的就自行操作了。博客已经完成了同步。 注：每次写完文章部署网站后，记得再执行如下操作。 123git add . # 所有变化提交到暂存区git commit -m &quot;新增xxx文章&quot; # 提交文件git push origin hexo # 推送hexo分支 同步第三方主题在博客根目录执行如下操作。12git submodule init # 初始化本地配置文件git submodule update # 拉取子模块 如果第三方主题有修改的，修改完成后在第三方主题目录执行。 123git add . # 所有变化提交到暂存区git commit -m &quot;修改主题xxxx&quot; # 提交文件git push origin master # 推送master分支 这样就会把修改的主题推送到自己的仓库。 修改的主题推送到自己的仓库 这样就实现多端同步了。 参考http://devtian.me/2015/03/17/blog-sync-solutionhttps://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm install 报错提示请使用管理员","slug":"npm-install-报错提示请使用管理员","date":"2017-12-27T11:07:20.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"npm-install-报错提示请使用管理员.html","link":"","permalink":"http://blog.langpz.com/npm-install-报错提示请使用管理员.html","excerpt":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误","text":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误Please try running this command again as root/Administrator 解决方案: 后面加上–no-optional 或者降级 5.3 版本 升级更高版本 npm install hexo-cli -g --no-optional 参考https://stackoverflow.com/questions/46020018/error-eperm-operation-not-permitted-unlink-d-sources-node-modules-fseven","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"nvm管理node.js版本（Windows系统）","slug":"nvm管理node-js版本（Windows系统）","date":"2017-12-26T14:03:59.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"nvm管理node-js版本（Windows系统）.html","link":"","permalink":"http://blog.langpz.com/nvm管理node-js版本（Windows系统）.html","excerpt":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows）","text":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows） 先去下载nvm-windows下载链接地址 注：目前版本1.1.6。如果你之前安装过node，先卸载掉。 安装nvm-windows刚才下载的是 nvm-setup.zip 这个文件 1输入 nvm 这就安装成功了。 安装node安装最新稳定版 node 1nvm install latest 安装指定版本 node 1nvm install 8.9.0 切换node版本1nvm use 9.3.0 nvm list 显示当前安装node版本列表 * 代表当前使用的版本 注: 安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 nvm基本命令nvm arch [32|64]: 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm install [arch]: version 版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm list [available]: 显示当前安装node版本列表 * 代表当前使用的版本，在末尾输入 available 显示可供下载的所有版本列表。nvm on: 使用Node.js版本管理。nvm off: 禁用node.js版本管理（不会卸载任何东西）。nvm proxy [url]: 设置下载的代理，将[url]留空以查看当前代理。 将[url]设置为 none 以删除代理。nvm uninstall : 卸载指定的node版本。nvm use [arch]: 切换指定的node版本，可选[arch]32和64位版本。nvm root : 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录。nvm version: 显示Windows的NVM的当前运行版本。nvm node_mirror : 设置node节点镜像。国内可以使用 https://npm.taobao.org/mirrors/node/nvm npm_mirror : 设置npm节点镜像。国内可以使用 https://npm.taobao.org/mirrors/npm/ 参考https://github.com/coreybutler/nvm-windows","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hexo+Next集成Algolia搜索","slug":"Hexo-Next集成Algolia搜索","date":"2017-12-22T13:13:18.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"Hexo-Next集成Algolia搜索.html","link":"","permalink":"http://blog.langpz.com/Hexo-Next集成Algolia搜索.html","excerpt":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后","text":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 首先注册Algolia账户Algolia 登陆页面https://www.algolia.com/users/sign_in，可以使用 GitHub 或者 Google 账户直接登录，也可以注册一个新账户。我直接用谷歌账户登陆了，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。 注册完成后，创建一个新的 Index，这个 index name 之后会用到Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： 1npm install hexo-algolia --save # 目前最新版本是1.2.4，下面的操作都是基于这个版本的文档 获取 Key，更新站点根目录配置 前往站点根目录打开_config.yml添加以下代码 12345# Algolia Search API Keyalgolia: applicationID: &apos;你的Application ID&apos; apiKey: &apos;你的Search-Only API Key&apos; indexName: &apos;输入刚才创建index name&apos; 修改Algolia搜索ACL（访问控制列表） 选中后保存。 操作完成后执行命令123export(windows 为 set) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API keyset (Mac和git bash 为 export) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY #查看是否设置成功如果没有值就设置失败hexo algolia 成功后修改Next主题配置文件更改Next主题配置文件，找到 Algolia Search 配置部分： 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot; hits_stats: &quot;找到约$&#123;hits&#125;条结果（用时$&#123;time&#125;ms）&quot; 将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。这个是我修改的文本。 总结一下集成遇到的BUGPlease provide an Algolia index name in your hexo _config.yml flle 原因：Algolia Search API Key indexName 错了 解决方案：看下之前新建index的名字 Not enough rights to update an object near 原因：没有修改Algolia搜索ACL（访问控制列表） 解决方案： 按1.4操作勾选上就可以 移动端遮罩盖住搜索 原因：遮罩的z-index值太高，我的next主题是5.1.3版本可能其他版本没有这个BUG 解决方案： 找到\\themes\\next\\source\\css_common\\components\\third-party 下面的algolia-search.styl 文件 第8行追加12+mobile() z-index: 1000 参考http://theme-next.iissnan.com/third-party-services.html#algolia-searchhttps://github.com/oncletom/hexo-algolia","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm使用介绍","slug":"npm使用介绍","date":"2017-12-20T14:56:09.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"npm使用介绍.html","link":"","permalink":"http://blog.langpz.com/npm使用介绍.html","excerpt":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com","text":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com 创建一个模块1npm init 会提示你输入包名等，然后生成一个package.json文件,文件内容如下1234567891011&#123; &quot;name&quot;: &quot;xxx&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;lanpang&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; package.json文件属性说明 name - 包名 version - 包的版本号 description - 包的描述，方便在npm search中搜索 main - main字段配置一个文件名指向模块的入口程序。如果你包的名字叫xxx，然后用户require(“xxx”)，main配置的模块的exports对象会被返回 scripts - 是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令 author - 作者 license - 许可证，让人知道使用的权利和限制的更多说明请查看https://github.com/ericdum/mujiang.info/issues/6/ 安装模块1234npm install (Module Name) options # 语法npm install express # 本地安装npm install express -g # 全局安装npm install express@1.0.0 # 安装指定版本 npm 的包安装分为本地安装（local）、全局安装（global）两种。 本地安装：将安装包放在当前目录下的 ./node_modules 下。 本地安装：可以通过 require(Module Name) 来引入本地安装的包。 全局安装：node安装目录/node_modules。 全局安装：可以直接在命令行里使用。 查看全局安装目录1npm list -g --depth=0 安装包信息将加入到dependencies（生产阶段的依赖）12npm install express --save # npm5已经将--save变成了默认参数，执行 install 依赖包时默认都会带上，除非加上 --no-save。npm install express -S # 缩写 安装包信息将加入到devDependencies（开发和测试阶段的依赖）12npm install gulp --save-devnpm install gulp -D # 缩写 注: 包的依赖都被写入了package.json文件后，他人git或者svn下载项目可以通过npm install 安装项目依赖的包。 卸载包1npm uninstall gulp # 如果你安装的包带参数 --save 或者 --save-dev 必须npm uninstall gulp 要添加对应参数 更新包更新本地包1npm update gulp 更新全局包1npm update gulp -g 检查包是否已经过时检查本地包1npm outdated 检查全局包1npm outdated -g --depth=0 搜索包1npm search express 查看包安装信息查看本地包1npm list 查看全局包1npm list -g npm-scripts可以修改package.json文件scripts增加自定义命令，执行一些操作123&quot;scripts&quot;: &#123; &quot;start&quot; : &quot;gulp&quot;&#125; 此时在cmd或git bash中输入npm start 就会执行gulp命令 包版本号默认1.0.0 bug修复和其他小的变化：修补程序版本，增加最后一个数字，例如1.0.1。 不破坏现有功能的新功能：次要版本，增加中间数字，例如1.1.0。 主要版本，增加第一个数字，例如2.0.0。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"国内学生云主机优惠整理","slug":"国内学生云主机优惠整理","date":"2017-12-20T10:10:37.000Z","updated":"2018-05-17T05:09:39.336Z","comments":true,"path":"国内学生云主机优惠整理.html","link":"","permalink":"http://blog.langpz.com/国内学生云主机优惠整理.html","excerpt":"腾讯云云+校园扶持计划10元／月链接地址","text":"腾讯云云+校园扶持计划10元／月链接地址 阿里云云翼计划9.9元／月 59元／半年 118元／年链接地址 美团云云帆校园扶持计划8.8元／月链接地址 京东云跃云计划8.8元／月 88 元／年链接地址 注： 必须是要在籍大学生进行学生认证才可以购买","categories":[],"tags":[{"name":"云主机","slug":"云主机","permalink":"http://blog.langpz.com/tags/云主机/"}]},{"title":"css实现单行、多行文本溢出显示省略号","slug":"css实现单行、多行文本溢出显示省略号","date":"2017-12-19T10:58:41.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"css实现单行、多行文本溢出显示省略号.html","link":"","permalink":"http://blog.langpz.com/css实现单行、多行文本溢出显示省略号.html","excerpt":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号","text":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号 css实现多行文本溢出显示省略号12345display: -webkit-box; // 设置弹性盒子模型overflow : hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号-webkit-line-clamp: 2; // 限制在一个块元素显示的文本的行数-webkit-box-orient: vertical; // 属性规定框的子元素应该被水平或垂直排列。 注：因为用了webkit的私有属性，建议只在移动端使用。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"npm设置淘宝镜像","slug":"npm设置淘宝镜像","date":"2017-12-15T16:06:34.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"npm设置淘宝镜像.html","link":"","permalink":"http://blog.langpz.com/npm设置淘宝镜像.html","excerpt":"npm设置淘宝镜像 我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙）","text":"npm设置淘宝镜像 我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙） 我们可以通过设置淘宝镜像来解决问题 淘宝镜像同步频率目前为10分钟一次以保证尽量与官方服务同步。 设置成淘宝镜像 1npm config set registry http://registry.npm.taobao.org 查看设置是否成功 1npm get registry 注意如果你换成淘宝镜像的话，会影响你发布模块，这时候需要换回npm官网的镜像1npm config set registry https://registry.npmjs.org","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"node.js Windows下安装（笔记）","slug":"node-js-Windows下安装","date":"2017-12-12T16:26:01.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"node-js-Windows下安装.html","link":"","permalink":"http://blog.langpz.com/node-js-Windows下安装.html","excerpt":"首先去Node.js中文网下载安装包 偶数位为稳定版本，奇数位为非稳定版本（开发版） 稳定版本中已发布的API是不会改变的 奇数开头的开发版就是会不断变化更新","text":"首先去Node.js中文网下载安装包 偶数位为稳定版本，奇数位为非稳定版本（开发版） 稳定版本中已发布的API是不会改变的 奇数开头的开发版就是会不断变化更新 点这里去下载 如下图，选择系统对应的位数下载 双击打开你下载node-v8.9.0-x64.msi安装包 一路下一步 Node.js默认安装目录，你也可以点Change修改目录，点击下一步(Next) 点击下一步(Next) 点击安装(Install) 安装完检测PATH环境变量是否配置Node.js123win + r输入 cmd 回车输入 node -v 和 npm -v 会显示你安装node和npm的版本","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-12T16:00:01.000Z","updated":"2018-05-17T05:09:39.332Z","comments":true,"path":"hello-world.html","link":"","permalink":"http://blog.langpz.com/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}