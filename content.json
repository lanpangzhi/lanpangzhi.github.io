{"meta":{"title":"蓝胖纸","subtitle":"哆啦A梦","description":"我的大雄呢","author":"lanpangzhi","url":"http://blog.langpz.com"},"pages":[{"title":"","date":"2025-09-06T12:42:50.048Z","updated":"2025-09-06T12:42:50.048Z","comments":true,"path":"404.html","permalink":"http://blog.langpz.com/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":100,\"height\":200},\"mobile\":{\"show\":false},\"react\":{\"opacityDefault\":1,\"opacityOnHover\":0.2}});"},{"title":"","date":"2025-09-06T12:42:50.054Z","updated":"2025-09-06T12:42:50.054Z","comments":false,"path":"tags/index.html","permalink":"http://blog.langpz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS设计模式-工厂模式","slug":"JS设计模式-工厂模式","date":"2025-08-30T14:58:36.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-工厂模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-工厂模式.html","excerpt":"工厂模式是一种创建型设计模式，它提供了一种创建对象的优雅方式。将对象的创建与使用分离。我们在创建对象时不会对客户端暴露创建逻辑，客户端只需要知道如何使用对象即可。","text":"工厂模式是一种创建型设计模式，它提供了一种创建对象的优雅方式。将对象的创建与使用分离。我们在创建对象时不会对客户端暴露创建逻辑，客户端只需要知道如何使用对象即可。简单工厂模式简单工厂模式是一种创建型设计模式，它根据参数的不同返回不同类的实例。简单工厂模式的工厂类负责创建所有的实例。例如便利店，你告诉店员想要什么（比如一瓶可乐或一包薯片），店员直接从货架上拿给你，不需要知道商品是如何生产的。123456789101112131415161718192021222324252627282930313233343536373839// 简单工厂：集中式对象创建class SimpleFactory &#123; // 静态工厂方法，直接通过类调用 static createProduct(type) &#123; switch(type) &#123; case 'cola': return new Cola(); case 'crisps': return new Crisps(); default: throw new Error('没有这种商品'); &#125; &#125;&#125;// 产品类class Cola &#123; constructor() &#123; this.name = '可乐'; &#125; info() &#123; console.log(this.name); &#125;&#125;class Crisps &#123; constructor() &#123; this.name = '薯片'; &#125; info() &#123; console.log(this.name); &#125;&#125;// 客户端代码const cola = SimpleFactory.createProduct('cola');const crisps = SimpleFactory.createProduct('crisps');cola.info(); // 输出：可乐crisps.info(); // 输出：薯片工厂方法模式工厂方法模式定义了一个创建对象的接口，父类定义创建接口，子类负责具体实现，新增产品类型只需添加新的子类，无需改动现有代码。就像不同的专业工厂，每个工厂只专注做一类产品。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class CarFactory &#123; createCar() &#123; throw new Error('子类必须实现createCar方法'); &#125;&#125;// 奔驰工厂class BenzFactory extends CarFactory &#123; createCar(model) &#123; console.log('使用德国工艺标准生产'); return new BenzCar(model); &#125;&#125;// 宝马工厂class BMWFactory extends CarFactory &#123; createCar(model) &#123; console.log('使用巴伐利亚工艺标准生产'); return new BMWCar(model); &#125;&#125;// 汽车类class Car &#123; constructor(brand, model) &#123; this.brand = brand; this.model = model; &#125;&#125;class BenzCar extends Car &#123; constructor(model) &#123; super('奔驰', model); console.log(`生产了一辆$&#123;this.brand&#125; $&#123;this.model&#125;`); &#125;&#125;class BMWCar extends Car &#123; constructor(model) &#123; super('宝马', model); console.log(`生产了一辆$&#123;this.brand&#125; $&#123;this.model&#125;`); &#125;&#125;// 客户端代码const benzFactory = new BenzFactory();const benzCar = benzFactory.createCar('S级'); // 输出：使用德国工艺标准生产// 生产了一辆奔驰 S级const bmwFactory = new BMWFactory();const bmwCar = bmwFactory.createCar('X1');// 输出：使用巴伐利亚工艺标准生产// 生产了一辆宝马 X1抽象工厂模式抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。它强调产品之间的兼容性，确保创建的对象能够协同工作。抽象工厂就像智能家居生态系统（如小米、苹果），每个生态系统提供一系列兼容的产品（手机、手表、耳机），这些产品专门设计为能无缝协作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// 抽象工厂：声明创建一系列相关产品的接口class AbstractFactory &#123; createPhone() &#123; throw new Error('必须实现createPhone方法'); &#125; createWatch() &#123; throw new Error('必须实现createWatch方法'); &#125; createEarphones() &#123; throw new Error('必须实现createEarphones方法'); &#125;&#125;// 具体工厂1：小米生态系统class XiaomiFactory extends AbstractFactory &#123; createPhone() &#123; return new XiaomiPhone(); &#125; createWatch() &#123; return new XiaomiWatch(); &#125; createEarphones() &#123; return new XiaomiEarphones(); &#125;&#125;// 具体工厂2：苹果生态系统class AppleFactory extends AbstractFactory &#123; createPhone() &#123; return new iPhone(); &#125; createWatch() &#123; return new AppleWatch(); &#125; createEarphones() &#123; return new AirPods(); &#125;&#125;// 抽象产品接口class Phone &#123; call() &#123; throw new Error('必须实现call方法'); &#125; // 与同系列设备连接的方法 connectToWatch(watch) &#123; throw new Error('必须实现connectToWatch方法'); &#125;&#125;class Watch &#123; showTime() &#123; throw new Error('必须实现showTime方法'); &#125;&#125;class Earphones &#123; playSound() &#123; throw new Error('必须实现playSound方法'); &#125;&#125;// 具体产品实现class XiaomiPhone extends Phone &#123; call() &#123; return '小米手机打电话'; &#125; connectToWatch(watch) &#123; if (watch instanceof XiaomiWatch) &#123; return '小米手机连接小米手表'; &#125; return '小米手机连接失败：不兼容的设备'; &#125;&#125;class iPhone extends Phone &#123; call() &#123; return '苹果手机打电话'; &#125; connectToWatch(watch) &#123; if (watch instanceof AppleWatch) &#123; return '苹果手机连接苹果手表'; &#125; return '苹果手机连接失败：不兼容的设备'; &#125;&#125;class XiaomiWatch extends Watch &#123; showTime() &#123; return '小米手表显示时间'; &#125;&#125;class AppleWatch extends Watch &#123; showTime() &#123; return '苹果手表显示时间'; &#125;&#125;class XiaomiEarphones extends Earphones &#123; playSound() &#123; return '小米耳机播放声音'; &#125;&#125;class AirPods extends Earphones &#123; playSound() &#123; return 'AirPods播放声音'; &#125;&#125;// 客户端代码function createDeviceSuite(factory) &#123; const phone = factory.createPhone(); const watch = factory.createWatch(); const earphones = factory.createEarphones(); return &#123; phone, watch, earphones, testCompatibility() &#123; return phone.connectToWatch(watch); &#125; &#125;;&#125;// 使用示例const xiaomiSuite = createDeviceSuite(new XiaomiFactory());console.log(xiaomiSuite.testCompatibility()); // 小米手机连接小米手表const appleSuite = createDeviceSuite(new AppleFactory());console.log(appleSuite.testCompatibility()); // 苹果手机连接苹果手表三种模式对比模式特点适用场景简单工厂一个工厂类负责所有产品创建产品种类较少，创建逻辑简单工厂方法每个工厂类负责一种产品产品种类较多，每种产品有独特的创建逻辑抽象工厂每个工厂创建一系列相关产品需要创建一系列相关的产品族","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://blog.langpz.com/tags/工厂模式/"}]},{"title":"JS设计模式-状态机模式","slug":"JS设计模式-状态机模式","date":"2025-07-26T10:18:49.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-状态机模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-状态机模式.html","excerpt":"状态机模式状态机模式（State Pattern）是一种行为设计模式，它允许对象在内部状态改变时改变它的行为。简单来说，就像一个开关，不同的状态下会有不同的行为表现。","text":"状态机模式状态机模式（State Pattern）是一种行为设计模式，它允许对象在内部状态改变时改变它的行为。简单来说，就像一个开关，不同的状态下会有不同的行为表现。状态机由以下几个核心组件构成：状态（State）：对象在某一时刻的特定条件或模式。事件（Event）：导致状态从一个状态转换到另一个状态的动作或触发器。转换（Transition）：从一个状态到另一个状态的改变，通常由事件触发，并且可能伴随某些动作。可以想象一下你的手机：待机状态：屏幕黑屏，按电源键可以唤醒解锁状态：屏幕亮起，可以滑动解锁使用状态：可以打开应用、拨打电话等充电状态：显示充电图标，限制某些功能每个状态都有特定的行为，状态之间可以相互转换，这就是状态机的核心思想。为什么要使用状态机模式？传统方式的问题123456789101112131415161718192021222324252627282930// 传统的if-else方式处理状态class TrafficLight &#123; constructor() &#123; this.state = 'red'; &#125; changeLight() &#123; if (this.state === 'red') &#123; this.state = 'green'; console.log('绿灯亮起，可以通行'); &#125; else if (this.state === 'green') &#123; this.state = 'yellow'; console.log('黄灯亮起，准备停车'); &#125; else if (this.state === 'yellow') &#123; this.state = 'red'; console.log('红灯亮起，禁止通行'); &#125; &#125; // 如果要添加新状态或新行为，代码会变得越来越复杂 handleEmergency() &#123; if (this.state === 'red') &#123; // 红灯时的紧急处理 &#125; else if (this.state === 'green') &#123; // 绿灯时的紧急处理 &#125; else if (this.state === 'yellow') &#123; // 黄灯时的紧急处理 &#125; &#125;&#125;状态机模式的优势代码更清晰：每个状态的逻辑独立，易于理解易于扩展：添加新状态不影响现有代码减少bug：状态转换规则明确，避免非法状态便于维护：修改某个状态的行为只需修改对应的状态类状态机模式的实现基础实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 状态接口class State &#123; handle(context) &#123; throw new Error('子类必须实现handle方法'); &#125;&#125;// 具体状态类class RedLight extends State &#123; handle(context) &#123; console.log('红灯亮起，禁止通行'); context.setState(new GreenLight()); &#125;&#125;class GreenLight extends State &#123; handle(context) &#123; console.log('绿灯亮起，可以通行'); context.setState(new YellowLight()); &#125;&#125;class YellowLight extends State &#123; handle(context) &#123; console.log('黄灯亮起，准备停车'); context.setState(new RedLight()); &#125;&#125;// 上下文类（状态机）class TrafficLight &#123; constructor() &#123; this.state = new RedLight(); &#125; setState(state) &#123; this.state = state; &#125; changeLight() &#123; this.state.handle(this); &#125;&#125;// 使用示例const trafficLight = new TrafficLight();trafficLight.changeLight(); // 红灯亮起，禁止通行trafficLight.changeLight(); // 绿灯亮起，可以通行trafficLight.changeLight(); // 黄灯亮起，准备停车trafficLight.changeLight(); // 红灯亮起，禁止通行实际案例：音乐播放器让我们用一个更贴近生活的例子——音乐播放器来演示状态机模式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 播放器状态基类class PlayerState &#123; play(player) &#123; throw new Error('子类必须实现play方法'); &#125; pause(player) &#123; throw new Error('子类必须实现pause方法'); &#125; stop(player) &#123; throw new Error('子类必须实现stop方法'); &#125;&#125;// 停止状态class StoppedState extends PlayerState &#123; play(player) &#123; console.log('开始播放音乐 🎵'); player.setState(new PlayingState()); &#125; pause(player) &#123; console.log('当前已停止，无法暂停'); &#125; stop(player) &#123; console.log('当前已经是停止状态'); &#125;&#125;// 播放状态class PlayingState extends PlayerState &#123; play(player) &#123; console.log('当前正在播放中'); &#125; pause(player) &#123; console.log('暂停播放 ⏸️'); player.setState(new PausedState()); &#125; stop(player) &#123; console.log('停止播放 ⏹️'); player.setState(new StoppedState()); &#125;&#125;// 暂停状态class PausedState extends PlayerState &#123; play(player) &#123; console.log('继续播放 ▶️'); player.setState(new PlayingState()); &#125; pause(player) &#123; console.log('当前已经是暂停状态'); &#125; stop(player) &#123; console.log('停止播放 ⏹️'); player.setState(new StoppedState()); &#125;&#125;// 音乐播放器类class MusicPlayer &#123; constructor() &#123; this.state = new StoppedState(); this.currentSong = ''; &#125; setState(state) &#123; this.state = state; &#125; play() &#123; this.state.play(this); &#125; pause() &#123; this.state.pause(this); &#125; stop() &#123; this.state.stop(this); &#125; loadSong(song) &#123; this.currentSong = song; console.log(`加载歌曲: $&#123;song&#125;`); &#125;&#125;// 使用示例const player = new MusicPlayer();player.loadSong('陈奕迅 - 爱情转移');player.play(); // 开始播放音乐 🎵player.play(); // 当前正在播放中player.pause(); // 暂停播放 ⏸️player.pause(); // 当前已经是暂停状态player.play(); // 继续播放 ▶️player.stop(); // 停止播放 ⏹️player.pause(); // 当前已停止，无法暂停进阶案例：订单状态管理在电商系统中，订单状态管理是状态机模式的经典应用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// 订单状态基类class OrderState &#123; constructor(name) &#123; this.name = name; &#125; pay(order) &#123; console.log(`订单$&#123;this.name&#125;状态下无法支付`); &#125; ship(order) &#123; console.log(`订单$&#123;this.name&#125;状态下无法发货`); &#125; receive(order) &#123; console.log(`订单$&#123;this.name&#125;状态下无法确认收货`); &#125; cancel(order) &#123; console.log(`订单$&#123;this.name&#125;状态下无法取消`); &#125;&#125;// 待支付状态class PendingPaymentState extends OrderState &#123; constructor() &#123; super('待支付'); &#125; pay(order) &#123; console.log('✅ 支付成功，订单进入待发货状态'); order.setState(new PendingShipmentState()); &#125; cancel(order) &#123; console.log('❌ 订单已取消'); order.setState(new CancelledState()); &#125;&#125;// 待发货状态class PendingShipmentState extends OrderState &#123; constructor() &#123; super('待发货'); &#125; ship(order) &#123; console.log('🚚 订单已发货，进入待收货状态'); order.setState(new ShippedState()); &#125; cancel(order) &#123; console.log('❌ 订单已取消，将退款处理'); order.setState(new CancelledState()); &#125;&#125;// 已发货状态class ShippedState extends OrderState &#123; constructor() &#123; super('已发货'); &#125; receive(order) &#123; console.log('📦 确认收货，订单完成'); order.setState(new CompletedState()); &#125;&#125;// 已完成状态class CompletedState extends OrderState &#123; constructor() &#123; super('已完成'); &#125;&#125;// 已取消状态class CancelledState extends OrderState &#123; constructor() &#123; super('已取消'); &#125;&#125;// 订单类class Order &#123; constructor(id, items) &#123; this.id = id; this.items = items; this.state = new PendingPaymentState(); this.createTime = new Date(); &#125; setState(state) &#123; console.log(`订单状态变更: $&#123;this.state.name&#125; -&gt; $&#123;state.name&#125;`); this.state = state; &#125; pay() &#123; this.state.pay(this); &#125; ship() &#123; this.state.ship(this); &#125; receive() &#123; this.state.receive(this); &#125; cancel() &#123; this.state.cancel(this); &#125; getStatus() &#123; return this.state.name; &#125;&#125;// 使用示例const order = new Order('ORD001', ['iPhone 15', 'AirPods']);console.log(`订单创建，当前状态: $&#123;order.getStatus()&#125;`);order.pay(); // ✅ 支付成功，订单进入待发货状态order.ship(); // 🚚 订单已发货，进入待收货状态order.receive(); // 📦 确认收货，订单完成// 演示错误操作order.pay(); // 订单已完成状态下无法支付order.cancel(); // 订单已完成状态下无法取消使用状态机模式的最佳实践1. 状态转换图在实现状态机之前，先画出状态转换图：1234待支付 --[支付]--&gt; 待发货 --[发货]--&gt; 已发货 --[确认收货]--&gt; 已完成 | | | | +--[取消]----------+--[取消]--------&gt; 已取消2. 状态验证12345678910111213141516171819202122232425class OrderStateMachine &#123; constructor() &#123; // 定义允许的状态转换 this.transitions = &#123; 'pending_payment': ['paid', 'cancelled'], 'paid': ['shipped', 'cancelled'], 'shipped': ['delivered'], 'delivered': [], 'cancelled': [] &#125;; &#125; canTransition(fromState, toState) &#123; return this.transitions[fromState]?.includes(toState) || false; &#125; transition(order, toState) &#123; if (this.canTransition(order.currentState, toState)) &#123; order.currentState = toState; console.log(`状态转换成功: $&#123;toState&#125;`); &#125; else &#123; console.log(`非法状态转换: $&#123;order.currentState&#125; -&gt; $&#123;toState&#125;`); &#125; &#125;&#125;3. 状态持久化1234567891011121314151617181920212223242526272829303132333435class PersistentOrder extends Order &#123; constructor(id, items) &#123; super(id, items); &#125; setState(state) &#123; super.setState(state); // 保存状态到数据库 this.saveToDatabase(); &#125; saveToDatabase() &#123; // 模拟保存到数据库 console.log(`保存订单 $&#123;this.id&#125; 状态: $&#123;this.state.name&#125;`); &#125; static loadFromDatabase(id) &#123; // 模拟从数据库加载 const orderData = &#123; id, state: 'paid', items: ['商品1'] &#125;; const order = new PersistentOrder(orderData.id, orderData.items); // 根据保存的状态恢复对象状态 switch(orderData.state) &#123; case 'pending_payment': order.state = new PendingPaymentState(); break; case 'paid': order.state = new PendingShipmentState(); break; // ... 其他状态 &#125; return order; &#125;&#125;总结状态机模式是一个非常实用的设计模式，特别适合以下场景：对象行为依赖于状态：如播放器、订单、游戏角色等状态转换规则复杂：有多个状态和转换条件需要避免大量if-else：让代码更清晰易维护优点📝 代码清晰：每个状态的逻辑独立🔧 易于扩展：添加新状态不影响现有代码🐛 减少bug：状态转换规则明确🔄 符合开闭原则：对扩展开放，对修改关闭缺点📈 增加类的数量：每个状态都需要一个类🏗️ 结构复杂：对于简单状态可能过度设计","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"状态机模式","slug":"状态机模式","permalink":"http://blog.langpz.com/tags/状态机模式/"}]},{"title":"JS设计模式-适配器模式","slug":"JS设计模式-适配器模式","date":"2025-06-28T16:18:49.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-适配器模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-适配器模式.html","excerpt":"适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类（或对象）的接口转换成客户端期望的另一个接口。适配器让那些由于接口不兼容而不能在一起工作的类可以协同工作。","text":"适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个类（或对象）的接口转换成客户端期望的另一个接口。适配器让那些由于接口不兼容而不能在一起工作的类可以协同工作。适配器模式使用场景在以下情况下可以考虑使用适配器模式：接口兼容问题： 系统需要使用现有的类，而这些类的接口不符合系统的需求。提高代码复用性：可以复用一些现有的、功能强大的类，而无需修改其源代码。增强系统灵活性：将客户端代码与具体实现解耦。如果未来需要替换或引入新的被适配者，只需创建一个新的适配器，而无需修改客户端代码。这在集成第三方库或处理遗留代码时尤其有用。适配器模式的结构适配器模式包含以下主要角色：目标接口（Target）：定义客户端使用的与特定领域相关的接口。适配者（Adaptee）：包含一些已有的功能，但其接口与目标接口不兼容。适配器（Adapter）：将适配者的接口转换成目标接口，使客户端能够与适配者进行交互。客户端 (Client) ：使用目标接口的代码适配器模式的实现多种支付方式适配器在电商系统中，我们经常需要集成多种支付方式（支付宝、微信支付、银联等），每种支付方式的接口都不相同。1. 目标接口 (Target)所有支付方式都需要提供一个统一的 pay(amount, orderId) 方法。1adapter.pay(amount, orderId);2. 适配者（Adaptee）1234567891011121314151617181920212223242526272829303132333435// 支付宝支付类class AlipayService &#123; makePayment(amount, orderId) &#123; console.log(`支付宝支付: 订单$&#123;orderId&#125;, 金额$&#123;amount&#125;元`); return &#123; success: true, transactionId: 'alipay_' + Date.now(), message: '支付宝支付成功' &#125;; &#125;&#125;// 微信支付类class WechatPayService &#123; pay(money, orderNumber) &#123; console.log(`微信支付: 订单$&#123;orderNumber&#125;, 金额$&#123;money&#125;元`); return &#123; status: 'ok', wxTransactionId: 'wx_' + Date.now(), desc: '微信支付完成' &#125;; &#125;&#125;// 银联支付类class UnionPayService &#123; processPayment(orderInfo) &#123; console.log(`银联支付: 订单$&#123;orderInfo.id&#125;, 金额$&#123;orderInfo.amount&#125;元`); return &#123; code: 200, unionPayId: 'union_' + Date.now(), result: '银联支付成功' &#125;; &#125;&#125;3. 适配器（Adapter）123456789101112131415161718192021222324252627282930313233343536373839class PaymentAdapter &#123; constructor(paymentService, type) &#123; this.paymentService = paymentService; this.type = type; &#125; pay(amount, orderId) &#123; let result; switch (this.type) &#123; case 'alipay': result = this.paymentService.makePayment(amount, orderId); return &#123; success: result.success, transactionId: result.transactionId, message: result.message &#125;; case 'wechat': result = this.paymentService.pay(amount, orderId); return &#123; success: result.status === 'ok', transactionId: result.wxTransactionId, message: result.desc &#125;; case 'unionpay': result = this.paymentService.processPayment(&#123; id: orderId, amount &#125;); return &#123; success: result.code === 200, transactionId: result.unionPayId, message: result.result &#125;; default: throw new Error('不支持的支付方式'); &#125; &#125;&#125;4. 客户端代码12345678910111213141516171819202122232425262728function processOrder(paymentType, amount, orderId) &#123; let paymentService; let adapter; switch (paymentType) &#123; case 'alipay': paymentService = new AlipayService(); adapter = new PaymentAdapter(paymentService, 'alipay'); break; case 'wechat': paymentService = new WechatPayService(); adapter = new PaymentAdapter(paymentService, 'wechat'); break; case 'unionpay': paymentService = new UnionPayService(); adapter = new PaymentAdapter(paymentService, 'unionpay'); break; &#125; const result = adapter.pay(amount, orderId); console.log('支付结果:', result); return result;&#125;// 测试processOrder('alipay', 100, '1');processOrder('wechat', 200, '2');processOrder('unionpay', 300, '3');扩展新支付方式新增 PayPal 支付时：新建 PaypalService 类；修改 PaymentAdapter 添加 “paypal” 的逻辑；修改 processOrder 添加 “paypal” 分支；优缺点总结优点代码复用 ：可以复用现有的类，无需修改其源代码解耦 ：将客户端代码与具体实现分离灵活性 ：可以轻松替换或添加新的适配器符合开闭原则 ：对扩展开放，对修改关闭缺点增加复杂性 ：引入了额外的抽象层性能开销 ：可能会有轻微的性能损失维护成本 ：需要维护适配器代码","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"适配器模式","slug":"适配器模式","permalink":"http://blog.langpz.com/tags/适配器模式/"}]},{"title":"JS设计模式-中介者模式","slug":"JS设计模式-中介者模式","date":"2025-05-25T16:04:14.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-中介者模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-中介者模式.html","excerpt":"中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列对象之间的交互，从而使得这些对象之间不再相互耦合，从而使得对象之间的通信更加灵活和可维护。这种模式特别适用于管理多个对象或组件间的复杂通信。","text":"中介者模式（Mediator Pattern）是一种行为型设计模式，它通过引入一个中介者对象来封装一系列对象之间的交互，从而使得这些对象之间不再相互耦合，从而使得对象之间的通信更加灵活和可维护。这种模式特别适用于管理多个对象或组件间的复杂通信。中介者模式案例聊天系统一个简化的聊天系统的中介者模式实现中介者类123456class ChatRoom &#123; showMessage(user, message) &#123; const time = new Date().toLocaleTimeString(); console.log(`[$&#123;time&#125;] $&#123;user.name&#125;: $&#123;message&#125;`); &#125;&#125;用户类123456789class User &#123; constructor(name, chatRoom) &#123; this.name = name; this.chatRoom = chatRoom; &#125; send(message) &#123; this.chatRoom.showMessage(this, message); &#125;&#125;测试12345const chatRoom = new ChatRoom();const user1 = new User('Lanpz', chatRoom);const user2 = new User('haha', chatRoom);user1.send('Hello, Lanpz!'); // 输出: [11:00:00] Lanpz: Hello, Lanpz!user2.send('Hi, haha!'); // 输出: [11:00:00] haha: Hi, haha!这个例子中，ChatRoom 类充当了中介者，User 类则是具体的用户。当用户发送消息时，消息会被传递给中介者，中介者打印消息。这样用户和用户之间的通信不再直接发生，而是通过中介者来进行。优点降低了对象之间的耦合性，使得对象之间的通信更加灵活和可维护。提高了系统的可扩展性，当需要添加新的对象时，只需要修改中介者即可，不需要修改原有对象。简化了对象之间的通信，使得对象之间的通信更加清晰和易于理解。缺点中介者对象可能会变得非常复杂，维护起来可能会比较困难。中介者对象可能会成为系统的瓶颈，影响系统的性能。中介者对象可能会成为系统的单点故障，影响系统的可用性。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"中介者模式","slug":"中介者模式","permalink":"http://blog.langpz.com/tags/中介者模式/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"}]},{"title":"DeepSeek本地部署","slug":"DeepSeek本地部署","date":"2025-04-19T10:31:29.000Z","updated":"2025-09-06T12:42:50.048Z","comments":true,"path":"DeepSeek本地部署.html","link":"","permalink":"http://blog.langpz.com/DeepSeek本地部署.html","excerpt":"DeepSeek本地部署DeepSeek 是由深度求索公司开发的一系列强大的开源大语言模型主打高效推理与成本优势。在本地部署这些模型，可以让你在没有网络连接或出于隐私考虑的情况下，也能利用它们的能力。","text":"DeepSeek本地部署DeepSeek 是由深度求索公司开发的一系列强大的开源大语言模型主打高效推理与成本优势。在本地部署这些模型，可以让你在没有网络连接或出于隐私考虑的情况下，也能利用它们的能力。硬件要求对比本地部署 DeepSeek 模型对硬件有一定要求，主要取决于你选择的模型大小和是否使用量化。以下是不同参数规模模型的大致硬件需求对比：模型版本参数量（B = Billion）最低显存要求推荐硬件配置适用场景1.5B15 亿参数1GB 显存（纯 CPU 推理需 8GB 内存）CPU 4核+；内存8GB+；显卡可选4GB+（如GTX 1650）低资源设备、简单文本生成、物联网设备7B70 亿参数8GB 显存（4-bit量化可降至4GB）CPU 8核+；内存16GB+；RTX 3070/4060（8GB+）中小型企业开发测试、文本摘要、轻量级对话8B80 亿参数10GB 显存（8-bit量化）CPU 8核+；内存16GB+；RTX 4060Ti（10GB+）复杂逻辑推理、代码生成任务14B140 亿参数16GB 显存CPU 12核+；内存32GB+；RTX 4090/A5000（16GB+）企业级复杂任务、长文本理解与生成32B320 亿参数24GB 显存CPU 16核+；内存64GB+；A100 40GB或双RTX 3090高精度专业任务、多模态预处理、金融预测70B700 亿参数40GB+ 显存CPU 32核；内存128GB+；多卡并行（2xA100 80GB或4xRTX 4090）科研机构、大型企业的高复杂度生成任务Ollama 部署Ollama 是一个流行的工具，可以让你轻松地在本地运行各种开源大语言模型，包括 DeepSeek。用户可以轻松加载并使用这些模型进行文本生成、情感分析、问答等任务。下载Ollama访问 Ollama 官网或 GitHub Releases，下载对应系统的安装包并进行安装。下载DeepSeek模型下载并运行 DeepSeek-r1模型：打开终端或命令提示符，运行以下命令1ollama run deepseek-r1:1.5b如果是第一次运行，Ollama 会自动下载模型文件。下载完成后，你就可以在终端直接与模型交互了。通过 API 调用：Ollama 还提供了一个本地 API (默认在 http://localhost:11434 )，你可以通过编程方式调用模型。获取本地模型列表1curl http://localhost:11434/api/tags发送对话请求（推理）12345curl http://localhost:11434/api/generate -d '&#123; \"model\": \"deepseek-r1:1.5b\", \"prompt\": \"你好，介绍一下你自己\", \"stream\": false&#125;'Web UI 可视化界面除了命令行和 API，DeepSeek 及其他大模型还可以通过多种 Web UI 工具进行可视化操作，适合不懂代码的用户或需要多轮对话、历史管理等功能的场景。常见的 Web UI 工具有：LM Studio跨平台桌面应用，支持 DeepSeek、Llama、Qwen 等模型，内置模型下载和聊天界面，支持 OpenAI API 兼容。官网：https://lmstudio.ai/Text Generation WebUI (oobabooga)功能强大，支持多种模型格式（GGUF、GPTQ、Transformers等），插件丰富，适合高级用户。GitHub：https://github.com/oobabooga/text-generation-webuiOpen WebUI现代化 Web 聊天界面，支持 Ollama、LM Studio、OpenAI API 等后端，支持多会话和插件。GitHub：https://github.com/open-webui/open-webuiChatbot UI类似 ChatGPT 的前端界面，支持自定义 API 地址（如 Ollama、LM Studio）。GitHub：https://github.com/mckaywrigley/chatbot-ui这些 Web UI 工具大多支持直接加载本地模型，或通过 API 对接 Ollama/LM Studio 等后端，适合快速体验和部署本地大模型。你可以根据自己的需求和系统环境选择合适的 Web UI 工具。本地部署大模型的优点：数据隐私与安全 ：所有数据都在本地处理，无需上传到云端或第三方服务器，极大保障了用户隐私和企业数据安全。离线可用 ：无需依赖互联网，断网环境下也能正常使用，适合对网络环境有要求的场景。低延迟高响应 ：本地推理无需经过网络传输，响应速度更快，体验更流畅。成本可控 ：一次性硬件投入后，无需持续支付云服务费用，长期使用更经济。可定制化 ：可以根据自身需求对模型进行微调、裁剪、集成到本地业务系统，实现高度定制。本地模型还能扩展的方向包括：本地知识库检索 ：结合本地文档、数据库，实现企业/个人知识问答、智能客服等场景。插件与工具集成 ：与本地办公软件、自动化脚本、IoT设备等集成，提升自动化和智能化水平。多模态扩展 ：支持图片、语音、视频等多模态输入输出，打造更丰富的AI应用。本地微调与训练 ：根据自身数据进行微调，提升模型在特定领域的表现。API服务化 ：本地模型可作为API服务，对接前端、移动端、Web UI等多种应用。安全审计与合规 ：本地可控，便于满足行业合规和安全审计要求。本地大模型不仅能保护数据，还能成为企业和个人智能化升级的基础平台，具备极强的扩展性和灵活性。","categories":[],"tags":[{"name":"DeepSeek","slug":"DeepSeek","permalink":"http://blog.langpz.com/tags/DeepSeek/"},{"name":"AI","slug":"AI","permalink":"http://blog.langpz.com/tags/AI/"}]},{"title":"JS设计模式-代理模式","slug":"JS设计模式-代理模式","date":"2025-03-22T14:42:06.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-代理模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-代理模式.html","excerpt":"代理模式（Proxy Pattern）是一种设计模式，它为对象提供一个代理，以控制对该对象的访问。可以把代理理解为对象的“中间人”，在访问目标对象时，代理可以拦截操作，并进行处理、修改或限制。在 ES6 中，JavaScript 引入了 Proxy 对象，使得代理模式的实现变得更加简单和强大。","text":"代理模式（Proxy Pattern）是一种设计模式，它为对象提供一个代理，以控制对该对象的访问。可以把代理理解为对象的“中间人”，在访问目标对象时，代理可以拦截操作，并进行处理、修改或限制。在 ES6 中，JavaScript 引入了 Proxy 对象，使得代理模式的实现变得更加简单和强大。代理模式用法ES6 引入的 Proxy 对象让我们可以轻松创建代理。new Proxy(target, handler) 接受两个参数：target 是要代理的对象，handler 是一个对象，其中包含了代理的行为。1234567891011121314151617const target = &#123; name: 'Lanpz', age: 18&#125;;const handler = &#123; get: function(target, property) &#123; console.log(`访问属性: $&#123;property&#125;`); return target[property]; &#125;, set: function(target, property, value) &#123; console.log(`设置 $&#123;property&#125; 属性为 $&#123;value&#125;`); target[property] = value; &#125;&#125;const proxy = new Proxy(target, handler);proxy.name; // 访问属性: nameproxy.age = 20; // 设置 age 属性为 20在上面的例子中，我们创建了一个代理对象 proxy，它代理了 target 对象。当我们访问 proxy 的属性时，会触发 get 方法，当我们设置 proxy 的属性时，会触发 set 方法。代理的常见应用场景1. 数据验证代理可以用来验证数据的有效性，例如在表单提交时，我们可以使用代理来验证表单数据是否符合要求。123456789101112131415161718const form = &#123; name: '', age: ''&#125;;const handler = &#123; set: function(target, property, value) &#123; if (property === 'name' &amp;&amp; value.length &lt; 2) &#123; throw new Error('姓名长度不能小于2'); &#125; if (property === 'age' &amp;&amp; (value &lt; 0 || value &gt; 150)) &#123; throw new Error('年龄必须在0-150之间'); &#125; target[property] = value; &#125;&#125;const proxy = new Proxy(form, handler);proxy.name = 'Lanpz'; // 正确proxy.age = 180; // 报错提示：年龄必须在0-150之间2.保护对象属性代理可以用来保护对象的属性，例如在一个对象中，我们只想暴露部分属性给外部访问，但是不给外部删除和修改。123456789101112131415161718192021222324252627282930const obj = &#123; name: 'Lanpz', age: 18, _password: '123456'&#125;;const handler = &#123; get: function(target, property) &#123; if (property === '_password') &#123; return '******' &#125; return target[property]; &#125;, set: function(target, property, value) &#123; if (property.startsWith('_')) &#123; throw new Error('不能修改以 _ 开头的属性'); &#125; target[property] = value; &#125;, deleteProperty: function(target, property) &#123; if (property.startsWith('_')) &#123; throw new Error('不能删除以 _ 开头的属性'); &#125; delete target[property]; &#125;&#125;const proxy = new Proxy(obj, handler);console.log(proxy.name); // Lanpzproxy.age = 20; // 正确console.log(proxy._password); // ******delete proxy._password; // 报错提示：不能删除以 _ 开头的属性代理模式会带来一些性能上的开销，尤其是在频繁访问对象属性的场景下，因此在使用时需要权衡利弊。过度使用代理模式可能会导致代码变得难以维护，因此在使用代理模式时需要谨慎。通过代理模式，我们可以在不修改原始对象的情况下，增强对象的行为，实现各种高级功能。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://blog.langpz.com/tags/代理模式/"}]},{"title":"JS设计模式-单例模式","slug":"JS设计模式-单例模式","date":"2025-02-22T09:40:26.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-单例模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-单例模式.html","excerpt":"单例模式（Singleton Pattern），其核心思想是保证一个类只有一个实例，并提供一个全局访问点。","text":"单例模式（Singleton Pattern），其核心思想是保证一个类只有一个实例，并提供一个全局访问点。单例模式可以用来管理一些共享资源，例如全局配置、应用配置管理器、事件总线等。单例模式实现12345678910111213141516171819202122class Single &#123; constructor() &#123; if (Single.instance) &#123; return Single.instance; &#125; this.data = [] Single.instance = this; &#125; addData(data) &#123; this.data.push(data) &#125; getData() &#123; return this.data &#125;&#125;const single1 = new Single()const single2 = new Single()single1.addData(1)console.log(single2.getData()) // [1]console.log(single1 === single2) // true, single1 和 single2 为同一实例例子中，构造函数检查 Single.instance 是否已存在。如果存在则返回已有实例，否则创建新实例并缓存。这样，无论调用多少次构造函数，都只能得到同一个实例。单例模式的优缺点优点优点描述节省资源只创建一个实例，避免重复创建和销毁对象保证数据一致性所有代码访问的都是同一个对象实例全局访问点提供一个全局访问点，方便在应用的不同部分使用缺点缺点描述全局状态单例引入了全局状态，可能导致代码耦合度增加测试困难单例对象的状态在测试之间可能会相互影响，使测试变得困难隐藏依赖使用单例可能会隐藏类之间的依赖关系","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://blog.langpz.com/tags/单例模式/"}]},{"title":"JS设计模式-观察者模式","slug":"JS设计模式-观察者模式","date":"2025-01-19T15:45:00.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JS设计模式-观察者模式.html","link":"","permalink":"http://blog.langpz.com/JS设计模式-观察者模式.html","excerpt":"观察者模式是一种“一对多”依赖关系设计模式。被观察者（Subject）：保存着所有观察者的列表，当自身状态改变时，负责通知所有观察者。观察者（Observer）：实现一个更新接口，当接收到通知时自动执行相应操作。","text":"观察者模式是一种“一对多”依赖关系设计模式。被观察者（Subject）：保存着所有观察者的列表，当自身状态改变时，负责通知所有观察者。观察者（Observer）：实现一个更新接口，当接收到通知时自动执行相应操作。观察者模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// 被观察者类class Subject &#123; constructor() &#123; this.observers = []; // 存储所有观察者 &#125; // 添加观察者 addObserver(observer) &#123; this.observers.push(observer); &#125; // 删除观察者 removeObserver(observer) &#123; this.observers = this.observers.filter(o =&gt; o !== observer); &#125; // 通知所有观察者，传递相关数据 notifyObservers(data) &#123; this.observers.forEach(observer =&gt; observer.update(data)); &#125;&#125;// 观察者类class Observer &#123; constructor(name) &#123; this.name = name; &#125; // 当被观察者状态变化时调用该方法 update(data) &#123; console.log(`$&#123;this.name&#125; 收到更新：$&#123;data&#125;`); &#125;&#125;// 示例使用const subject = new Subject();const observer1 = new Observer(\"观察者1\");const observer2 = new Observer(\"观察者2\");// 添加观察者subject.addObserver(observer1);subject.addObserver(observer2);// 被观察者状态发生改变，通知所有观察者subject.notifyObservers(\"状态 A 已更新\");// 删除其中一个观察者后再次通知subject.removeObserver(observer1);subject.notifyObservers(\"状态 B 已更新\");demodemo地址","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://blog.langpz.com/tags/观察者模式/"}]},{"title":"手写PromiseA+ 实现","slug":"手写PromiseA-实现","date":"2024-12-31T19:28:49.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"手写PromiseA-实现.html","link":"","permalink":"http://blog.langpz.com/手写PromiseA-实现.html","excerpt":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。PromiseA+规范中文版实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166class MyPromise &#123; constructor(executor) &#123; // 2.1 Promise状态和值 this.status = \"pending\"; // 2.1.1 初始状态为pending this.value = undefined; // 2.1.2.2 fulfilled状态的值 2.1.3.2 rejected状态的值 this.onResolvedCallbacks = []; // 2.2.6.1 存储fulfilled的回调 this.onRejectedCallbacks = []; // 2.2.6.2 存储rejected的回调 // 3.1 确保异步执行 this.useMicroTask = typeof queueMicrotask === 'function' || typeof process?.nextTick === 'function'; const resolve = (value) =&gt; &#123; // 2.3.2 如果value是Promise，递归解析 if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; // 3.1 确保异步执行 this.asyncTask(() =&gt; &#123; if (this.status === 'pending') &#123; this.value = value; this.status = 'resolved'; // 状态从pending转换为fulfilled // 2.2.6.1 调用所有fulfilled回调 this.onResolvedCallbacks.forEach(fn =&gt; fn(value)); &#125; &#125;); &#125;; const reject = (reason) =&gt; &#123; // 3.1 确保异步执行 this.asyncTask(() =&gt; &#123; if (this.status === 'pending') &#123; this.value = reason; this.status = 'rejected'; // 状态从pending转换为rejected // 2.2.6.2 调用所有rejected回调 this.onRejectedCallbacks.forEach(fn =&gt; fn(reason)); &#125; &#125;); &#125;; try &#123; // 2.1.1、2.3 执行 executor 函数 resolve/reject 改变状态 executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 2.2.7.2 捕获 executor 内的异常，并以 reject 的形式处理 &#125; &#125; // 3.1 异步任务处理函数 asyncTask(fn) &#123; if (this.useMicroTask) &#123; // 优先使用微任务 if (typeof queueMicrotask === 'function') &#123; queueMicrotask(fn); &#125; else if (typeof process?.nextTick === 'function') &#123; process.nextTick(fn); &#125; &#125; else &#123; // 降级使用宏任务 setTimeout(fn, 0); &#125; &#125; // 2.2 then方法 then(onFulfilled, onRejected) &#123; // 2.2.1 参数可选 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; // 2.2.1.1 onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125;; // 2.2.1.2 // 2.2.7 then必须返回一个新的Promise const promise2 = new MyPromise((resolve, reject) =&gt; &#123; const handleFulfilled = () =&gt; &#123; // 3.1 确保异步执行 this.asyncTask(() =&gt; &#123; try &#123; const x = onFulfilled(this.value); // 2.2.5 调用onFulfilled resolvePromise(promise2, x, resolve, reject); // 2.2.7.1 处理返回值 &#125; catch (e) &#123; reject(e); // 2.2.7.2 捕获异常 &#125; &#125;); &#125;; const handleRejected = () =&gt; &#123; // 3.1 确保异步执行 this.asyncTask(() =&gt; &#123; try &#123; const x = onRejected(this.value); // 2.2.5 调用onRejected resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;; // 2.2.2 和 2.2.3 根据状态调用对应的回调 if (this.status === 'resolved') &#123; handleFulfilled(); &#125; else if (this.status === 'rejected') &#123; handleRejected(); &#125; else &#123; // 2.2.6 注册回调 this.onResolvedCallbacks.push(handleFulfilled); this.onRejectedCallbacks.push(handleRejected); &#125; &#125;); return promise2; &#125; catch(onRejected) &#123; // 2.2.3.2 实现catch方法 return this.then(null, onRejected); &#125; static resolve(value) &#123; // 如果是Promise直接返回 return value instanceof MyPromise ? value : new MyPromise(resolve =&gt; resolve(value)); &#125;&#125;// 2.3 Promise解决过程function resolvePromise(promise2, x, resolve, reject) &#123; // 2.3.1 防止循环引用 if (promise2 === x) &#123; reject(new TypeError('循环引用')); return; &#125; let called = false; // 2.3.3.3.3 确保只调用一次 // 2.3.3 如果x是对象或函数 if (x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123; try &#123; // 2.3.3.1 获取then方法 const then = x.then; if (typeof then === 'function') &#123; // 2.3.3.3 调用then方法 then.call( x, y =&gt; &#123; if (called) return; called = true; resolvePromise(promise2, y, resolve, reject); // 2.3.3.3.1 递归处理 &#125;, r =&gt; &#123; if (called) return; called = true; reject(r); // 2.3.3.3.2 处理reject &#125; ); &#125; else &#123; // 2.3.3.4 如果then不是函数，直接resolve resolve(x); &#125; &#125; catch (e) &#123; // 2.3.3.2 捕获异常 if (called) return; called = true; reject(e); &#125; &#125; else &#123; // 2.3.4 如果x不是对象或函数，直接resolve resolve(x); &#125;&#125;测试12345678910MyPromise.deferred = function () &#123; const obj = &#123;&#125;; obj.promise = new MyPromise(function (resolve, reject) &#123; obj.resolve = resolve; obj.reject = reject; &#125;); return obj;&#125;;保存MyPromise代码和上面代码创建 test.js 文件，并运行以下命令测试1npx promises-aplus-tests test.js可以看到MyPromise通过 872个测试 符合 Promise/A+ 规范了！","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://blog.langpz.com/tags/Promise/"}]},{"title":"git reset 和 git revert的区别","slug":"git-reset-和-git-revert的区别","date":"2024-11-24T12:27:37.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"git-reset-和-git-revert的区别.html","link":"","permalink":"http://blog.langpz.com/git-reset-和-git-revert的区别.html","excerpt":"git reset 和 git revert的区别在 Git 中，git reset 和 git revert 是两个常见且功能强大的命令。它们都可以撤销更改，但适用场景和操作方式截然不同。","text":"git reset 和 git revert的区别在 Git 中，git reset 和 git revert 是两个常见且功能强大的命令。它们都可以撤销更改，但适用场景和操作方式截然不同。git resetgit reset 用于移动当前分支的 HEAD 指针，并可以选择性地更改工作区和暂存区的状态。它主要用于“回滚到某个版本”，从历史记录中移除不需要的提交。常用参数–soft：仅回滚到指定版本，保留暂存区和工作区的更改。–mixed（默认）：回滚到指定版本，同时清空暂存区，但保留工作区更改。–hard：回滚到指定版本，并丢弃暂存区和工作区的更改。提交历史如下1A -&gt; B -&gt; C -&gt; D (HEAD)回滚到提交B1git reset --hard BC 和 D 会被彻底删除，工作区将恢复到 B 的状态。现在的提交历史会变成如下。1A -&gt; B (HEAD)如果使用 –soft1git reset --soft BC 和 D 的更改会保留在暂存区，待提交。注意事项破坏性操作：–hard 会直接丢弃更改，如果没分支或tag保存，有数据丢失的风险，需谨慎使用。本地历史调整：git reset 不会生成新的提交，只会修改现有提交的状态，通常仅在本地分支中使用。git revertgit revert 是一种更安全的撤销方法。它通过创建一个新的提交来反转指定提交的更改，而不会改变提交历史。这非常适合在协作开发中撤销错误操作。提交历史如下1A -&gt; B -&gt; C -&gt; D (HEAD)撤销提交C1git revert CGit 会生成一个新的提交 E，其内容与 C 的更改相反，撤销提交 C 带来的修改。1A -&gt; B -&gt; C -&gt; D -&gt; E (HEAD)提交 E = 提交 B 的内容 + 提交 C 的反向更改 + 提交 D 的更改。注意事项不可破坏性：git revert 不会修改历史记录，非常适合需要保留团队协作完整性的场景。可撤销性：如果你不小心 revert 了一个提交，还可以通过另一个 revert 恢复，git revert E。两者的主要区别特性git resetgit revert历史记录修改历史记录，移除指定提交保留历史记录，生成新的提交适用场景本地修改，调整错误提交团队协作，安全撤销已推送的提交破坏性可能丢失更改（尤其是 –hard）不会丢失任何更改是否生成新提交不会生成新的提交会生成新的提交","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"TypeScript-5.0装饰器","slug":"TypeScript-装饰器","date":"2024-10-19T16:08:53.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-装饰器.html","link":"","permalink":"http://blog.langpz.com/TypeScript-装饰器.html","excerpt":"装饰器TypeScript 装饰器是一种特殊的声明，可以附加到类声明、方法、属性或参数上。它允许开发者在不修改原有代码的情况下，对类和它的成员进行额外的功能。它就像是在代码的外面包了一层，使得代码可以有更多的功能，而不用重复写同样的逻辑。装饰器本质上是一个函数，在运行时被调用，并接受被装饰的元素作为参数。","text":"装饰器TypeScript 装饰器是一种特殊的声明，可以附加到类声明、方法、属性或参数上。它允许开发者在不修改原有代码的情况下，对类和它的成员进行额外的功能。它就像是在代码的外面包了一层，使得代码可以有更多的功能，而不用重复写同样的逻辑。装饰器本质上是一个函数，在运行时被调用，并接受被装饰的元素作为参数。在 TypeScript 5.0 中，将对全新的处于 stage3 阶段的装饰器提案提供支持。语法装饰器使用 @ 符号来表示，后面跟着一个表达式。这个表达式必须是一个函数。123456789function decorator(constructor: Function) &#123; console.log('decorator');&#125;@decoratorclass MyClass &#123; method() &#123;&#125;&#125;// 输出：decorator装饰器类型1234567891011type Decorator = (value: Input, context: &#123; kind: string; name: string | symbol; access: &#123; get?(): unknown; set?(value: unknown): void; &#125;; private?: boolean; static?: boolean; addInitializer(initializer: () =&gt; void): void;&#125;) =&gt; Output | void;装饰器函数有两个参数。运行时，JavaScript 引擎会提供这两个参数。value：所要装饰的值，某些情况下可能是undefined（装饰属性时）。context：上下文信息对象。装饰器函数的返回值，是一个新版本的装饰对象，但也可以不返回任何值（void）。上下文对象也会根据被修饰的值而变化。分解属性：kind：字符串，表示装饰类型，值有class、method、getter、setter、field、accessor。name：被装饰的值的名称: 或者在私有元素的情况下，对其的描述（例如可读名称）。access：对象，包含访问这个值的方法，即存值器和取值器。static: 布尔值，该值是否为静态元素。仅适用于类元素。private：布尔值，该值是否为私有元素。仅适用于类元素。addInitializer：函数，允许用户增加初始化逻辑。类装饰器类装饰器是用来装饰整个类的。它可以在类定义的时候加上一些额外的功能。例如我们想在每次创建类的时候记录日志，告诉我们类被创建了。1234567891011function LogClass(constructor: Function) &#123; console.log('类被创建了');&#125;@LogClassclass MyClass &#123; constructor() &#123; console.log('MyClass 实例创建'); &#125;&#125;// 输出：类被创建了这个例子中，每次创建 MyClass 的实例时，控制台都会打印 “类被创建了”。方法装饰器方法装饰器是用来装饰类里面的方法的。可以通过方法装饰器来修改方法的行为，例如在方法执行前后打印一些信息。1234567891011121314151617181920212223// 方法装饰器function LogMethod(target: any, context: ClassMethodDecoratorContext) &#123; const originalMethod = target; // target 就是当前被装饰的 class 方法 // 定义一个新方法 const decoratedMethod = function (this: unknown, ...args: unknown[]) &#123; console.log(`参数是：`, args); // 打印参数 const returnValue = originalMethod.call(this, ...args); // 调用原有方法 console.log('代码执行完了'); // 执行完后打印信息 return returnValue; &#125;; return decoratedMethod&#125;class MyClass &#123; @LogMethod greet(name: string) &#123; console.log(`Hello, $&#123;name&#125;!`); // 输出 Hello, lgpz! &#125;&#125;let m = new MyClass();m.greet('lgpz'); // 调用方法在这个例子中，每次调用 greet 方法时，控制台会先打印参数，然后再执行原来的逻辑，原有逻辑执行完再输出：代码执行完了。属性装饰器属性装饰器不直接修改属性值，但可以在属性定义时附加一些信息，比如做权限检查或设置默认值。12345678function LogProperty(target: any, context: DecoratorContext) &#123; console.log(`属性 $&#123;[context.name]&#125; 被定义`, context.name);&#125;class MyClass &#123; @LogProperty name: string = 'TypeScript';&#125;在这个例子中，定义 name 属性时，控制台会打印 “属性 name 被定义”。getter 装饰器，setter 装饰器getter 装饰器和 setter 装饰器，是分别针对类的取值器（getter）和存值器（setter）的装饰器。12345678910111213141516171819202122232425262728function logged(value: any, &#123; kind, name &#125;: ClassMemberDecoratorContext) &#123; if (kind === \"method\" || kind === \"getter\" || kind === \"setter\") &#123; return function (this: unknown, ...args: any[]) &#123; console.log(`开始 $&#123;[name]&#125; with arguments $&#123;args.join(\", \")&#125;`); const ret = value.call(this, ...args); console.log(`结束 $&#123;[name]&#125;`); return ret; &#125;; &#125; return&#125;class C &#123; private _name: string = ''; @logged set x(arg: any) &#123; this._name = arg &#125; @logged get x() &#123; return this._name &#125;&#125;let a = new C()a.x = 'langpz' // 输出： 开始 x with arguments langpz\" 结束 xconsole.log(a.x) // 输出：开始 x with arguments 结束 x langpz在这个例子中，get和set x 的时候都会打印开始和和结束。accessor 关键字类装饰器引入了一个关键字accessor（自动访问器），用来属性的前缀。自动访问器与常规字段不同，它在类原型上定义 getter 和 setter。此 getter 和 setter 默认用于在私有槽上获取和设置值。accessor关键字前面，还可以加上static关键字和private关键字。123class C &#123; accessor x = 1;&#125;它是一种简写形式，相当于声明属性x是私有属性#x的存取接口。上面的代码等同于下面的代码。1234567891011class C &#123; #x = 1; get x() &#123; return this.#x; &#125; set x(val) &#123; this.#x = val; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637function logged(value: any, &#123; kind, name &#125;: ClassMemberDecoratorContext) &#123; if (kind === \"accessor\") &#123; let &#123; get, set &#125; = value; return &#123; get() &#123; console.log(`getting $&#123;[name]&#125;`); return get.call(this); &#125;, set(val: any) &#123; console.log(`setting $&#123;[name]&#125; to $&#123;val&#125;`); return set.call(this, val); &#125;, init(initialValue:any) &#123; console.log(`initializing $&#123;[name]&#125; with value $&#123;initialValue&#125;`); return initialValue; &#125; &#125;; &#125; return&#125;class C &#123; @logged accessor x = '1';&#125;let c = new C();// initializing x with value '1'c.x;// getting xc.x = 'langpz';// setting x to langpz在这个例子中改写accessor属性的 getter 和 setter 方法。自动访问器初始化时以及每次访问时进行记录。addInitializer() 方法addInitializer方法可用于为每种类型的值提供给装饰器的上下文对象。可以调用此方法将初始化函数与类或类元素关联起来，该函数可用于在定义值后运行任意代码以完成设置。设置时机类装饰器：在类完全定义之后，并且类静态字段被分配之后。类静态元素方法和 Getter/Setter 装饰器：在类定义期间，在分配静态类方法之后，在初始化任何静态类字段之前。字段和访问器装饰器：在类定义期间，在应用它们的字段或访问器初始化之后立即初始化。类非静态元素方法和 Getter/Setter 装饰器：在类构造期间，在任何类字段初始化之前。字段和访问器装饰器：在类构造期间，在应用它们的字段或访问器初始化之后立即初始化。12345678910111213141516171819202122function bound(value: any, &#123; name, addInitializer &#125;:ClassMethodDecoratorContext) &#123; addInitializer(function (this: any) &#123; this[name] = this[name].bind(this); &#125;);&#125;class C &#123; message = \"hello!\"; @bound m() &#123; console.log(this.message); &#125; c() &#123; console.log(this.message); &#125;&#125;let &#123; m, c &#125; = new C();m(); // hello!在这个例子中addInitializer方法装饰器实现了@bound装饰器，将方法this绑定到类。参考ts5.0装饰器","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"装饰器","slug":"装饰器","permalink":"http://blog.langpz.com/tags/装饰器/"}]},{"title":"TypeScript-声明文件","slug":"TypeScript-声明文件","date":"2024-09-07T10:16:01.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-声明文件.html","link":"","permalink":"http://blog.langpz.com/TypeScript-声明文件.html","excerpt":"声明文件TypeScript 声明文件（.d.ts）是用来描述 JavaScript 库或模块的类型信息的文件。它告诉 TypeScript 编译器，这些库或模块中的变量、函数、类等具有什么样的类型，从而使我们在使用这些库时能够获得类型检查和代码补全等功能，提高开发效率和代码质量。","text":"声明文件TypeScript 声明文件（.d.ts）是用来描述 JavaScript 库或模块的类型信息的文件。它告诉 TypeScript 编译器，这些库或模块中的变量、函数、类等具有什么样的类型，从而使我们在使用这些库时能够获得类型检查和代码补全等功能，提高开发效率和代码质量。创建声明文件的场景声明文件通常用于以下场景：JavaScript 库没有内置的类型定义：比如老旧的 JavaScript 库或者一些专用的小型库没有提供 .d.ts 文件，这时你可以手动创建一个声明文件来为该库添加类型支持。当需要编写自己的 JavaScript 库或模块时，需要定义其类型信息以便其他开发者能够更好地使用它。为第三方库添加类型：有些库可能已经在 DefinitelyTyped 上有类型定义，但你可能需要根据项目需求进行扩展或修改。声明全局变量全局变量的声明123declare const _: &#123; map&lt;T&gt;(arr: T[], fn: (item: T) =&gt; any): T[];&#125;;声明了一个全局变量 _，它是一个对象，其中有一个名为 map 的方法。函数的声明1declare function lanpz(name: string): void;声明了一个名为 lanpz 的函数，接受一个 string 类型的参数，并且不返回任何值（void）。类的声明1234declare class Person &#123; constructor(name: string, age: number); greet(): string;&#125;声明了一个 Person 类，带有构造函数和一个方法。模块的声明123declare module \"lodash\" &#123; export function map&lt;T&gt;(arr: T[], fn: (item: T) =&gt; any): T[];&#125;声明了一个 lodash 模块，其中包含一个 map 函数。全局变量的声明12345declare global &#123; interface Window &#123; name: string; &#125;&#125;Window 接口添加了一个名为 name 的属性，并且将其类型定义为 string。TypeScript 在任何地方引用 window.name 时都会认为它是一个 string 类型的值。还可以使用 declare namespace 来声明一个命名空间; declare enum 来声明一个枚举类型; declare interface 来声明一个接口; declare type 来声明一个类型别名等。编写第三方声明文件假设我们有一个名为 langpz-lib 的第三方库，它导出了一个对象，里面包含几个方法和属性：123456789101112// langpz-lib.jsmodule.exports = &#123; name: \"LangpzLib\", version: \"1.0.0\", hello: function () &#123; console.log(\"Hello, LangpzLib!\"); &#125;, config: &#123; setting1: true, setting2: \"default\" &#125;&#125;;TypeScript 声明文件示例1234567891011121314// langpz-lib.d.tsdeclare module \"langpz-lib\" &#123; export const name: string; export const version: string; export function hello(): void; export interface Config &#123; setting1: boolean; setting2: string; &#125; export const config: Config;&#125;declare module 一般用于定义 CommonJS 模块或其他非 ES6 模块系统中的模块。使用第三方 @types 包在很多情况下，你不需要手动编写声明文件，因为大部分流行的 JavaScript 库都已经由社区编写好了类型定义文件，并发布到了 DefinitelyTyped 仓库中。你可以通过 npm 安装这些声明文件，通常以 @types 前缀命名。1npm install @types/lodash -D当使用lodash时默认会查找 node_modules/@types/lodash/index.d.ts 文件，无需手动配置。TypeScript 将自动引用这些类型声明文件。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"声明文件","slug":"声明文件","permalink":"http://blog.langpz.com/tags/声明文件/"}]},{"title":"TypeScript-模块和命名空间","slug":"TypeScript-模块和命名空间","date":"2024-08-17T15:29:04.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-模块和命名空间.html","link":"","permalink":"http://blog.langpz.com/TypeScript-模块和命名空间.html","excerpt":"模块和命名空间TypeScript 提供了两种主要的代码组织方式：模块（Modules）和命名空间（Namespaces）。它们都用于组织和管理代码，但有不同的用途和特性。","text":"模块和命名空间TypeScript 提供了两种主要的代码组织方式：模块（Modules）和命名空间（Namespaces）。它们都用于组织和管理代码，但有不同的用途和特性。模块（Modules）在 TypeScript 中，可以通过 export 关键字来导出模块中的变量、函数、类和接口。导出的元素可以在其他模块中通过 import 关键字进行导入。每个模块都拥有自己的作用域，不会与其他模块中的变量冲突。导出和导入1234567// math.ts导出export function add(x: number, y: number): number &#123; return x + y;&#125;// index.ts导入import &#123; add &#125; from './math.ts'默认导出12345// a.ts导出export default 'langpz'// index.ts导入import name from './a'默认导出可以使用 default 关键字。默认导出的项在导入时不需要使用大括号 {}。重命名导入和导出在导入和导出时，可以对名称进行重命名，以避免命名冲突或使名称更加语义化。12345678910111213141516// math.ts导出export function add(x: number, y: number): number &#123; return x + y;&#125;export function subtract(x: number, y: number): number &#123; return x - y;&#125;export &#123; add as sum, subtract as difference &#125;;// index.ts导入import &#123; sum, difference &#125; from './math';console.log(sum(5, 3)); // 输出: 8console.log(difference(5, 3)); // 输出: 2命名空间（Namespaces）命名空间是 TypeScript 提供的一种将代码分组的方式，适用于将代码组织在一个全局范围内。命名空间通过 namespace 关键字定义，通常用于在一个全局作用域中定义库或框架。使用命名空间12345678910111213namespace Utils &#123; export function log(message: string): void &#123; console.log(message); &#125; export function error(message: string): void &#123; console.error(message); &#125;&#125;// 使用命名空间中的函数Utils.log('lanpz'); // 输出:lanpzUtils.error('https://blog.langpz.com'); // 输出:https://blog.langpz.com命名空间嵌套使用12345678910111213namespace zoo &#123; export class Dog &#123; eat() &#123; console.log('zoo dog'); &#125; &#125; export namespace bear &#123; export const name = '熊'; &#125;&#125;console.log(zoo.bear.name); // 输出: 熊合并命名空间TypeScript 允许合并同名的命名空间，这在定义复杂库或框架时非常有用。123456789101112131415namespace Library &#123; export function init(): void &#123; console.log('Library initialized'); &#125;&#125;namespace Library &#123; export function shutdown(): void &#123; console.log('Library shut down'); &#125;&#125;// 使用合并后的命名空间Library.init(); // 输出: Library initializedLibrary.shutdown(); // 输出: Library shut down模块（Modules） VS 命名空间（Namespaces）特性模块（Modules）命名空间（Namespaces）作用域独立作用域，避免命名冲突全局作用域，可能导致命名冲突依赖管理通过导入和导出管理模块依赖无法管理依赖，全部在全局可见代码重用易于在不同项目中重用重用性较差，需要手动包含文件动态加载支持动态加载，提高性能不支持动态加载，不适用于大型应用兼容性与 ECMAScript 标准兼容非 ECMAScript 标准，现代项目不推荐使用学习曲线较为复杂，需要学习和配置简单易用，适合快速开发适用场景适用于大型项目和现代应用适用于小型项目和库开发","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"模块， 命名空间","slug":"模块，-命名空间","permalink":"http://blog.langpz.com/tags/模块，-命名空间/"}]},{"title":"TypeScript-unknown类型","slug":"TypeScript-unknown类型","date":"2024-07-20T10:42:30.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-unknown类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-unknown类型.html","excerpt":"unknown类型unknown 类型是 TypeScript 3.0 引入的一种类型，用于表示未知类型。与 any 类型类似，它可以赋值给任何类型的变量，但与 any 不同的是，unknown 类型更安全，因为它强制在使用之前进行类型检查。","text":"unknown类型unknown 类型是 TypeScript 3.0 引入的一种类型，用于表示未知类型。与 any 类型类似，它可以赋值给任何类型的变量，但与 any 不同的是，unknown 类型更安全，因为它强制在使用之前进行类型检查。unknown12345678let x:unknown;x = true; // 正确x = 42; // 正确x = 'langpz'; // 正确x.length // 报错let bolg:unknown = &#123; name: 'langpz' &#125;;bolg.name // 报错unknown类型跟any类型的不同之处在于，不能直接访问unknown类型上的属性和方法，不能作为函数、类来使用联合类型中的unknown1type UnionUnknown = unknown | null | string | number;联合类型与unknown都是unknown类型。交叉类型中的unknown1type UnionUnknown = unknown &amp; null交叉类型与unknown都是其他类型, 如上类型就是null类型。使用unknown 类型的上的属性和方法在使用 unknown 类型的值之前，必须先进行类型检查或类型断言，以确保类型安全。这样做的目的是防止运行时错误和确保代码的类型安全。12345678let value: unknown;// 使用typeof进行类型检查if (typeof value === \"string\") &#123; console.log(value.length); // 现在TypeScript知道value是一个string&#125; else if (typeof value === \"number\") &#123; console.log(value.toFixed(2)); // 现在TypeScript知道value是一个number&#125;unknown 类型的优势类型安全：unknown 类型强制在使用之前进行类型检查或类型断言，确保类型安全。避免类型错误：使用 unknown 类型可以避免运行时类型错误。增强代码可读性：通过显式的类型检查，可以提高代码的可读性和可维护性。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"unknown","slug":"unknown","permalink":"http://blog.langpz.com/tags/unknown/"}]},{"title":"TypeScript-条件类型","slug":"TypeScript-条件类型","date":"2024-06-23T17:05:18.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-条件类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-条件类型.html","excerpt":"条件类型条件类型是 TypeScript 提供的一种基于条件的类型选择机制，可以根据类型的真假条件来进行类型推导和分配。这种功能使得 TypeScript 更加灵活和强大，能够处理复杂的类型逻辑。例如 A extends B ? C : D 。","text":"条件类型条件类型是 TypeScript 提供的一种基于条件的类型选择机制，可以根据类型的真假条件来进行类型推导和分配。这种功能使得 TypeScript 更加灵活和强大，能够处理复杂的类型逻辑。例如 A extends B ? C : D 。条件类型基本使用可以使用extends关键字和三元表达式，实现条件判断。1A extends B ? C : DA extends B 是条件表达式，如果 A 能够赋值给 B（即 A 是 B 的子类型），那么结果类型就是 C，否则就是 B。案例1234type IsNumber&lt;T&gt; = T extends number ? true : false;type B = IsNumber&lt;number&gt;; // truetype A = IsNumber&lt;string&gt;; // falseIsNumber 是一个条件类型，它检查给定的类型 T 是否是 number 类型。如果是 number，则结果类型为 true，否则为 false。条件类型分发当条件类型作用于联合类型时，TypeScript 会对联合类型中的每一个成员单独进行条件类型的检查和分发。这意味着条件类型在联合类型上会进行分配和计算，而不是直接应用于整个联合类型。12type Example&lt;T&gt; = T extends string ? 'string' : 'not string';type Result = Example&lt;string | number&gt;; // 'string' | 'not string'Result 的类型是 ‘string’ | ‘not string’，因为 Example 类型应用于 string 和 number 时，分别得到了 ‘string’ 和 ‘not string’。这里会用每一项依次进行分发，最终采用联合类型作为结果，等价如下。123type c1 = Example&lt;string&gt;;type c2 = Example&lt;number&gt;;type c = c1 | c2infer类型推断infer 关键字用于在条件类型中引入类型推断。它允许从上下文中推断出某个类型，而无需显式指定。这种特性对于处理复杂的类型转换和推断非常有用。MyReturnType 返回值类型1234567type MyReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;function getUser() &#123; return &#123; a: 1, name: \"lanpz\" &#125;;&#125;type ExampleReturnType = MyReturnType&lt;typeof getUser&gt;; // &#123; a: number, name: string &#125;MyInstanceType 实例类型12345class Person &#123; constructor(name: string, age: number) &#123; &#125;&#125;type MyInstanceType&lt;T&gt; = T extends &#123; new(...args: any): infer R &#125; ? R : anytype MyInstance = MyInstanceType&lt;typeof Person&gt;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"条件类型","slug":"条件类型","permalink":"http://blog.langpz.com/tags/条件类型/"}]},{"title":"TypeScript-类型保护","slug":"TypeScript-类型保护","date":"2024-05-25T12:48:08.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-类型保护.html","link":"","permalink":"http://blog.langpz.com/TypeScript-类型保护.html","excerpt":"类型保护在 TypeScript 中，类型保护（Type Guards）通过在运行时检查变量的类型，可以在特定的代码块中自动识别变量的属性和方法，从而确保代码的类型安全，提示并规避不合法的操作。","text":"类型保护在 TypeScript 中，类型保护（Type Guards）通过在运行时检查变量的类型，可以在特定的代码块中自动识别变量的属性和方法，从而确保代码的类型安全，提示并规避不合法的操作。typeof类型保护typeof 操作符可以用来判断基本类型，如 string、number 等。1234567891011function langpz(value: string | number) &#123; value.toFixed(2) // 报错 类型“string”上不存在属性“toFixed” if (typeof value === 'string') &#123; console.log(value.toUpperCase()); // value 被识别为 string &#125; else if (typeof value === 'number') &#123; console.log(value.toFixed(2)); // value 被识别为 number &#125;&#125;langpz(\"hello\"); // 输出: \"HELLO\"langpz(123.456); // 输出: \"123.46\"通过 typeof 操作符，我们可以对变量进行识别类型，避免调用字符串或者数字方法报错。instanceof类型保护123456789101112131415161718192021222324class Cat &#123; miao() &#123; console.log(\"喵喵\"); &#125;&#125;class Dog &#123; wang() &#123; console.log(\"汪汪\"); &#125; &#125;const speak: (animal: Cat | Dog) =&gt; void = (animal) =&gt; &#123; if (animal instanceof Dog) &#123; animal.wang(); // animal 被识别为 Dog &#125; else if (animal instanceof Cat) &#123; animal.miao(); // animal 被识别为 Cat &#125;&#125;const dog = new Dog();const cat = new Cat();speak(dog); // 输出: \"汪汪!\"speak(cat); // 输出: \"喵喵!\"instanceof 检查使得 TypeScript 能够在不同的代码块中识别 animal 是 Dog 还是 Cat 的实例，并调用相应的方法。in类型保护in 操作符用于检查对象上是否存在某个属性。它适用于检查具有不同属性的联合类型。1234567891011121314151617interface Fish &#123; swim(): void;&#125;interface Bird &#123; fly(): void;&#125;function getType(animal: Fish | Bird) &#123; if ('swim' in animal) &#123; animal.swim(); // animal 被识别为 Fish &#125; else &#123; animal.fly(); // animal 被识别为 Bird &#125;&#125;const fish: Fish = &#123; swim: () =&gt; console.log(\"Swimming\") &#125;;const bird: Bird = &#123; fly: () =&gt; console.log(\"Flying\") &#125;;getType(fish); // 输出: \"Swimming\"getType(bird); // 输出: \"Flying\"自定义类型保护自定义类型保护通常是一个函数，它接受一个参数，并返回一个类型谓词，即一个表达式，其结果为布尔值，用于确定参数是否属于某个特定的类型。12345678910111213141516171819202122interface Fish &#123; swim(): void;&#125;interface Bird &#123; fly(): void;&#125;function isBird(animal: Fish | Bird):animal is Bird &#123; return 'fly' in animal&#125;function getAniaml (animal:Fish | Bird)&#123; if(isBird(animal))&#123; animal.fly(); // animal 被识别为 Bird &#125;else&#123; animal.swim(); // animal 被识别为 Fish &#125;&#125;const fish: Fish = &#123; swim: () =&gt; console.log(\"Swimming\") &#125;;const bird: Bird = &#123; fly: () =&gt; console.log(\"Flying\") &#125;;getAniaml(fish); // 输出: \"Swimming\"getAniaml(bird); // 输出: \"Flying\"自定义类型保护函数 isBird 通过检查 fly 方法是否存在来识别 animal 是否为 Bird 类型。可辨识联合类型可辨识联合类型是一种特殊的联合类型，它允许我们根据某个字段（通常称为“标签”或“可辨识字段”）的值来区分不同的类型。12345678910111213141516171819202122232425262728293031interface Fish &#123; kind: \"fish\"; swim(): void;&#125;interface Bird &#123; kind: \"bird\"; fly(): void;&#125;type Animal = Fish | Bird;function makeSound(animal: Animal) &#123; switch (animal.kind) &#123; case \"fish\": animal.swim(); // 在这里，animal 被识别为 Fish 类型 break; case \"bird\": animal.fly(); // 在这里，animal 被识别为 Bird 类型 break; default: // 这是一个类型永远不会到达的分支，但可以为了完整性而保留 throw new Error(\"Unknown animal kind\"); &#125;&#125;const myFish: Fish = &#123; kind: \"fish\", swim: () =&gt; console.log(\"langpz fish\") &#125;;const myBird: Bird = &#123; kind: \"bird\", fly: () =&gt; console.log(\"langpz bird\") &#125;;makeSound(myFish); // 输出: \"langpz fish\"makeSound(myBird); // 输出: \"langpz bird\"","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"类型保护","slug":"类型保护","permalink":"http://blog.langpz.com/tags/类型保护/"}]},{"title":"TypeScript-交叉类型","slug":"TypeScript-交叉类型","date":"2024-04-27T10:20:57.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-交叉类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-交叉类型.html","excerpt":"交叉类型在 TypeScript 中，交叉类型（Intersection Types）是一种非常有用的类型操作符，它允许我们将多个类型合并为一个新的类型。","text":"交叉类型在 TypeScript 中，交叉类型（Intersection Types）是一种非常有用的类型操作符，它允许我们将多个类型合并为一个新的类型。合并对象属性： 当你需要将多个对象的属性合并成一个新对象时，可以使用交叉类型。这在实现对象组合时非常有用。12345type Name = &#123; name: string; &#125;;type Age = &#123; age: number; &#125;;type Person = Name &amp; Age;let lanpz: Person = &#123; name: 'langpz', age: '18' &#125;在上面的示例中，我们定义了两个类型 Name 和 Age，然后使用 &amp; 符号将它们合并为一个新的类型 Person Person 类型具有 Name 和 Age 类型的所有属性。lanpz函数参数： 当你需要定义一个函数，其参数具有多种类型的属性时，可以使用交叉类型。1234function mixin&lt;T, K&gt;(a: T, b: K): T &amp; K &#123; return &#123; ...a, ...b &#125;&#125;const lan = mixin(&#123; name: 'langpz' &#125;, &#123; address: 'https://blog.langpz.com/' &#125;)","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"交叉类型","slug":"交叉类型","permalink":"http://blog.langpz.com/tags/交叉类型/"}]},{"title":"TypeScript-联合类型","slug":"TypeScript-联合类型","date":"2024-03-22T20:11:51.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-联合类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-联合类型.html","excerpt":"联合类型联合类型是 TypeScript 中的一个高级类型，允许一个变量是几种类型之一。你可以使用管道符（|）来定义一个联合类型，这告诉 TypeScript，该变量可以存储管道符两侧任何一种类型的值。例如，string | number 类型的变量可以接受字符串或数字。","text":"联合类型联合类型是 TypeScript 中的一个高级类型，允许一个变量是几种类型之一。你可以使用管道符（|）来定义一个联合类型，这告诉 TypeScript，该变量可以存储管道符两侧任何一种类型的值。例如，string | number 类型的变量可以接受字符串或数字。用法1234567let langpz:string | number; // 联合类型 console.log(langpz!.toString()); // 公共方法langpz = 10;console.log(langpz!.toFixed(2)); // number方法langpz = 'lan';console.log(langpz!.toLowerCase()); // 字符串方法langpz = true // error Type 'boolean' is not assignable to type 'string | number'在这个例子中，langpz 被定义为可以是 string 或 number 类型。给它赋值字符串或数字都是允许的，但如果尝试赋值其他类型的值，TypeScript 编译器将会报错。使用场景联合类型在很多情况下都非常有用，特别是在处理多种输入类型但又不想失去类型安全性的情况下。一些常见的使用场景包括：函数参数：当你希望一个函数能接受不同类型的参数时。返回类型：当一个函数可能返回多种类型的值时。数组和其他集合：当数组或其他数据结构中可能包含多种类型的元素时。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"联合类型","slug":"联合类型","permalink":"http://blog.langpz.com/tags/联合类型/"}]},{"title":"TypeScript-泛型","slug":"TypeScript-泛型","date":"2024-02-25T14:27:17.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-泛型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-泛型.html","excerpt":"什么是泛型？泛型是一种参数化类型的概念，允许我们在定义函数、类、接口等时使用类型变量来表示未知的具体类型。通过泛型，我们可以编写出更通用的代码，从而提高代码的复用性和可读性。在 TypeScript 中，泛型以的形式表示，其中 T 可以是任何标识符，常用于表示类型参数。","text":"什么是泛型？泛型是一种参数化类型的概念，允许我们在定义函数、类、接口等时使用类型变量来表示未知的具体类型。通过泛型，我们可以编写出更通用的代码，从而提高代码的复用性和可读性。在 TypeScript 中，泛型以的形式表示，其中 T 可以是任何标识符，常用于表示类型参数。泛型函数123456789function getArg&lt;T&gt;(arg: T): T &#123; return arg;&#125;let output = getArg&lt;string&gt;(\"langpz\");console.log(output); // 输出：langpzlet output2 = getArg&lt;number&gt;(1);console.log(output2); // 输出：1getArg 函数接受一个参数 arg，并返回相同的参数。通过，使函数 getArg 成为了一个泛型函数，可以接受任意类型的参数，并返回相同类型的值。泛型类泛型类使用（&lt;&gt;）括起泛型类型，跟在类名后面。123456class Info&lt;T, U&gt; &#123; // 这里的 T 和 U 是使用接口的时候传入 constructor(public name: T, public age: U) &#123;&#125;&#125;let langpz = new Info&lt;string, number&gt;(\"langpz\", 1);console.log(langpz.name); // 输出：langpz注：类的静态属性不能引用泛型类型。泛型约束有时候，我们希望泛型参数具有某些特定的属性或方法。可以使用泛型约束来实现。如果不约束会ts会直接报错属性或方法不存在。1234567891011interface Lengthwise &#123; length: number;&#125;function getArg&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length) return arg;&#125;let output = getArg&lt;string&gt;(\"langpz\");console.log(output); // 输出：langpzlet output2 = getArg&lt;number&gt;(1); // 报错 Type 'number' does not satisfy the constraint 'Lengthwise'使用了 extends 关键字来约束泛型 T 必须满足 Lengthwise 接口的要求，传入的参数必须包含必须 length 的属性。默认泛型1234type NameType&lt;T = string&gt; = &#123; name: T;&#125;;let name1:NameType = &#123;name:'langpz'&#125;可以通过在泛型 T 参数后面加上 = 符号和默认值来实现。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"泛型","slug":"泛型","permalink":"http://blog.langpz.com/tags/泛型/"}]},{"title":"解决github拉取推送代码报错:ssh: connect to host github.com port 22: Connection timed out","slug":"解决github拉取推送代码报错-ssh-connect-to-host-github-com-port-22-Connection-timed-out","date":"2024-01-20T18:49:52.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"解决github拉取推送代码报错-ssh-connect-to-host-github-com-port-22-Connection-timed-out.html","link":"","permalink":"http://blog.langpz.com/解决github拉取推送代码报错-ssh-connect-to-host-github-com-port-22-Connection-timed-out.html","excerpt":"github拉代码报错ssh: connect to host github.com port 22: Connection timed out","text":"github拉代码报错ssh: connect to host github.com port 22: Connection timed outWindows 找到用户/.ssh/config 文件macOS ~/.ssh/config没有config文件就创建一个123Host github.com Hostname ssh.github.com Port 443重新拉取或提交代码，就可以正常使用了。","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://blog.langpz.com/tags/github/"}]},{"title":"TypeScript-接口","slug":"TypeScript-接口","date":"2024-01-20T17:24:42.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-接口.html","link":"","permalink":"http://blog.langpz.com/TypeScript-接口.html","excerpt":"接口接口（Interfaces）是 TypeScript 中强大而灵活的特性之一。接口用于定义代码结构，使得代码更易读、易维护，同时提供了一种强大的方式来描述对象的形状。(接口中不能含有具体的实现逻辑)","text":"接口接口（Interfaces）是 TypeScript 中强大而灵活的特性之一。接口用于定义代码结构，使得代码更易读、易维护，同时提供了一种强大的方式来描述对象的形状。(接口中不能含有具体的实现逻辑)函数接口参数12345678910interface LabelledValue &#123; label: string;&#125;function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;label: \"Size 10 Object\"&#125;;printLabel(myObj); //输出: Size 10 Object函数类型接口12345678910interface IFullName &#123; firstName:string, lastName:string&#125;interface IFn &#123; (obj:IFullName):string&#125;const fullName:IFn = (&#123;firstName,lastName&#125;)=&gt;&#123; return firstName + lastName&#125;通过接口限制函数的参数类型和返回值类型函数混合类型12345678910111213interface ICounter &#123; (): number; // 限制函数类型 count: 0 // 限制函数上的属性&#125;let fn: any = () =&gt; &#123; fn.count++; return fn.count;&#125;fn.count = 0;let counter:ICounter = fn;counter.xx = 0; // 输出: Property 'xx' does not exist on type 'ICounter'. ICounter上没有xx 属性console.log(counter()); // 输出: 1console.log(counter()); // 输出: 2对象接口、可选属性、只读属性1234567891011121314interface Iinfo&#123; age?:number, // 可选属性 name:'lanpz'|'langpz', readonly gender: string // 只读属性&#125;interface Iinfo&#123; size: string&#125;const info:Iinfo = &#123; name: 'lanpz', gender: '男', size: '1'&#125;?标识的属性为可选属性readonly标识的属性则不能修改多个同名的接口会自动合并可索引接口接口还支持可索引的成员，使我们能够通过索引访问对象的属性。12345678910interface StringArray &#123; readonly [index: number]: string;&#125;const myArray: StringArray = [\"a\", \"b\", \"c\"];let obj: StringArray = &#123; 0:'1',1:'2',3:'3'&#125;console.log(obj[0]); // 输出: \"1\"console.log(myArray[0]); // 输出: \"a\"任意属性123456789101112131415interface MyObject &#123; [key: string]: any;&#125;const myObj: MyObject = &#123; name: \"John\", age: 25, job: \"Engineer\"&#125;;interface MyArray &#123; [index: number]: string;&#125;const arr: MyArray = ['lanpz', 'aaa'];类接口接口中不能含有具体的实现逻辑123456789101112interface Speakable &#123; name:string; speak():void;&#125;interface ChineseSpeakable&#123; speakChinese():void&#125;class Speak implements Speakable,ChineseSpeakable&#123; name!:string speak()&#123;&#125; speakChinese()&#123;&#125;&#125;接口继承接口的继承使用 extends 关键字。接口之间的（继承）允许你创建一个新的接口，该接口包含了另一个或多个已存在接口的属性和方法。123456789101112interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;const square: Square = &#123; color: \"red\", sideLength: 10&#125;;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"接口","slug":"接口","permalink":"http://blog.langpz.com/tags/接口/"}]},{"title":"TypeScript-类","slug":"TypeScript-类","date":"2023-12-09T17:47:18.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-类.html","link":"","permalink":"http://blog.langpz.com/TypeScript-类.html","excerpt":"类es5及以前，JavaScript 通过构造函数实现类的概念，通过原型链实现继承来创建可重用的组件。而在 ES6 中，可以使用 class。基于类的面向对象的方式。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法如（public，readonly）。","text":"类es5及以前，JavaScript 通过构造函数实现类的概念，通过原型链实现继承来创建可重用的组件。而在 ES6 中，可以使用 class。基于类的面向对象的方式。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法如（public，readonly）。TS中使用类12345678910111213141516class Pointer&#123; x!:number; // 实例上的属性必须先声明 y!:number; constructor(x:number,y?:number,...args:number[])&#123; this.x = x; this.y = y as number; &#125;&#125;class SumPointer extends Pointer &#123; log():void &#123; console.log(\"x+y: \"+ (this.x + this.y)) &#125; &#125;let p1 = new SumPointer(100,200);p1.log() // 打印300实例上的属性需要先声明在使用，构造函数中的参数可以使用可选参数和剩余参数。类的修饰符（public、private、protected等）在 TypeScript 中，我们可以使用修饰符来限制对类的属性和方法的访问。public修饰符（谁都可以访问到）默认为 public1234567891011121314class Pointer&#123; public x:number; // 不写修饰符默认为 public public constructor(x:number)&#123; this.x = x; &#125;&#125;class SumPointer extends Pointer &#123; constructor(x:number)&#123; super(x) console.log(this.x) // 子类访问 &#125; &#125;let p1 = new SumPointer(100);protected修饰符 (自己和子类可以访问到)123456789101112131415class Pointer&#123; protected x:number; constructor(x:number)&#123; this.x = x; &#125;&#125;class SumPointer extends Pointer &#123; constructor(x:number)&#123; super(x) console.log(this.x) // 子类访问 &#125; &#125;let p1 = new SumPointer(100);console.log(p1.x) // // 无法访问 ts会提示报错private修饰符 （除了自己都访问不到）12345678910111213141516class Pointer&#123; private x:number; constructor(x:number)&#123; this.x = x; console.log(this.x) // 自己可以访问到 &#125;&#125;class SumPointer extends Pointer &#123; constructor(x:number)&#123; super(x) console.log(this.x) // 子类无法访问 &#125; &#125;let p1 = new SumPointer(100);console.log(p1.x) // 无法访问readonly修饰符 （只读修饰符）1234567class Pointer&#123; constructor(readonly x:number)&#123; this.x = x; // 只读属性只能在constructor中被赋值 &#125;&#125;let p1 = new Pointer(100);p1.x = 1 // 错误! x 是只读的.静态属性和方法1234567class Pointer&#123; static x:number = 10; // 静态属性 static getNumber() &#123; return 100 &#125;&#125;console.log(Pointer.x, Pointer.getNumber()) // 10, 100静态属性和方法可以不用实例化，直接通过类就可以调用，并且静态属性和静态方法是可以被子类所继承的。抽象类抽象类就是供其它类继承的一个基础类。抽象类是不允许被实例化的、只能被继承，抽象方法不能在抽象类中实现，只能在抽象类的具体子类中实现,而且必须实现。123456789101112131415abstract class Animal&#123; name!:string; abstract speak():void&#125;class Cat extends Animal &#123; speak()&#123; console.log('喵喵喵'); &#125;&#125;class Dog extends Animal&#123; speak():string&#123; console.log('汪汪汪'); return 'wangwang' &#125;&#125;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"类","slug":"类","permalink":"http://blog.langpz.com/tags/类/"}]},{"title":"TypeScript-函数类型","slug":"TypeScript-函数类型","date":"2023-11-11T15:50:07.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-函数类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-函数类型.html","excerpt":"函数类型在 TypeScript 中，函数不仅是代码结构的组成部分，还是类型系统的核心。通过函数类型，我们能够更清晰地定义函数的输入和输出，并让 TypeScript 编译器在编译时进行更强大的类型检查。","text":"函数类型在 TypeScript 中，函数不仅是代码结构的组成部分，还是类型系统的核心。通过函数类型，我们能够更清晰地定义函数的输入和输出，并让 TypeScript 编译器在编译时进行更强大的类型检查。函数的两种声明方式通过function关键字来进行声明1234function add(a: number, b: number):number &#123; return a + b;&#125;add(1, 2)通过表达式方式声明12345type Add = (x: number, b1: number) =&gt; number;let add: Add = (x, y) =&gt; &#123; return x + y&#125;;add(1, 2)可以用来限制函数的参数和返回值类型，上面的例子声明了一个名为 add 的函数，该函数接收两个参数 x 和 y，它们的类型分别为 number，并且函数返回值的类型也被指定为 number。可选参数在函数参数中，有时候我们希望某个参数是可选的（非必传）。可以使用 ? 表示可选参数。1234let sum = (a: string, b?: string):string =&gt; &#123; return a + b;&#125;;sum('langpz');可选参数必须在其他参数的最后面。默认参数在函数参数中，有时候我们希望希望给参数设置一个默认值。可以使用 = 表示默认参数。1234let sum = (a: string, b: string = '.com'):string =&gt; &#123; return a + b;&#125;;sum('langpz');默认参数不能同时和可选参数使用。剩余参数有时我们希望一个函数可以接受任意数量的参数。可以使用 … 表示剩余参数。12345function sum(...numbers: number[]): number &#123; return numbers.reduce((acc, val) =&gt; acc + val, 0);&#125;const result = sum(1, 2, 3, 4); // 10函数重载TypeScript 允许我们为同一个函数提供多个类型定义，称之为函数重载。你可以在不同的情况下为函数提供不同的输入和输出类型定义，让编译器能够更精确地推断和检查函数调用。1234567891011function toArray(value: number): number[]function toArray(value: string): string[]function toArray(value: number | string) &#123; if (typeof value === 'string') &#123; return value.split(''); &#125; else &#123; return value.toString().split('').map(item =&gt; Number(item)); &#125;&#125;toArray(123); // [1, 2, 3] toArray('123'); // [\"1\", \"2\", \"3\"]根据传入不同类型的数据 返回不同的结果。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"函数类型","slug":"函数类型","permalink":"http://blog.langpz.com/tags/函数类型/"}]},{"title":"TypeScript-基础类型","slug":"TypeScript-基础类型","date":"2023-10-14T10:00:09.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript-基础类型.html","link":"","permalink":"http://blog.langpz.com/TypeScript-基础类型.html","excerpt":"基础类型TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举等类型方便我们使用。TS中冒号后面的都为类型标识。","text":"基础类型TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举等类型方便我们使用。TS中冒号后面的都为类型标识。布尔值1let bool:boolean = true;数字和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744;字符串1let str:string = 'hello langpz';数组声明数组中元素数据类型1234let arr1:number[] = [1,2,3];let arr2:string[] = ['1','2','3'];let arr3:(number|string)[] = [1,'2',3]; // 联合类型 let arr4:Array&lt;number | string&gt; = [1,'2',3]; // 泛型方式来声明元组类型元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。123let tuple:[string, boolean] = ['langpz',true];// 像元组中增加数据，只能增加元组中存放的类型tuple.push(1); // 会报错 Argument of type '1' is not assignable to parameter of type 'string | boolean'null 和 undefined任何类型的子类型,如果strictNullChecks的值为true，则不能把null 和 undefined付给其他类型。12let name:number | boolean;name = null;void类型只能接受null，undefined。一般用于函数的返回值。严格模式下不能将null赋予给void。12let a:void;a = undefined;any类型不进行类型检测，可以任意赋值。12let s:any = 'langpz's = 10枚举类型123456enum USER_ROLE &#123; USER, // 默认从0开始 ADMIN, MANAGER&#125;// &#123;\"0\": \"USER\", \"1\": \"ADMIN\", \"2\": \"MANAGER\", \"USER\": 0, \"ADMIN\": 1, \"MANAGER\": 2&#125;默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。123456enum USER_ROLE &#123; USER = 'langpz', ADMIN = 1, MANAGER,&#125;// &#123;\"1\": \"ADMIN\", \"2\": \"MANAGER\", \"USER\": \"langpz\", \"ADMIN\": 1, \"MANAGER\": 2&#125;never类型任何类型的子类型,never代表永不存在的值。不能把其他类型赋值给never。123456789101112131415function error(message: string): never &#123; throw new Error(\"err\");&#125;function loop(): never &#123; while (true) &#123; &#125;&#125;function fn(x:number | string)&#123; if(typeof x == 'number')&#123; &#125;else if(typeof x === 'string')&#123; &#125;else&#123; console.log(x); // never &#125;&#125;Symbol类型Symbol的值是不可变且唯一的。123const s1 = Symbol('langpz');const s2 = Symbol('langpz');console.log(s1 == s2); // falseBigInt类型JavaScript 中可以用 Number 表示的最大整数为 2^53 - 1，可以写为 Number.MAX_SAFE_INTEGER。如果超过了这个界限，可以用 BigInt来表示，它可以表示任意大的整数。123456const theBiggestInt: bigint = 9007199254740991nconst alsoHuge: bigint = BigInt(9007199254740991)const hugeString: bigint = BigInt(\"9007199254740991\")console.log(theBiggestInt === alsoHuge) // trueconsole.log(theBiggestInt === hugeString) // trueobject对象类型object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。1234567let create = (obj:object):void=&gt;&#123;&#125;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Error类型断言类型断言允许您告诉编译器一个值的类型，并且您可以使用两种语法进行类型断言。1234let value: any = \"langpz\";let length: number = (value as string).length;// 或者let length2: number = (&lt;string&gt;value).length;","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"},{"name":"基础类型","slug":"基础类型","permalink":"http://blog.langpz.com/tags/基础类型/"}]},{"title":"TypeScript简介","slug":"TypeScript简介","date":"2023-09-17T12:14:50.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"TypeScript简介.html","link":"","permalink":"http://blog.langpz.com/TypeScript简介.html","excerpt":"什么是 TypeScript？TypeScript（简称 TS）是一种由微软开发的开源编程语言，它是 JavaScript 的超集。这意味着 TypeScript 扩展了 JavaScript，为其添加了额外的功能，最主要的是类型系统。TypeScript 的目标是提供更强大、更安全、更可维护的代码，同时与 JavaScript 保持高度的兼容性。","text":"什么是 TypeScript？TypeScript（简称 TS）是一种由微软开发的开源编程语言，它是 JavaScript 的超集。这意味着 TypeScript 扩展了 JavaScript，为其添加了额外的功能，最主要的是类型系统。TypeScript 的目标是提供更强大、更安全、更可维护的代码，同时与 JavaScript 保持高度的兼容性。为什么需要 TypeScript？JavaScript 是一门非常灵活的动态类型语言，但这也意味着在编写大型应用程序时可能会出现一些潜在的问题：类型错误： 在运行时才能发现的类型错误可能会导致应用程序崩溃或产生不可预测的行为。代码维护困难： 在大型项目中，难以理解的变量命名和函数签名可能会导致代码难以维护。缺少工具支持： 缺乏类型信息可能导致开发工具无法提供有用的代码补全、重构和错误检查。TypeScript 解决了这些问题，通过引入静态类型检查来增加代码的可靠性和可维护性。它使开发人员能够在开发阶段捕获类型错误，提供了更多的代码提示和智能感知，并提高了代码的可读性。TypeScript 的特点和优势静态类型检查： TypeScript 允许开发人员在编写代码时指定变量、参数和返回值的类型。这样，在编译时就可以检测到类型错误，而不是在运行时出现错误。强大的工具支持： TypeScript 受益于强大的开发工具，如编辑器（如VSCode、WebStorm）和构建工具（如Webpack）。这些工具提供了智能感知、代码补全、重构和错误检查等功能。增强的可读性： TypeScript 代码通常更具可读性，因为类型信息使得代码的意图更加明确。这有助于团队合作和代码维护。渐进式采用： 你可以将 TypeScript 逐步引入项目中，而不需要从头开始重写代码。它兼容现有的 JavaScript 代码，并允许你逐渐添加类型注解。社区支持： TypeScript 有一个庞大的社区，提供了丰富的文档、库和工具，以帮助你更好地使用它。环境配置全局编译TS文件全局安装typescript对TS进行编译12npm install typescript -gtsc --init # 生成tsconfig.json12tsc # 可以将ts文件编译成js文件tsc --watch # 监控ts文件变化生成js文件配置rollup环境初始化项目并安装依赖12npm initnpm install rollup typescript rollup-plugin-typescript2 @rollup/plugin-node-resolve rollup-plugin-serve -D初始化TS配置文件1npx tsc --init修改tsconfig.json文件module: “module”: “ESNext”rollup配置文件123456789101112131415161718192021222324252627// rollup.config.jsimport ts from 'rollup-plugin-typescript2'import &#123;nodeResolve&#125; from '@rollup/plugin-node-resolve';import serve from 'rollup-plugin-serve';import path from 'path'export default &#123; input:'src/main.ts', // 定义入口文件 output:&#123; format:'iife', file:path.resolve('dist/bundle.js'), sourcemap:true &#125;, plugins:[ nodeResolve(&#123; extensions:['.js','.ts'] &#125;), ts(&#123; tsconfig:path.resolve(__dirname,'tsconfig.json') &#125;), serve(&#123; open:true, openPage:'/public/index.html', port:3000, contentBase:'' &#125;) ]&#125;创建 /public/index.html 和 src/main.ts文件123456789101112// /public/index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"/dist/bundle.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;12let a:string = '123'console.log(a)package.json配置123\"scripts\": &#123; \"dev\": \"rollup -c -w --bundleConfigAsCjs\"&#125;我们可以通过npm run dev启动服务来使用typescript。","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.langpz.com/tags/TypeScript/"}]},{"title":"vite热更新报错","slug":"vite热更新报错","date":"2023-08-20T10:26:53.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vite热更新报错.html","link":"","permalink":"http://blog.langpz.com/vite热更新报错.html","excerpt":"vite热更新报错在pinia中使用vue-router控制台报错HMR error: Cannot access ‘…’ before initialization。","text":"vite热更新报错在pinia中使用vue-router控制台报错HMR error: Cannot access ‘…’ before initialization。发现是因为是循环引用导致的报错。组件中引用了vue-router的方法，然后组件还引用了pinia的方法，然后pinia又引用vue-router。造成循环引用报错无法热更新。解决方案使用 import router form ‘@/router/index.js’ 替换 import { useRouter } from “vue-router” 这样去引用vue-router。在pinia 中可以注册插件把 vue-router 挂到全局属性上使用。123456789101112import &#123; createApp, markRaw &#125; from 'vue';import &#123; createPinia &#125; from 'pinia';import App from './app/App.vue';import &#123; router &#125; from './modules/router/router';const app = createApp(App);const pinia = createPinia();pinia.use((&#123; store &#125;) =&gt; &#123; store.$router = markRaw(router)&#125;);app.use(router)如果还出现这类报错可能是别的js方法也出现循环引用。解决思路同上。","categories":[],"tags":[{"name":"vite","slug":"vite","permalink":"http://blog.langpz.com/tags/vite/"}]},{"title":"for in 和 for of 区别","slug":"for-in-和-for-of-区别","date":"2023-07-16T17:59:18.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"for-in-和-for-of-区别.html","link":"","permalink":"http://blog.langpz.com/for-in-和-for-of-区别.html","excerpt":"for in 和 for of 区别for…in 和 for…of 是 JavaScript 中的两种不同的循环语法，用于遍历对象和数组的元素。","text":"for in 和 for of 区别for…in 和 for…of 是 JavaScript 中的两种不同的循环语法，用于遍历对象和数组的元素。for…in 循环for…in 语句以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。for…in 循环不推荐用于遍历数组，因为它可能会遍历数组的所有属性，包括数组原型链上的属性，从而导致不可预料的结果。1234567891011Object.prototype.a = '123'const obj = &#123; name: 'lanpz', age: 60, sex: '男' &#125;;for (let key in obj) &#123; console.log(key + ': ' + obj[key]);&#125;// 输出// \"name: lanpz\"// \"age: 60\"// \"sex: 男\"// \"a: 123\"for…of 循环for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray等）上创建一个迭代循环。123456789101112const arr = [1, 2, 3];Array.prototype.arrCustom = 5for (let value of arr) &#123; if (value == 2) &#123; continue &#125; console.log(value);&#125;// 输出// 1// 3for in 和 for of 区别for in 不仅会遍历当前对象，还包括原型链上的可枚举属性。可能需要通过 hasOwnProperty() 方法来检查是否为对象自身的属性，以避免遍历到原型链上的属性。for of 可以使用break，continue，return终止循环、for in 不支持。for of 按顺序遍历，for…in 循环不保证遍历对象属性的顺序。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"}]},{"title":"使用 Volta 管理Node","slug":"使用-Volta-管理Node","date":"2023-06-24T15:11:37.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用-Volta-管理Node.html","link":"","permalink":"http://blog.langpz.com/使用-Volta-管理Node.html","excerpt":"VoltaVolta 是一个JavaScript包管理器，基于rust构建的没有外部依赖项方便安装，支持 跨平台，支持 macOS、Windows、Linux 、按项目自动版本切换、多个包管理器等优势。","text":"VoltaVolta 是一个JavaScript包管理器，基于rust构建的没有外部依赖项方便安装，支持 跨平台，支持 macOS、Windows、Linux 、按项目自动版本切换、多个包管理器等优势。安装如果之前安装过node 或者 nvm n 请先卸载掉再安装 VoltamacOS / Unix 安装1curl https://get.volta.sh | bash如果没有自动添加到环境变量，需要自己手动配置如果您的shell是bash，进入终端，编辑环境变量文件~/.bash_profile, 输入如下内容如果您的shell是zsh，进入终端，编辑环境变量文件~/.zprofile，输入如下内容12export VOLTA_HOME=\"$HOME/.volta\"export PATH=\"$VOLTA_HOME/bin:$PATH\"Windows安装下载地址 目前最新版是 volta-1.1.1-windows-x86_64.msi安装过程中需要把360卫士之类的安全管家关闭掉，否则有可能无法自动添加到环境变量。安装完可以在命令行输入 volta 检查是否能正常运行。使用安装 node 和yarn123volta install node@11.0.0 // 安装 node 11.0.0版本volta install yarn@1.19 // 安装 yarn 1.19版本volta install node@latest // 安装 node 最新版本固定项目节点引擎（在项目根目录执行）12volta pin node@11.0.0volta pin yarn@1.19将Volta保存到package.json1234\"volta\": &#123; \"node\": \"11.0.0\", \"yarn\": \"1.19.2\"&#125;Volta 将 Node 引擎的确切版本保存在您的中package.json，以便您可以将您的选择提交到 git。从那时起，每次您在项目目录中运行 Node 时，Volta 都会自动切换到您选择的 Node 版本。同样，您的所有协作者都可以通过在其开发计算机上安装 Volta 来执行相同的操作。使用项目工具node和包管理工具可执行文件不是工具链中唯一的智能工具。工具链中的包二进制文件也可以识别当前目录并尊重当前项目结构。例如，安装 Typescript 包会将编译器可执行文件 ( tsc) 添加到工具链中。1npm install --global typescript根据您所在的项目，此可执行文件将切换到项目选择的 TypeScript 版本：12345cd /path/to/project-using-typescript-3.9.4tsc --version // 3.9.4cd /path/to/project-using-typescript-4.1.5tsc --version // 4.1.5不仅 Node 和 npm / Yarn 等包管理器，而且通过它们安装的包二进制文件都受到 Volta 的监控。因此，它会自动切换每个项目的版本。注:目前volta支持pnpm但是不支持全局安装 例如pnpm install -gVolta 命令这是命令行二进制文件的命令参考volta，其语法如下：123456789101112131415161718192021222324252627282930313233The JavaScript Launcher ⚡ To install a tool in your toolchain, use `volta install`. To pin your project's runtime or package manager, use `volta pin`.USAGE: volta [FLAGS] [SUBCOMMAND]FLAGS: --verbose Enables verbose diagnostics --quiet Prevents unnecessary output -v, --version Prints the current version of Volta -h, --help Prints help informationSUBCOMMANDS: fetch Fetches a tool to the local machine install Installs a tool in your toolchain uninstall Uninstalls a tool from your toolchain pin Pins your project's runtime or package manager list Displays the current toolchain completions Generates Volta completions which Locates the actual binary that will be called by Volta setup Enables Volta for the current user / shell run Run a command with custom Node, npm, pnpm, and/or Yarn versions help Prints this message or the help of the given subcommand(s)volta fetch 允许您将工具提取到本地缓存中，而无需将其设置为默认值或使其可用，以供将来离线使用。volta install 安装工具的默认版本。如果该工具尚未在本地缓存，它也会下载该工具。volta uninstall 允许您删除任何已安装的全局包volta install。volta pin 更新项目package.json文件以使用选定版本的工具。volta list 查看已安装的 Node 运行时、包管理器和带有二进制文件的包。volta completions 为您的 shell 生成命令完成信息。volta which 定位并打开 Volta 启动实际的二进制文件。volta setup 通过修改当前用户的 来volta setup启用 Volta （以依赖于平台的方式）以包含 Volta shim 目录。PATHvolta run 使用在命令行中指定的工具版本来运行您提供的命令。volta help 打印此消息或给定子命令的帮助。常用的命令用蓝色标注出来了，对比nvm的好处是无感自动切换版本（在项目目录执行的时候已经切换好版本了）。速度更快。workspaces如果在单个存储库中有多个项目，都共享 Volta 设置。“volta”在 中的部分中package.json，您可以使用 key 指定一个条目“extends”。该条目的值应该是另一个也有一个部分的 JSON 文件的路径”volta”。相对路径将相对于设置它们的文件进行解析。12345&#123; \"volta\": &#123; \"extends\": \"../../package.json\" &#125;&#125;只需要仓库根目录执行volta pin 固定版本 子项目通过extends引入根项目的package.json就可以实现共享 Volta 设置。pnpm支持pnpm目前处于实验阶段。要启用它，请确保将环境变量VOLTA_FEATURE_PNPM设置为1。在 Windows 上，可以将其添加到系统设置中的用户或系统环境变量中。在 Linux/Mac 上，您可以在配置文件脚本中设置值（例如.bash_profile、.zshrc或类似的）。由于此支持是实验性的，因此可能存在一些悬而未决的问题。下面列出了一些已知的限制。全局安装目前，不支持全局安装（例如pnpm install -g），并且会导致错误。迁移目前没有自动迁移功能，因此如果您之前已pnpm作为 Volta 全局安装，则需要通过调用 手动重新安装它volta install pnpm。在启用支持并重新安装之前，您可以pnpm通过卸载以前安装的软件包volta uninstall pnpm。一旦切换到本机 pnpm 支持，您可能无法pnpm通过调用相同的命令来删除隔离的旧包，因为目前还缺乏卸载实现。Volta Could not download node如果碰见 volta install node@11.0.0报错 Volta Could not download node 可以手动下载安装包再执行 volta install node@11.0.0 就可以安装成功了。node下载地址然后找到对应版本Windows 下载 win-xnn.zip后缀 我这边下载的是 node-v11.0.0-win-x64.zipC:\\Users\\电脑账号名\\AppData\\Local\\Volta\\tools\\inventory\\node放到这个目录下再执行1volta install node@11.0.0注:如果你有修改过VOLTA_HOME 环境变量请把node 放到配置环境变量的地址。Volta error: Could not create shared environment for package如果npm or yarn 安装全局包出现这个报错，请使用管理员权限的命令行工具。参考voltaWindow下volta安装node失败解决方案","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Volta","slug":"Volta","permalink":"http://blog.langpz.com/tags/Volta/"}]},{"title":"nvm切换node版本 npm ERR! Unexpected token '.'","slug":"nvm切换node版本-npm-ERR-Unexpected-token","date":"2023-06-17T17:22:42.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"nvm切换node版本-npm-ERR-Unexpected-token.html","link":"","permalink":"http://blog.langpz.com/nvm切换node版本-npm-ERR-Unexpected-token.html","excerpt":"","text":"npm ERR! Unexpected token ‘.’nvm 1.1.9 版本切换高版本node后，执行npm命令报错 npm ERR! Unexpected token &#39;.&#39;解决方案卸载当前nvm 重新下载最新版本1.1.11，然后删除之前安装node 再重新下载。找到之前安装nvm的目录 unins000.exe 右键打开执行卸载流程。下载最新版安装完再执行nvm list 把之前安装node卸载重装就解决问题了。参考https://github.com/npm/cli/issues/4234","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"pinia使用指南","slug":"pinia使用指南","date":"2023-05-27T10:37:37.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"pinia使用指南.html","link":"","permalink":"http://blog.langpz.com/pinia使用指南.html","excerpt":"Pinia 是 Vue 的专属状态管理库，Vue3官网推荐使用Pinia，Pinia支持Vue2和Vue3。","text":"Pinia 是 Vue 的专属状态管理库，Vue3官网推荐使用Pinia，Pinia支持Vue2和Vue3。Pinia 对比 vuex没有了 mutations 这个概念只需要用 Action就可以定义同步和异步的方法没有了 modules Pinia里每个store是一个模块轻量化 Pinia 大小只有 1kb 左右！起步安装 pinia123yarn add pinia# 或者使用 npmnpm install piniaVue3使用123456789import &#123; createApp &#125; from 'vue'import &#123; createPinia &#125; from 'pinia'import App from './App.vue'const pinia = createPinia()const app = createApp(App)app.use(pinia)app.mount('#app')StoredefineStore来定义Store，每个store是一个模块1234567891011import &#123; defineStore &#125; from 'pinia'const countStore = defineStore('storeId', &#123; state: () =&gt; &#123; return &#123; count: 0, &#125; &#125;,&#125;)export &#123; countStore &#125;;使用state12345678910111213141516171819const store = countStore()// 可以通过 store 实例访问 state，直接对其进行读写store.count++// 重置 statestore.$reset()// 变更 state 除了用 store.count++ 直接改变 store，你还可以调用 $patch 方法。它允许你用一个 state 的补丁对象在同一时间更改多个属性store.$patch(&#123; count: store.count + 1, age: 120&#125;)// 订阅 statestore.$subscribe((mutation, state) =&gt; &#123; // mutation.type // ‘direct’ | ‘patch object’ | ‘patch function’ // mutation.storeId // 'storeId' console.log(mutation, state);&#125;, &#123; detached: true &#125;);订阅$subscribemutation.typedirect 直接修改值patch object 通过 patch 传对象方式修改patch function 通过 patch 函数形式修改值detached: true 订阅器即便在组件卸载之后仍会被保留注: store.$state = { count: 24 } 不能完全替换掉 store 的 state，因为那样会破坏其响应性。要使用$patch来修改。GetterGetter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。12345678910const countStore = defineStore('storeId', &#123; state: () =&gt; &#123; return &#123; count: 0, &#125; &#125;, getters: &#123; doubleCount: (state) =&gt; state.count * 2, &#125;,&#125;)使用和state一样。Getter也可以不依赖于state，可以使用其他 getter 来计算。ActionAction 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义。12345678910111213141516171819const countStore = defineStore('storeId', &#123; state: () =&gt; &#123; return &#123; count: 0, &#125; &#125;, getters: &#123; doubleCount: (state) =&gt; state.count * 2, &#125;, actions: &#123; increment() &#123; this.count++ &#125;, &#125;&#125;)const store = countStore()// 直接使用actionsstore.increment()Action 里面不同区分同步还是异步，比vuex更简单和使用方便。订阅 action 通过 store.$onAction(callback, false) 来监听 action 和它们的结果。传递给它的回调函数会在 action 本身之前执行。after 表示在 promise 解决之后，允许你在 action 解决后执行一个回调函数。同样地，onError 允许你在 action 抛出错误或 reject 时执行一个回调函数。组件销毁会自动删除action 订阅器，如需保留可以传递第二个参数 true。1234567891011121314151617181920212223242526272829303132333435const store = countStore()const unsubscribe = store.$onAction( (&#123; name, // action 名称 store, // store 实例，类似 `countStore` args, // 传递给 action 的参数数组 after, // 在 action 返回或解决后的钩子 onError, // action 抛出或拒绝的钩子 &#125;) =&gt; &#123; // 为这个特定的 action 调用提供一个共享变量 const startTime = Date.now() // 这将在执行 \"store \"的 action 之前触发。 console.log(`Start \"$&#123;name&#125;\" with params [$&#123;args.join(', ')&#125;].`) // 这将在 action 成功并完全运行后触发。 // 它等待着任何返回的 promise after((result) =&gt; &#123; console.log( `Finished \"$&#123;name&#125;\" after $&#123; Date.now() - startTime &#125;ms.\\nResult: $&#123;result&#125;.` ) &#125;) // 如果 action 抛出或返回一个拒绝的 promise，这将触发 onError((error) =&gt; &#123; console.warn( `Failed \"$&#123;name&#125;\" after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.` ) &#125;) &#125;)// 手动删除监听器unsubscribe()访问其他 store 的 Store、 getter、 ActionPinia里每个store是一个模块，直接import 实例化 就可以使用其他store 的 Store、 getter、 Action。1234567891011121314151617181920212223242526272829303132333435363738394041export const ageStore = defineStore(\"ageStore\", &#123; state: () =&gt; &#123; return &#123; age: 18 &#125;; &#125;, getters: &#123; doubleAge: (state) =&gt; state.age * 2 &#125;, actions: &#123; increment() &#123; this.age++; &#125; &#125;&#125;);// 引入 ageStore 并使用ageStore 的 Store、 getter、 Actionimport &#123; ageStore &#125; from \"./age\";const countStore = defineStore(\"storeId\", &#123; state: () =&gt; &#123; // 使用 ageStore 的 state const age = ageStore(); return &#123; count: 0, age: age.age &#125;; &#125;, getters: &#123; doubleCount: (state) =&gt; state.count * 2 &#125;, actions: &#123; increment() &#123; // 使用 ageStore 的 actions const age = ageStore(); age.increment(); this.count++; &#125; &#125;&#125;);export &#123; countStore &#125;;注: 两个或更多的 store 相互使用，它们不可以通过 getters 或 actions 创建一个无限循环。它们也不可以同时在它们的 setup 函数中直接互相读取对方的 state组合式API写法12345678export const useCounterStore = defineStore('counter', () =&gt; &#123; const count = ref(0) function increment() &#123; count.value++ &#125; return &#123; count, increment &#125;&#125;)在 Setup Store 中：ref() 就是 state 属性computed() 就是 gettersfunction() 就是 actionsdemodemo参考pinia","categories":[],"tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"http://blog.langpz.com/tags/vue3-0/"},{"name":"pinia","slug":"pinia","permalink":"http://blog.langpz.com/tags/pinia/"}]},{"title":"手写bind、call、apply方法实现","slug":"手写bind、call、apply方法实现","date":"2023-05-13T15:07:23.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"手写bind、call、apply方法实现.html","link":"","permalink":"http://blog.langpz.com/手写bind、call、apply方法实现.html","excerpt":"bind、call、apply方法常用于改调用函数并指定函数执行时的上下文（即this关键字的值）以及参数列表。例如将一个类数组对象转换为真正的数组，以便使用数组的方法、Object原型上的toString方法判断数据类型等功能。","text":"bind、call、apply方法常用于改调用函数并指定函数执行时的上下文（即this关键字的值）以及参数列表。例如将一个类数组对象转换为真正的数组，以便使用数组的方法、Object原型上的toString方法判断数据类型等功能。callcall 方法调用执行函数并用第一个参数改变函数执行时的上下文，可以传多个参数列表实现1234567891011Function.prototype.myCall = function(context, ...args) &#123; // 有bug NaN 0 '' 也会指向window context = context || window // 使用Symbol 防止替换context属性 const symbol = Symbol(); // 通过x.xx() 执行改变 this 上下文 context[symbol] = this const result = context[symbol](...args); delete context[symbol]; return result;&#125;测试一下12345678910111213var x = 1000function b(...arg) &#123; console.log(this.x ,arg)&#125;let a = &#123; x: 1&#125;b.call(a, 2, 3, 4)// 输出 1 [2, 3, 4] this 就变成 a 参数列表也打印了b.myCall(null, 2, 3, 4)// 输出 1000 [2, 3, 4] this 是windowdemoapplycall 方法调用执行函数并用第一个参数改变函数执行时的上下文，第二个参数是一个数组（或一个类数组对象）的形式提供的参数。 和call 的区别在于第二个参数 call 是参数列表实现1234567891011Function.prototype.myApply = function(context, args) &#123; // 有bug NaN 0 '' 也会指向window context = context || window // 使用Symbol 防止替换context属性 const symbol = Symbol(); // 通过x.xx() 执行改变 this 上下文 context[symbol] = this const result = context[symbol](...args); delete context[symbol]; return result;&#125;测试一下12345678910111213var x = 1000function b(...arg) &#123; console.log(this.x ,arg)&#125;let a = &#123; x: 1&#125;b.apply(a, [2, 3, 4])// 输出 1 [2, 3, 4] this 就变成 a 参数列表也打印了b.myApply(null, [2, 3, 4])// 输出 1000 [2, 3, 4] this 是windowdemobindbind方法和call、apply都不一样，先绑定context 上下文和参数，创建一个新的函数返回。参数将作为新函数的参数，供调用时使用。实现1234567Function.prototype.myBind = function(context, ...args1) &#123; const fn = this; return function(...args2) &#123; context = context || this; return fn.apply(context, [...args1, ...args2]); &#125;&#125;测试一下12345678910111213141516171819202122Function.prototype.myBind = function(context, ...args1) &#123; const fn = this; return function(...args2) &#123; context = context || this; return fn.apply(context, [...args1, ...args2]); &#125;&#125;var x = 1000function b(...arg) &#123; console.log(this.x ,arg)&#125;let a = &#123; x: 1&#125;let bind1 = b.bind(a, 2, [3, 4])bind1()// 输出 1 [2, [3, 4]]let bind2 = b.myBind(null, 2, [3, 4])bind2()// 输出 1000 [2, [3, 4]]","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"}]},{"title":"手写EventHub(发布订阅)","slug":"手写EventHub-发布订阅","date":"2023-04-29T14:07:39.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"手写EventHub-发布订阅.html","link":"","permalink":"http://blog.langpz.com/手写EventHub-发布订阅.html","excerpt":"EventHub 是一种事件发布-订阅模式的实现。订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。","text":"EventHub 是一种事件发布-订阅模式的实现。订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。实现每个实例有一个调度中心。负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者。on方法订阅的事件注册（Subscribe）到调度中心。once方法只订阅一次，执行后移除订阅事件。off方法从调度中心移除订阅的事件。emit方法发布事件，并通过调度中心通知所有的订阅者1234567891011121314151617181920212223242526272829303132333435363738394041class EventHub &#123; constructor() &#123; // 调度中心 this.channel = &#123;&#125; &#125; on(name, fn) &#123; this.channel[name] = this.channel[name] || [] this.channel[name].push(fn) &#125; off(name, fn) &#123; const list = this.channel[name] || [] const index = list.indexOf(fn) if(index &lt; 0) return list.splice(index, 1) &#125; once(name, fn) &#123; this.channel[name] = this.channel[name] || [] let one = (arg) =&gt; &#123; fn.call(null, arg) &#125; // 记录下绑定事件 one.fn = fn // 添加移除方法 one.off = () =&gt; &#123; this.off(name, one) &#125; this.on(name, one) &#125; emit(name, data) &#123; let list = this.channel[name] || [] let ones = [] list.forEach(fn =&gt; &#123; fn.call(null, data) fn.off &amp;&amp; ones.push(fn) &#125;) // 移除once订阅事件、执行完再移除不会导致删除数组后执行顺序不对问题 ones.forEach(fn =&gt; fn.off()) &#125;&#125;测试123456789101112131415// 发布者let q = new EventHub()// 订阅者q.on('click', function(data) &#123; console.log('on')&#125;)// 订阅者只订阅一次q.once('click', function() &#123; console.log('once')&#125;)// 发布者发布消息通知click的订阅者q.emit('click')q.emit('click')// 输出 on、once、ondemodemo地址","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.langpz.com/tags/设计模式/"},{"name":"EventHub，发布订阅","slug":"EventHub，发布订阅","permalink":"http://blog.langpz.com/tags/EventHub，发布订阅/"}]},{"title":"Vue3组合式API(Composition API)","slug":"Vue3组合式API(Composition API) ","date":"2023-04-22T11:36:22.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"Vue3组合式API(Composition API) .html","link":"","permalink":"http://blog.langpz.com/Vue3组合式API(Composition API) .html","excerpt":"组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。组合式 API 是Vue 3 及 Vue 2.7 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue/composition-api。","text":"组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。组合式 API 是Vue 3 及 Vue 2.7 的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue/composition-api。Vue3并没有强制必须要使用组合式 API (Composition API) 在Vue3中还是可以使用 选项式（Options API）的写法。什么是组合式 API？组合式 API (Composition API) 是一系列 API 的集合，使我们可以使用函数而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：响应式 API：例如 ref() 和 reactive()，使我们可以直接创建响应式状态、计算属性和侦听器。生命周期钩子：例如 onMounted() 和 onUnmounted()，使我们可以在组件各个生命周期阶段添加逻辑。依赖注入：例如 provide() 和 inject()，使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统。组合式 API优点提高代码逻辑的可复用性更灵活的代码组织对比选项式 API（Options API）1234567891011121314151617181920212223242526272829303132&lt;script&gt;export default &#123; props: ['msg'], data() &#123; return &#123; count: 0, // 逻辑1的数据 name: 'langpz' // 逻辑2的数据 &#125; &#125;, methods: &#123; onAdd() &#123; // 逻辑1的⽅法 this.count++ &#125;, getCount() &#123; // 逻辑2的⽅法 this.count = Math.floor(Math.random() * 100) &#125; &#125;, computed: &#123; helloText() &#123; // 逻辑2的计算属性 return this.msg + ' ' + this.name &#125; &#125;, watch: &#123; count() &#123; // 逻辑1的Watch console.log('count 变了') &#125; &#125;, created() &#123; this.getCount() // 逻辑2的初始化操作 &#125;&#125;&lt;/script&gt;组合式 API (Composition API)123456789101112131415161718192021&lt;script setup&gt;import &#123; ref, watch, computed, onMounted &#125; from 'vue'const props = defineProps(['msg'])// 逻辑1的数据let count = ref(0)// 逻辑1的⽅法const onAdd = () =&gt; count.value++// 逻辑1的Watchwatch(count, (val, oldVal) =&gt; &#123; console.log(`count 从$&#123;oldVal&#125; 变成了 $&#123;val&#125;`)&#125;)// 逻辑2的⽅法const getCount = () =&gt; count.value = Math.floor(Math.random() * 100)// 逻辑2的初始化操作onMounted(getCount)// 逻辑2的数据let name = ref('langpz')// 逻辑2的计算属性let helloText = computed(() =&gt; props.msg + ' ' +name.value)&lt;/script&gt;通过上面的例子相同的业务逻辑，组合式 API 里面同一个逻辑关注点相关的代码被归为了一组：我们无需再为了一个逻辑关注点在不同的选项块间来回滚动切换。此外，我们现在可以很轻松地将这一组代码移动到一个外部文件中，不再需要为了抽象而重新组织代码，大大降低了重构成本，这在长期维护的大型项目中非常关键。&lt;script setup&gt;在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 &lt;script setup&gt; 来大幅度地简化代码。setup() 函数1234567891011121314151617181920212223import &#123; reactive &#125; from 'vue'export default &#123; setup(props, context) &#123; const state = reactive(&#123; count: 0 &#125;) function increment() &#123; state.count++ &#125; // 还需要把值和方法return 返回 return &#123; state, increment &#125; &#125;&#125;&lt;template&gt; &lt;button @click=\"increment\"&gt; &#123;&#123; state.count &#125;&#125; &lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;123456789101112131415&lt;script setup&gt;import &#123; reactive &#125; from 'vue'const state = reactive(&#123; count: 0 &#125;)function increment() &#123; state.count++&#125;&lt;/&gt;&lt;template&gt; &lt;button @click=\"increment\"&gt; &#123;&#123; state.count &#125;&#125; &lt;/button&gt;&lt;/template&gt;响应式 APIref()接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value。如果在 &lt;template&gt; 可以不用写.value123456789const count = ref(0)console.log(count.value) // 0count.value++console.log(count.value) // 1&lt;template&gt; &#123;&#123; count &#125;&#125;&lt;/template&gt;给ref传一个对象内部会去调用reactive()reactive()返回一个对象的响应式代理。12345const state = reactive(&#123; count: 0&#125;)state.count++console.log(state.count) // 1toRef()基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值也会同步关联修改。1234567891011121314const state = reactive(&#123; foo: 1, bar: 2&#125;)const fooRef = toRef(state, 'foo')// 更改该 ref 会更新源属性fooRef.value++console.log(state.foo) // 2// 更改源属性也会更新该 refstate.foo++console.log(fooRef.value) // 3toRefs()将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。1234567891011const state = reactive(&#123; foo: 1, bar: 2&#125;)const stateAsRefs = toRefs(state)state.foo++console.log(stateAsRefs.foo.value) // 2stateAsRefs.foo.value++console.log(state.foo) // 3computed()接受一个 getter 函数，返回一个只读的响应式 ref 对象。该 ref 通过 .value 暴露 getter 函数的返回值。它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。123456789101112const state = reactive(&#123; count: 0,&#125;)const doubleCount = computed(() =&gt; &#123; return state.count * 2&#125;)console.log(doubleCount.value) // 输出 0state.count++console.log(doubleCount.value) // 输出 2watch(source，callback，options)侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。第一个参数是侦听器的源。第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。第三个可选的参数是一个对象，支持以下这些选项：immediate：在侦听器创建时立即触发回调。 默认：falsedeep：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。 当直接侦听一个响应式对象时，侦听器会自动启用深层模式。 默认：falseonTrack / onTrigger：调试侦听器的依赖。flush：调整回调函数的刷新时机。 ‘pre’ | ‘post’ | ‘sync’ 默认：’pre’默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: ‘post’sync 同步调用123456const count = ref(0);watch(count, (newVal, oldVal) =&gt; &#123; console.log(`count changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`);&#125;);count.value++多个值123456789const count1 = ref(0);const count2 = ref(1);watch([count1, count2], ([newVal1, newVal2] , [oldVal1, oldVal2]) =&gt; &#123; console.log(`count1 changed from $&#123;oldVal1&#125; to $&#123;newVal1&#125;`); console.log(`count2 changed from $&#123;oldVal2&#125; to $&#123;newVal2&#125;`);&#125;);count1.value++count2.value++当直接侦听一个响应式对象时，侦听器会自动启用深层模式：1234const state = reactive(&#123; count: 0 &#125;)watch(state, () =&gt; &#123; /* 深层级变更状态所触发的回调 */&#125;)停止侦听器：1234const stop = watch(source, callback)// 当已不再需要该侦听器时：stop()watchEffect(effect, options)立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。第一个参数就是要运行的副作用函数。会自动收集函数里面的依赖监听。第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。onTrack / onTrigger：调试侦听器的依赖。flush：调整回调函数的刷新时机。 ‘pre’ | ‘post’ | ‘sync’ 默认：’pre’1234567const count = ref(0)watchEffect(() =&gt; console.log(count.value))// -&gt; 输出 0count.value++// -&gt; 输出 1和watch()用法一样，区别watchEffect可以自动收集需要监听的依赖。常用的响应式API就这些，更多API可以去官网查看生命周期钩子⽣命周期钩⼦写法微调，xxx变成 OnXxx，如mouted 变成 onMounted。created和beforeCreate不再需要。Vue2中 destroyed 和 beforeDestroy 在Vue3换了名字，换成 beforeUnmount 和 unmounted 。选项式 API组合式 APIbeforeCreatesetup()createdsetup()beforeMountonBeforeMountmountedonMountedbeforeUpdateonBeforeUpdateupdatedonUpdatedbeforeUnmountonBeforeUnmountunmountedonUnmountederrorCapturedonErrorCapturedrenderTrackedonRenderTrackedrenderTriggeredonRenderTriggeredactivatedonActivateddeactivatedonDeactivatedserverPrefetchonServerPrefetch","categories":[],"tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"http://blog.langpz.com/tags/vue3-0/"},{"name":"组合式API","slug":"组合式API","permalink":"http://blog.langpz.com/tags/组合式API/"}]},{"title":"JavaScript的事件委托原理","slug":"JavaScript的事件委托原理","date":"2023-03-26T15:48:44.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"JavaScript的事件委托原理.html","link":"","permalink":"http://blog.langpz.com/JavaScript的事件委托原理.html","excerpt":"事件委托事件委托是JavaScript中常用的一种事件处理方式，也称为事件代理。它可以让我们在处理多个相似元素事件时，减少重复代码，提高性能和代码可维护性。","text":"事件委托事件委托是JavaScript中常用的一种事件处理方式，也称为事件代理。它可以让我们在处理多个相似元素事件时，减少重复代码，提高性能和代码可维护性。事件委托的原理是将事件绑定在元素的祖先元素上，然后通过事件冒泡的机制，把事件传播到目标元素。代码实现原始版12345678910111213&lt;ul id=\"a\"&gt; &lt;li&gt;11&lt;/li&gt; &lt;li&gt;22&lt;/li&gt; &lt;li&gt;33&lt;/li&gt;&lt;/ul&gt;let a = document.querySelector('#a')let aLi = a.querySelectorAll('li')for (let i = 0; i &lt; aLi.length; i++) &#123; aLi[i].addEventListener('click', function(event) &#123; console.log(event.target.innerText) &#125;)&#125;给每个li添加一个click事件，如果数量过多每个LI都会添加事件这样会添加N个事件。委托版1234567891011121314&lt;ul id=\"aa\"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt; &lt;span&gt;333&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;let aa = document.querySelector('#aa')aa.addEventListener('click', function(event) &#123; if (event.target.tagName.toLocaleLowerCase() == 'li') &#123; console.log(event.target.innerText) &#125;&#125;)通过把事件委托到祖先元素上冒泡机制触发，然后再判断用户是不是点击的是li再执行某些操作。但是这样写会有一个问题，li里面又包了一个span标签再点击li里面的span就不会再执行某些操作。最终版1234567891011121314151617181920212223242526&lt;ul id=\"aaa\"&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt; &lt;span&gt;3333&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;function onEvent(element, eventType, selector, fn) &#123; element.addEventListener(eventType, e =&gt; &#123; let el = e.target while (!el.matches(selector)) &#123; if (element === el) &#123; el = null break &#125; el = el.parentNode &#125; el &amp;&amp; fn.call(el, e, el) &#125;) return element&#125;onEvent(document.querySelector('#aaa'), 'click', 'li', function(ev, el) &#123; console.log(el.innerText)&#125;)最终版利用Element.matches()来匹配。onEvent函数 最后封装好的方法第一个参数祖先元素，第二个参数绑定的事件第三个参数绑定的元素，可以是css选择器 例: ‘.ax img’、’”input[name=’xxx’]:checked”‘第四个参数触发的函数优点减少了DOM操作次数，提高了性能。事件委托利用事件冒泡机制，将事件绑定在父元素上，可以在子元素触发事件时进行响应，避免了对每个子元素都绑定事件的开销，减少了DOM操作次数，提高了性能。动态监听绑定事件，减少代码量。在动态添加子元素时，如果采用传统的事件绑定方式，需要对每个新添加的子元素都进行事件绑定操作，代码量会非常大。而事件委托只需要在父元素上绑定一次事件即可。缺点事件委托无法处理一些不能冒泡的事件，例如focus、blur等，需要对这些事件进行单独处理。调试比较复杂，不容易确定监听者。因为所有子元素的事件都被绑定在一个父元素上。DemoDemo地址","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"事件委托","slug":"事件委托","permalink":"http://blog.langpz.com/tags/事件委托/"}]},{"title":"解决Waline服务因vercel国内被墙无法使用","slug":"解决Waline服务因vercel国内被墙无法使用","date":"2023-03-04T16:40:24.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"解决Waline服务因vercel国内被墙无法使用.html","link":"","permalink":"http://blog.langpz.com/解决Waline服务因vercel国内被墙无法使用.html","excerpt":"Waline评论服务最近发现博客详情页面偶尔有报错，评论无法使用，查询发现是vercel被墙了。","text":"Waline评论服务最近发现博客详情页面偶尔有报错，评论无法使用，查询发现是vercel被墙了。解决方案自定义域名在你的域名下面添加一个新的子域名记录类型CNAME记录值cname.vercel-dns.com然后再去vercel 给你的Waline服务添加上刚才的子域名然后再把hexo博客里面Waline服务地址更换成刚才的子域名如果没有域名可以去https://my.freenom.com/ 注册免费的域名后续继续被墙可以考虑换服务或者套个cdn中转一下参考使用自定义域名激活Vercel部署的Waline服务","categories":[],"tags":[{"name":"Waline","slug":"Waline","permalink":"http://blog.langpz.com/tags/Waline/"},{"name":"vercel","slug":"vercel","permalink":"http://blog.langpz.com/tags/vercel/"}]},{"title":"Hexo博客从Travis-CI迁移到GitHub Actions","slug":"从Travis-CI迁移到GitHub-Actions","date":"2023-02-11T08:58:23.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"从Travis-CI迁移到GitHub-Actions.html","link":"","permalink":"http://blog.langpz.com/从Travis-CI迁移到GitHub-Actions.html","excerpt":"Hexo博客从Travis-CI迁移到GitHub Actions由于Travis-CI更改了免费政策，系统赠送的 10000 积分用完以后，就无法继续免费使用构建服务了。所以迁移到GitHub Actions。Github Actions每月2000分钟免费额度。","text":"Hexo博客从Travis-CI迁移到GitHub Actions由于Travis-CI更改了免费政策，系统赠送的 10000 积分用完以后，就无法继续免费使用构建服务了。所以迁移到GitHub Actions。Github Actions每月2000分钟免费额度。GitHub ActionsGitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。GitHub Actions 可帮助您在软件开发生命周期内自动执行任务。GitHub 操作是事件驱动的，这意味着您可以在发生指定事件后运行一系列命令。例如，每次有人为存储库创建拉取请求时，您都可以自动运行执行软件测试脚本的命令。GitHub Actions基本概念（1）workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。（2）events（事件）：事件是触发工作流程的特定活动。例如，监听推送触发工作流程等。（3）job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。（4）step（步骤）：每个 job 由多个 step 构成，一步步完成。（5）action （动作）：每个 step 可以依次执行一个或多个命令（action）。（6）runners （运行器）：运行器是安装了 GitHub Actions 运行器应用程序的服务器。workflows文件GitHub Actions 使用 YAML 语法来定义事件、作业和步骤。 这些 YAML 文件存储在代码仓库中名为 .github/workflows 的目录中。迁移首先在项目根目录下面创建 .github/workflows 目录和hexo.yml 文件。SecretId、SecretKey、CI_TOKEN 环境变量需要在仓库 -&gt; Settings -&gt; Actions secrets and variables -&gt; New repository secret, 添加Secrets变量12345678910111213141516171819202122232425262728293031323334353637383940name: hexoon: push: branches: - indigoenv: GH_REF: github.com/lanpangzhi/lanpangzhi.github.io secretId: $&#123;&#123; secrets.SECRETID &#125;&#125; secretKey: $&#123;&#123; secrets.SECRETKEY &#125;&#125;jobs: build: runs-on: ubuntu-latest steps: - name: Checkout codes uses: actions/checkout@v3 with: submodules: 'true' - name: Setup node uses: actions/setup-node@v3 with: node-version: \"10.14.0\" - name: Install and Deploy run: | npm install hexo-cli -g npm install hexo generate hexo d - name: Deploy github run: | cd ./public git init git config user.name \"lanpangzhi\" git config user.email \"875727617@qq.com\" git add . git commit -m \"GitHub Actions 自动部署\" git push --force --quiet \"https://$&#123;&#123;secrets.CI_TOKEN&#125;&#125;@$&#123;&#123;env.GH_REF&#125;&#125;\" master:master注意环境变量获取和写法和Travis-CI不一样12$&#123;&#123;env.GH_REF&#125;&#125; 对应 $&#123;GH_REF&#125; $&#123;&#123;secrets.CI_TOKEN&#125;&#125; 对应 $&#123;CI_TOKEN&#125; 因为是从配置Secrets变量直接拿所以要用 secrets.的方式git 子模块需要手动配置开启123- uses: actions/checkout@v3 with: submodules: true执行脚本12345steps: - name: Run build script run: | npm install hexo-cli -g npm install参考从 Travis CI 迁移到 GitHub Actions","categories":[],"tags":[{"name":"GitHub Actions","slug":"GitHub-Actions","permalink":"http://blog.langpz.com/tags/GitHub-Actions/"}]},{"title":"axios发送Basic Auth认证和Bearer Token","slug":"axios发送Basic-Auth认证和Bearer-Token","date":"2023-02-03T20:43:16.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"axios发送Basic-Auth认证和Bearer-Token.html","link":"","permalink":"http://blog.langpz.com/axios发送Basic-Auth认证和Bearer-Token.html","excerpt":"Basic Auth认证","text":"Basic Auth认证axios配置如下只需要增加 auth 参数即可，auth: {username: &#39;lanpz&#39;,password: &#39;123456789&#39;}。12345axios.post('xxx', &#123;x: 1&#125;, auth: &#123;username: 'lanpz',password: '123456789'&#125; , &#123; headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' &#125;&#125;).then((&#123;data&#125;) =&gt; console.log(data));Bearer Token在axios请求拦截器里面自定义下请求头即可。123service.interceptors.request.use(async request =&gt; &#123; request.headers['Authorization'] = `Bearer $&#123;token&#125;`&#125;)","categories":[],"tags":[{"name":"axios","slug":"axios","permalink":"http://blog.langpz.com/tags/axios/"}]},{"title":"手写vue日历组件","slug":"手写vue日历组件","date":"2023-01-14T18:28:52.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"手写vue日历组件.html","link":"","permalink":"http://blog.langpz.com/手写vue日历组件.html","excerpt":"手写vue日历组件vue版本vue2，样式和参数参考element-ui的Calendar组件。自动补全上一月和下一月空白日期，支持周起始日设置，单元格日期自定义插槽，自定义右侧头部插槽。坑点：闰年2月29天处理","text":"手写vue日历组件vue版本vue2，样式和参数参考element-ui的Calendar组件。自动补全上一月和下一月空白日期，支持周起始日设置，单元格日期自定义插槽，自定义右侧头部插槽。坑点：闰年2月29天处理处理闰年问题代码1234567891011121314151617181920212223242526272829//判断是否为闰年funtion isLeapYear(year) &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0;&#125;//获取当月的天数funtion getDaysOfMonth(dateStr) &#123; var date = new Date(dateStr); var year = date.getFullYear(); var mouth = date.getMonth() + 1; var day = 0; if (mouth == 2) &#123; day = isLeapYear(year) ? 29 : 28; &#125; else if ( mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12 ) &#123; day = 31; &#125; else &#123; day = 30; &#125; return day;&#125;,完整代码分为头部和日历天数区域，dom结构和样式代码参数v-model 绑定值 Date, String, Numberfirst-day-of-week 周起始日 Number 默认值 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239&lt;template&gt; &lt;div class=\"calendar\"&gt; &lt;div class=\"calendar-header\"&gt; &lt;div class=\"left\"&gt; &lt;span class=\"month\"&gt;&#123;&#123; value.toString(\"yyyy年MM月\") &#125;&#125;&lt;/span&gt; &lt;button @click=\"btnChangeMonth('prevMonth')\"&gt;上个月&lt;/button&gt; &lt;button style=\"margin-left: 10px\" @click=\"btnChangeMonth('nextMonth')\"&gt; 下个月 &lt;/button&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;!-- 自定义右侧头部插槽 --&gt; &lt;slot name=\"right-header\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"calendar-body\"&gt; &lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt; &#123;&#123; week[firstDayOfWeek] &#125;&#125; &lt;/td&gt; &lt;td v-for=\"item in week.length - 1 - firstDayOfWeek\" :key=\"week[item + firstDayOfWeek]\" &gt; &#123;&#123; week[item + firstDayOfWeek] &#125;&#125; &lt;/td&gt; &lt;td v-for=\"item in firstDayOfWeek\" :key=\"week[item - 1]\"&gt; &#123;&#123; week[item - 1] &#125;&#125; &lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"(item, index) in days.length / 7\" :key=\"index\"&gt; &lt;td :class=\"&#123; empty: !days[day + index * 7 - 1].date &#125;\" v-for=\"day in 7\" :key=\"day + index * 7\" &gt; &lt;!-- 单元格日期自定义插槽 --&gt; &lt;slot name=\"dateCell\" :row=\"days[day + index * 7 - 1]\"&gt; &#123;&#123; days[day + index * 7 - 1] &amp;&amp; days[day + index * 7 - 1].date.split(\"-\")[2] &#125;&#125; &lt;/slot&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: \"Calendar\", model: &#123; prop: \"value\", event: \"monthChange\", &#125;, props: &#123; value: [Date, String, Number], firstDayOfWeek: &#123; type: Number, default: 1, &#125;, &#125;, data() &#123; return &#123; week: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"], days: [], &#125;; &#125;, methods: &#123; btnChangeMonth(month) &#123; // 上一月 if (month === \"prevMonth\") &#123; this.$emit(\"monthChange\", this.getPrevNextMonth(this.value, -1)); &#125; // 下一月 if (month === \"nextMonth\") &#123; this.$emit(\"monthChange\", this.getPrevNextMonth(this.value, 1)); &#125; &#125;, init() &#123; const date = this.value; const time = date.toString(\"yyyy-MM\"); const firstDayOfWeek = this.firstDayOfWeek; // 当月周一是星期几 0-6 0是星期日 const days = this.getMonthDay(date); const fillDay = []; let day = []; // 一个月多少天 const monthDay = this.getDaysOfMonth(date); // 补全空格上月日期 const fill = (7 + days - firstDayOfWeek) % 7; for (let i = 0; i &lt; fill; i++) &#123; fillDay.push(&#123; date: \"\" &#125;); &#125; for (let j = 1; j &lt;= monthDay; j++) &#123; let d = j.toString().padStart(2, \"0\"); day.push(&#123; date: time + \"-\" + d &#125;); &#125; day = [...fillDay, ...day]; // 补全空格下个月日期 while (day.length % 7 != 0) &#123; day.push(&#123; date: \"\" &#125;); &#125; this.$set(this, \"days\", day); &#125;, //获取当月的天数 getDaysOfMonth(dateStr) &#123; var date = new Date(dateStr); var year = date.getFullYear(); var mouth = date.getMonth() + 1; var day = 0; if (mouth == 2) &#123; day = this.isLeapYear(year) ? 29 : 28; &#125; else if ( mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12 ) &#123; day = 31; &#125; else &#123; day = 30; &#125; return day; &#125;, //判断是否为闰年 isLeapYear(year) &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0; &#125;, /** * 获取上一月或者下一个月 * @param now 日期 * @param addMonths 传-1 上个月,传1 下个月 */ getPrevNextMonth(now, addMonths) &#123; var dd = new Date(now); var m = dd.getMonth() + 1; var y = dd.getMonth() + 1 + addMonths &gt; 12 ? dd.getFullYear() + 1 : dd.getFullYear(); if (m + addMonths == 0) &#123; y = y - 1; m = 12; &#125; else &#123; if (m + addMonths &gt; 12) &#123; m = \"01\"; &#125; else &#123; m = m + 1 &lt; 10 ? \"0\" + (m + addMonths) : m + addMonths; &#125; &#125; return new Date(y, m, 0); &#125;, // 获取月份1号是周几 getMonthDay(date) &#123; var d = new Date(date); const y = d.getFullYear(); const m = d.getMonth(); return new Date(y, m, 1).getDay(); &#125;, &#125;, created() &#123; this.init(); &#125;, watch: &#123; value(val) &#123; this.init(); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style rel=\"stylesheet/scss\" lang=\"scss\" scoped&gt;.calendar &#123; width: 100%; background: #fff; .calendar-header &#123; overflow: hidden; .left &#123; float: left; .month &#123; display: inline-block; width: 96px; font-size: 16px; line-height: 32px; font-weight: 500; color: #333; &#125; &#125; .right &#123; float: right; &#125; &#125; .calendar-body &#123; width: 100%; padding: 0 1px; overflow-y: auto; .table &#123; width: 100%; border-collapse: collapse; box-sizing: border-box; thead &#123; td &#123; padding: 8px 0; text-align: center; &#125; &#125; tbody &#123; td &#123; width: 14.28%; height: 80px; border: 1px solid #ebeef5; font-size: 18px; padding: 8px 14px; color: #666; &amp;.empty &#123; background: #f9f9f9; &#125; &#125; &#125; &#125; &#125;&#125;&lt;/style&gt;用法所有插槽和参数的用法1234567891011121314// 自定义左侧头部&lt;Calendar v-model=\"new Date()\"&gt; &lt;div slot=\"right-header\" style=\"color: red\"&gt;自定义左侧头部&lt;/div&gt;&lt;/Calendar&gt;// 自定义日期&lt;Calendar v-model=\"new Date()\"&gt; &lt;template slot=\"dateCell\" slot-scope=\"scope\"&gt; &#123;&#123; scope.row.date.split(\"-\").slice(1).join(\"-\") &#125;&#125; &lt;/template&gt;&lt;/Calendar&gt;// 自定义周起始日&lt;Calendar v-model=\"new Date()\" :first-day-of-week=\"0\"&gt; &lt;/Calendar&gt;demodemo地址","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"}]},{"title":"手写Promise.allsettled方法","slug":"手写Promise-allsettled方法","date":"2022-11-05T11:21:30.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"手写Promise-allsettled方法.html","link":"","permalink":"http://blog.langpz.com/手写Promise-allsettled方法.html","excerpt":"手写Promise.allsettled方法之前实现过Promsie.all方法，但是all这个方法如果有一个失败了就相当于全部失败了，这种对体验和交互都不友好，Promise.allsettled就是改进版，有失败还会继续执行，等所有的Promsie执行完返回一个对象数组。","text":"手写Promise.allsettled方法之前实现过Promsie.all方法，但是all这个方法如果有一个失败了就相当于全部失败了，这种对体验和交互都不友好，Promise.allsettled就是改进版，有失败还会继续执行，等所有的Promsie执行完返回一个对象数组。Promise.allsettled方法和Promsie.all方法接收参数一样。执行完返回一个数组对象每个结果对象，都有一个 status 字符串。如果它的值为 fulfilled，则结果对象上存在一个 value 。如果值为 rejected，则存在一个 reason 。代码实现1234567891011121314151617181920212223242526272829Promise.myAllsettled = function(list) &#123; if (list.length === 0) return Promise.resolve([]) const results = [] let count = 0 const settled = (index, status, res, resolve) =&gt; &#123; results[index] = &#123; status, ...res &#125; count += 1 if (count == list.length) &#123; resolve(results) &#125; &#125; return new Promise((resolve) =&gt; &#123; list.map((item, index) =&gt; &#123; // 把数据都处理成Promise Promise.resolve(item).then( res =&gt; &#123; settled(index, 'fulfilled', &#123;value: res&#125;, resolve) &#125;, err =&gt; &#123; settled(index, 'rejected', &#123;reason: err&#125;, resolve) &#125; ) &#125;) &#125;)&#125;demodemo地址参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://blog.langpz.com/tags/Promise/"}]},{"title":"Debian9安装设置Fail2ban","slug":"Debian9安装设置Fail2ban","date":"2022-10-22T14:47:31.000Z","updated":"2025-09-06T12:42:50.048Z","comments":true,"path":"Debian9安装设置Fail2ban.html","link":"","permalink":"http://blog.langpz.com/Debian9安装设置Fail2ban.html","excerpt":"Fail2banfail2ban是一款入侵防御软件，可以监视你的系统日志，然后匹配日志的错误信息（正则式匹配）执行相应的屏蔽动作。可以防止别人恶意扫描和暴力破解SSH密码。","text":"Fail2banfail2ban是一款入侵防御软件，可以监视你的系统日志，然后匹配日志的错误信息（正则式匹配）执行相应的屏蔽动作。可以防止别人恶意扫描和暴力破解SSH密码。安装Python2 &gt;= 2.7 or Python &gt;= 3.21234// 更新系统apt update &amp;&amp; apt upgrade -y// 安装apt install fail2ban修改配置文件vi /etc/fail2ban/jail.conf12345678[DEFAULT]// 封禁时间秒，设置了一年。bantime = 31536000 // 重试时间秒，这里设置了24小时。findtime = 86400 // 最大尝试次数 2。maxretry = 2创建本地规则配置vi /etc/fail2ban/jail.d/jail-debian.local1234[sshd]port = 你的ssh端口// 最大重试次数，2。maxentry = 2以上配置都保存后执行重启命令1systemctl restart fail2ban常用命令启动 systemctl start fail2ban停止 systemctl stop fail2ban重启 systemctl restart fail2ban移除被封的IP fail2ban-client set sshd unbanip 1.1.2.2（要解禁的IP）查看 sshd 封禁情况 fail2ban-client status sshdfail2ban状态 service fail2ban status","categories":[],"tags":[{"name":"Debian9","slug":"Debian9","permalink":"http://blog.langpz.com/tags/Debian9/"},{"name":"Fail2ban","slug":"Fail2ban","permalink":"http://blog.langpz.com/tags/Fail2ban/"}]},{"title":"el-date-picker日期范围设置选择区间","slug":"el-date-picker日期范围设置选择区间","date":"2022-10-01T09:48:14.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"el-date-picker日期范围设置选择区间.html","link":"","permalink":"http://blog.langpz.com/el-date-picker日期范围设置选择区间.html","excerpt":"el-date-picker日期范围设置选择区间el-date-picker组件type=”daterange” 选择日期范围的时候需要设置一个区间，官方api没直接提供参数，这个时候需要通过组件Picker Options来实现。","text":"el-date-picker日期范围设置选择区间el-date-picker组件type=”daterange” 选择日期范围的时候需要设置一个区间，官方api没直接提供参数，这个时候需要通过组件Picker Options来实现。代码用到了onPick（选中日期后会执行的回调，只有当 daterange 或 datetimerange 才生效） 和 disabledDate（设置禁用状态，参数为当前日期，要求返回 Boolean ）， onPick触发就代表选中了第一个日期，根据第一个日期算出来选择范围。disabledDate 根据范围禁用不可选日期。12345678910111213141516171819202122232425262728293031323334data() &#123; return &#123; daterange: &#123; maxTime: \"\", // 最大日期 minTime: \"\", // 最小日期 max: 30, // 限制范围 30天 &#125;, pickerOptions: &#123; onPick: time =&gt; &#123; // 如果没有选择时间 if (!time.maxDate) &#123; // 算出时间范围（30天） let timeRange = this.daterange.max * 24 * 60 * 60 * 1000; // 算出最大时间和最小时间 this.daterange.minTime = time.minDate.getTime() - timeRange; this.daterange.maxTime = time.minDate.getTime() + timeRange; &#125; else &#123; // 如果选了两个时间，那就清空本次范围判断数据，以备重选 this.daterange.maxTime = \"\"; this.daterange.minTime = \"\"; &#125; &#125;, disabledDate: time =&gt; &#123; // 禁用不可选日期 if (this.daterange.minTime &amp;&amp; this.daterange.maxTime) &#123; return ( time.getTime() &lt; this.daterange.minTime || time.getTime() &gt; this.daterange.maxTime ); &#125; &#125; &#125; &#125;&#125;demo地址","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"element-ui","slug":"element-ui","permalink":"http://blog.langpz.com/tags/element-ui/"}]},{"title":"手写Promise.race方法","slug":"手写Promise-race方法","date":"2022-09-10T17:57:26.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"手写Promise-race方法.html","link":"","permalink":"http://blog.langpz.com/手写Promise-race方法.html","excerpt":"手写Promsie.race方法需求分析Promsie.race方法接收一个参数 Promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型），返回一个新的Promsie数组里其中一个Promise失败或者成功，则将执行对应的回调。就采用第一个 promise 的值作为它的值","text":"手写Promsie.race方法需求分析Promsie.race方法接收一个参数 Promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型），返回一个新的Promsie数组里其中一个Promise失败或者成功，则将执行对应的回调。就采用第一个 promise 的值作为它的值123456789101112131415Promise.myRace = function(list) &#123; return new Promise((resolve, reject) =&gt; &#123; list.map((item, index) =&gt; &#123; // 把数据都处理成Promise Promise.resolve(item).then( res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; reject(err) &#125; ) &#125;) &#125;)&#125;demodemo地址","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://blog.langpz.com/tags/Promise/"}]},{"title":"手写Promsie.all方法","slug":"手写Promsie-all方法","date":"2022-07-27T20:44:39.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"手写Promsie-all方法.html","link":"","permalink":"http://blog.langpz.com/手写Promsie-all方法.html","excerpt":"手写Promsie.all方法需求分析Promsie.all方法接收一个参数 Promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型），返回一个新的Promsie数组里其中一个Promise失败会导致Promise.all 失败所有Promise resolve 回调的结果是一个数组","text":"手写Promsie.all方法需求分析Promsie.all方法接收一个参数 Promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型），返回一个新的Promsie数组里其中一个Promise失败会导致Promise.all 失败所有Promise resolve 回调的结果是一个数组代码实现123456789101112131415161718192021Promise.myAll = function(list) &#123; const results = [] let count = 0 return new Promise((resolve, reject) =&gt; &#123; list.map((item, index) =&gt; &#123; // 把数据都处理成Promise Promise.resolve(item).then( res =&gt; &#123; results[index] = res count += 1 if (count == list.length) &#123; resolve(results) &#125; &#125;, err =&gt; &#123; reject(err) &#125; ) &#125;) &#125;)&#125;demodemo地址参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://blog.langpz.com/tags/Promise/"}]},{"title":"手写简易Promise","slug":"手写简易Promise","date":"2022-06-28T21:32:50.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"手写简易Promise.html","link":"","permalink":"http://blog.langpz.com/手写简易Promise.html","excerpt":"手写简易PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。","text":"手写简易PromisePromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。一个 Promise 必然处于以下几种状态之一：状态改变后是不可逆的。待定（pending）：初始状态，既没有被兑现，也没有被拒绝。已兑现（fulfilled）：意味着操作成功完成。已拒绝（rejected）：意味着操作失败。两个参数resolve, reject 都是函数来改变Promise 状态的。由 JavaScript 引擎提供。resolve() 成功，把Promise状态设置为fulfilled，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。reject() 失败，把Promise状态设置为rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。实现1234567891011121314151617181920212223242526272829303132333435class MyPromise &#123; status = 'pending' resloveQueue = [] rejectQueue = [] constructor(fn) &#123; const reslove = data =&gt; &#123; if(this.status !== 'pending') return; this.status = 'fulfilled'; setTimeout(_ =&gt; &#123; this.resloveQueue.forEach(fnQueue =&gt; &#123; fnQueue &amp;&amp; fnQueue(data) &#125;) &#125;) &#125; const reject = errer =&gt; &#123; if(this.status !== 'pending') return; this.status = 'rejected'; setTimeout(_ =&gt; &#123; this.rejectQueue.forEach(fnQueue =&gt; &#123; fnQueue &amp;&amp; fnQueue(errer) &#125;) &#125;) &#125; fn(reslove, reject) &#125; then(fn, ErrFn) &#123; this.resloveQueue.push(fn) this.rejectQueue.push(ErrFn) return this &#125;&#125;测试123456789101112const p1 = new MyPromise((resolve, reject)=&gt;&#123; console.log('hi2'); if(Math.random()&gt;0.5)&#123; resolve('大') &#125;else&#123; reject('小') &#125;&#125;)p1.then((data)=&gt;&#123;console.log(+ '/' +'成功1')&#125;, (errer)=&gt;&#123;console.log(+ '/' +'失败1')&#125;).then(()=&gt;&#123;console.log('成功2')&#125;, ()=&gt;&#123;console.log('失败2')&#125;).then(()=&gt;&#123;console.log('成功3')&#125;, ()=&gt;&#123;console.log('失败3')&#125;)console.log('end');demodemo地址参考https://es6.ruanyifeng.com/#docs/promise","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://blog.langpz.com/tags/Promise/"}]},{"title":"拯救被墙的ip,v2ray使用cloudflare中转流量","slug":"拯救被墙的ip-v2ray使用cloudflare中转流量","date":"2022-05-25T18:40:58.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"拯救被墙的ip-v2ray使用cloudflare中转流量.html","link":"","permalink":"http://blog.langpz.com/拯救被墙的ip-v2ray使用cloudflare中转流量.html","excerpt":"拯救被墙的ip最近ip又被墙了，只能套cloudflare通过cdn来中转v2ray的WebSocket 流量，搬瓦工付费换ip太贵，也容易继续被墙。坏处就是速度变慢，时不时抽风连不上。v2ray我这里使用的是V2Ray一键安装脚本https://github.com/233boy/v2ray/tree/master","text":"拯救被墙的ip最近ip又被墙了，只能套cloudflare通过cdn来中转v2ray的WebSocket 流量，搬瓦工付费换ip太贵，也容易继续被墙。坏处就是速度变慢，时不时抽风连不上。v2ray我这里使用的是V2Ray一键安装脚本https://github.com/233boy/v2ray/tree/master首先注册一个免费域名https://my.freenom.com/ 最好先注册一个免费的顶级域名。最长一年时间，域名期限在到期14天内可以重复续上一年时间。注：freenom 这个网站的个人信息地址要和申请注册ip地址一样否则申请域名失败。Cloudflarehttps://dash.cloudflare.com/login注册一个账号，然后好给你的域名提供cdn加速。注册完之后添加站点这个时候输入您刚注册的域名。添加域名解析和域名设置自定义dnsCloudflare 找到刚才添加的站点左侧菜单dns，找到Cloudflare 名称服务器会有两个地址，把两个地址添加到 freenom 网站上域名自定义dns 服务器设置上。管理 （你的域名） 的 DNS添加记录，添加一个 A 记录的域名解析，假设你的域名是 langpz.com，并且想要使用 www.langpz.com 作为翻墙的域名。那么在 DNS 那里配置，Name 写 www，IPv4 address 写你的 VPS IP，务必把云朵点灰， 保存解析记录即可。(如果你已经添加域名解析，请务必把云朵点灰。)VPS设置v2ray如果没安装就去安装，安装的改下协议，传输协议选择 WebSocket + TLS (即是选择 4 )，V2Ray 端口随便，不要是 80 和 443 即可，然后输入你的域名，域名解析 Y ，自动配置 TLS 也是 Y ，其他就默认吧，一路回车。等待安装完成。然后输入 v2ray status 查看一下运行状态，请确保 V2Ray 和 Caddy 都在运行收尾然后去dns 解析那里把云朵点亮，再进入左侧菜单SSL/TLS 勾选 完全（严格）v2ray info 或者 v2ray qr 生成 V2Ray 配置二维码链接把配置添加到你的客户端。就可以正常使用了。参考https://github.com/233boy/v2ray/wiki/%E4%BD%BF%E7%94%A8Cloudflare%E4%B8%AD%E8%BD%ACV2Ray%E6%B5%81%E9%87%8F","categories":[],"tags":[{"name":"v2ray","slug":"v2ray","permalink":"http://blog.langpz.com/tags/v2ray/"},{"name":"cloudflare","slug":"cloudflare","permalink":"http://blog.langpz.com/tags/cloudflare/"},{"name":"被墙","slug":"被墙","permalink":"http://blog.langpz.com/tags/被墙/"}]},{"title":"Node.js使用Nodemailer发送邮件通知","slug":"Node-js使用Nodemailer发送邮件通知","date":"2022-02-28T19:53:15.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Node-js使用Nodemailer发送邮件通知.html","link":"","permalink":"http://blog.langpz.com/Node-js使用Nodemailer发送邮件通知.html","excerpt":"Node.js使用Nodemailer发送邮件通知Nodemailer是一个用于 Node.js 应用程序的模块，可以轻松发送电子邮件。支持Windows系统，使用要求Node.js v6.0.0或更新版本。","text":"Node.js使用Nodemailer发送邮件通知Nodemailer是一个用于 Node.js 应用程序的模块，可以轻松发送电子邮件。支持Windows系统，使用要求Node.js v6.0.0或更新版本。安装Nodemailer123yarn add nodemailer ornpm i nodemailer使用这里使用qq邮箱发送邮件，开启SMTP教程12345678910111213141516171819202122const nodemailer = require('nodemailer');// 1.创建一个Nodemailer smtp传输对象transporter = nodemailer.createTransport(&#123; host: 'smtp.qq.com', port: '465', secureConnection: true, secure: false, // true for 465, false for other ports auth: &#123; user:'SMTP邮箱名', pass: 'SMTP授权码' &#125;&#125;);// 2. 配置消息const data = &#123; subject: '标题', from: '发送邮箱' to: '接收邮箱、多邮箱拿，号分割', html: '支持发送html', text: '文本内容'&#125;// 3. 发送transporter.sendMail(data)更多使用方法参考文档参考https://github.com/nodemailer/nodemailer","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"js浮点运算0.1+0.2 = 0.30000000000000004","slug":"js浮点运算0-1-0-2-0-30000000000000004","date":"2021-12-31T19:30:53.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"js浮点运算0-1-0-2-0-30000000000000004.html","link":"","permalink":"http://blog.langpz.com/js浮点运算0-1-0-2-0-30000000000000004.html","excerpt":"js浮点运算0.1+0.2 == 0.30000000000000004由于JavaScript的Number类型为双精度IEEE 754 64位浮点类型。计算的时候会将超出精度部分进行”零舍一入”。导致 0.1+0.2 = 0.30000000000000004，其他采用IEEE 754标准的语言也有误差，可以去这个网站上查看https://0.30000000000000004.com/。","text":"js浮点运算0.1+0.2 == 0.30000000000000004由于JavaScript的Number类型为双精度IEEE 754 64位浮点类型。计算的时候会将超出精度部分进行”零舍一入”。导致 0.1+0.2 = 0.30000000000000004，其他采用IEEE 754标准的语言也有误差，可以去这个网站上查看https://0.30000000000000004.com/。解决方案可以用第三方库来解决，或者如果是一位小数x10后再运算后再除以10decimal.js12let x = new Decimal(0.1)x = x.plus(0.2) // '0.3'demohttps://github.com/MikeMcl/decimal.jsmathjs12let x = math.format(0.1+0.2, &#123;notation: 'fixed', precision: 1&#125;) // '0.3'// precision 保留几位小数demohttps://github.com/josdejong/mathjs参考IEEE 754标准https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"}]},{"title":"vue-cli4配置生产环境删除console.log","slug":"vue-cli4配置生产环境删除console-log","date":"2021-11-26T19:49:17.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue-cli4配置生产环境删除console-log.html","link":"","permalink":"http://blog.langpz.com/vue-cli4配置生产环境删除console-log.html","excerpt":"vue-cli4配置生产环境删除console.log使用 babel-plugin-transform-remove-console 插件去配置删除console.log","text":"vue-cli4配置生产环境删除console.log使用 babel-plugin-transform-remove-console 插件去配置删除console.log安装使用123npm install babel-plugin-transform-remove-console --save-devoryarn add babel-plugin-transform-remove-console -D然后找到src下面的babel.config.js文件修改1234567891011121314const prodPlugins = []// 生产环境添加plugins，排除console.error 和console.warnif (process.env.NODE_ENV === 'production') &#123; prodPlugins.push([\"transform-remove-console\", &#123; \"exclude\": [ \"error\", \"warn\"] &#125;])&#125;module.exports = &#123; presets: [ '@vue/cli-plugin-babel/preset' ], plugins: [ ...prodPlugins ]&#125;参考https://github.com/babel/minify/tree/master/packages/babel-plugin-transform-remove-console","categories":[],"tags":[{"name":"vue-cli4","slug":"vue-cli4","permalink":"http://blog.langpz.com/tags/vue-cli4/"}]},{"title":"vue3中引入element-plus的Icon","slug":"vue3中引入element-plus的Icon","date":"2021-11-20T10:52:58.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue3中引入element-plus的Icon.html","link":"","permalink":"http://blog.langpz.com/vue3中引入element-plus的Icon.html","excerpt":"vue3中引入element-plus的Icon最近使用element-plus开发项目，发现element-plus废弃了Font Icon 使用了 SVG Icon。需要在全局注册组件，或者按需引用。","text":"vue3中引入element-plus的Icon最近使用element-plus开发项目，发现element-plus废弃了Font Icon 使用了 SVG Icon。需要在全局注册组件，或者按需引用。安装123$ yarn add @element-plus/icons# 或者$ npm install @element-plus/icons全局引用在main.js 全局注册组件。123456789101112import * as Icons from '@element-plus/icons'const app = createApp(App)// 注册Icons 全局组件Object.keys(Icons).forEach(key =&gt; &#123; app.component(key, Icons[key])&#125;)// 在vue文件使用&lt;el-icon color=\"#409EFC\" class=\"no-inherit\"&gt; &lt;share /&gt;&lt;/el-icon&gt;就可以在vue文件里面直接使用图标了。按需引用对应的vue文件中直接import图标。123456import &#123; Edit &#125; from '@element-plus/icons'// 在vue文件使用&lt;el-icon color=\"#409EFC\" class=\"no-inherit\"&gt; &lt;edit /&gt;&lt;/el-icon&gt;参考https://element-plus.gitee.io/zh-CN/component/icon.html","categories":[],"tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"http://blog.langpz.com/tags/vue3-0/"},{"name":"element-plus","slug":"element-plus","permalink":"http://blog.langpz.com/tags/element-plus/"}]},{"title":"js函数防抖和节流的区别和代码实现","slug":"js函数防抖和节流的区别和代码实现","date":"2021-10-24T13:13:10.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"js函数防抖和节流的区别和代码实现.html","link":"","permalink":"http://blog.langpz.com/js函数防抖和节流的区别和代码实现.html","excerpt":"js函数防抖和节流的区别","text":"js函数防抖和节流的区别函数防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。例如游戏角色放技能被打断了，然后重新释放技能，重新计算释放时间。函数节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。就相当于游戏角色有霸体释放技能无法被打断。3秒一个技能，不管中间发生了什么。防抖函数1234567891011function debounce(fn, delay) &#123; var timer = null; return function() &#123; clearTimeout(timer); var that = this, args = arguments; timer = setTimeout(function() &#123; fn.apply(that, args) &#125;, delay) &#125;&#125;一般用于input或者srcoll事件上。输入框搜索防止输入过快向后端发很多个请求，就是限制多长时间才能执行一次。重复操作会重新计算时间。节流函数1234567891011121314151617function throttle(fn, delay) &#123; var timer = null, flag = false; return function() &#123; if (flag) &#123; return &#125; flag = true var that = this, args = arguments; timer = setTimeout(function() &#123; clearTimeout(timer); flag = false fn.apply(that, args) &#125;, delay) &#125;&#125;一般用于mousemove或者resize事件上，避免触发N次事件，限制多少毫秒内只能执行一次，提高性能。demohttps://jsbin.com/budazewure/edit?html,console,output","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.langpz.com/tags/面试题/"}]},{"title":"vue3的生命周期","slug":"vue3的生命周期","date":"2021-10-16T15:56:13.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue3的生命周期.html","link":"","permalink":"http://blog.langpz.com/vue3的生命周期.html","excerpt":"vue3的生命周期vue3的生命周期对比vue2没有大的改变，只有beforeDestroy和destroyed换了名字，换成beforeUnmount和unmounted。注：如果在组合式API里面使用生命周期的变动就多了。","text":"vue3的生命周期vue3的生命周期对比vue2没有大的改变，只有beforeDestroy和destroyed换了名字，换成beforeUnmount和unmounted。注：如果在组合式API里面使用生命周期的变动就多了。生命周期图示vue2生命周期https://blog.langpz.com/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html参考https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA","categories":[],"tags":[{"name":"vue3.0","slug":"vue3-0","permalink":"http://blog.langpz.com/tags/vue3-0/"},{"name":"生命周期","slug":"生命周期","permalink":"http://blog.langpz.com/tags/生命周期/"}]},{"title":"切换node版本项目Saas报错","slug":"切换node版本项目Saas报错","date":"2021-09-24T21:18:41.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"切换node版本项目Saas报错.html","link":"","permalink":"http://blog.langpz.com/切换node版本项目Saas报错.html","excerpt":"切换node版本项目Saas报错Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime","text":"切换node版本项目Saas报错Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime解决方案123yarn add --force node-sassornpm rebuild node-sass如果还不能运行，建议先卸载node-sass再重新安装。123npm uninstall node-sass &amp;&amp; npm install node-sassoryarn remove node-sass &amp;&amp; yarn add node-sass --dev参考https://stackoverflow.com/questions/37415134/error-node-sass-does-not-yet-support-your-current-environment-windows-64-bit-w","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.langpz.com/tags/yarn/"}]},{"title":"js获取图片文件宽度和高度","slug":"js获取图片文件宽度和高度","date":"2021-08-29T10:15:39.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"js获取图片文件宽度和高度.html","link":"","permalink":"http://blog.langpz.com/js获取图片文件宽度和高度.html","excerpt":"js获取图片文件宽度和高度这里利用FileReader对象来获取图片宽高。","text":"js获取图片文件宽度和高度这里利用FileReader对象来获取图片宽高。代码如下1234567891011const reader = new FileReader()// 获取base64格式字符串文件内容reader.readAsDataURL(file)reader.onload = function(data) &#123; const img = new Image() img.src = data.target.result let that = this img.onload = function() &#123; console.log(this.width, this.height) &#125;&#125;demohttps://jsbin.com/xalukapolu/edit?html,console,output参考https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"}]},{"title":"css粘性定位实现table表头和列固定","slug":"css实现table表头和列固定","date":"2021-08-22T21:12:07.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"css实现table表头和列固定.html","link":"","permalink":"http://blog.langpz.com/css实现table表头和列固定.html","excerpt":"css实现table表头和列固定需求分析：实现table表头和固定列定位，滚动位置不变，这里采用positons: sticky粘性定位来实现。","text":"css实现table表头和列固定需求分析：实现table表头和固定列定位，滚动位置不变，这里采用positons: sticky粘性定位来实现。样式代码具体结构去看demo12345678910111213141516171819202122232425262728293031323334353637#table &#123; width: 300px; height: 300px; overflow: auto; border: 1px solid;&#125;#table div &#123; width: 50px; height: 50px; text-align: center;&#125;#table thead div&#123; background: red&#125;#table tbody td:first-child div &#123; background: yellow;&#125;#table thead th &#123; position: sticky; top: 0;&#125;#table thead th &#123; position: sticky; top: 0; z-index: 2&#125;#table tbody td:first-child,#table thead th:first-child &#123; position: sticky; left: 0;&#125;#table thead th:first-child &#123; z-index: 3&#125;直接设置position: sticky; left和top就可以实现了，注意，一个sticky元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是最近的真实可滚动祖先。demo参考https://developer.mozilla.org/zh-CN/docs/Web/CSS/position","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"webpack内存溢出","slug":"webpack内存溢出","date":"2021-07-03T18:37:50.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"webpack内存溢出.html","link":"","permalink":"http://blog.langpz.com/webpack内存溢出.html","excerpt":"webpack内存溢出当项目过大的时候就会碰见内存溢出问题。","text":"webpack内存溢出当项目过大的时候就会碰见内存溢出问题。更新从 2017 年 8 月发布的 Node.js v8.0 开始，您现在可以使用NODE_OPTIONS 环境变量来全局设置 max_old_space_size。123export NODE_OPTIONS=--max-old-space-size=4096// windows使用set NODE_OPTIONS=--max-old-space-size=4096或者使用cross-env来解决平台不同命令不同12npm install -g cross-envcross-env NODE_OPTIONS=--max-old-space-size=4096vue-cli2.0解决方案修改package.json文件（兼容windows和macOS本）1234\"scripts\": &#123; \"dev\": \"node --max_old_space_size=4096 node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js\", \"build\": \"node -max_old_space_size=4096 build/build.js\", &#125;,参考https://github.com/endel/increase-memory-limithttps://github.com/kentcdodds/cross-env","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.langpz.com/tags/webpack/"}]},{"title":"nativefier 一行命令生成桌面应用","slug":"nativefier-一行命令生成桌面应用","date":"2020-06-27T14:53:57.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"nativefier-一行命令生成桌面应用.html","link":"","permalink":"http://blog.langpz.com/nativefier-一行命令生成桌面应用.html","excerpt":"nativefier 一行命令生成桌面应用nativefier 可以快速生成可执行文件（.app，.exe，等），在Windows，MacOS和Linux的使用。","text":"nativefier 一行命令生成桌面应用nativefier 可以快速生成可执行文件（.app，.exe，等），在Windows，MacOS和Linux的使用。安装Node.js 版本要 &gt;= 101npm install nativefier -g使用打包一个百度的桌面应用1nativefier \"https://www.baidu.com/\"然后会在执行命令目录下生成APP-win32-x64 文件夹，进入然后打开APP.exe，一个百度的桌面版就打包好了，可以打包任意网站。注意事项因为这个是基于Electron打包的，执行命名要下载Electron 有的时候会下载失败导致打包失败。解决方案设置国内源1npm set ELECTRON_MIRROR=\"https://npm.taobao.org/mirrors/electron/\"参考https://github.com/jiahaog/nativefier","categories":[],"tags":[{"name":"nativefier","slug":"nativefier","permalink":"http://blog.langpz.com/tags/nativefier/"}]},{"title":"解决node-sass安装失败","slug":"解决node-sass安装失败","date":"2020-06-14T20:21:00.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"解决node-sass安装失败.html","link":"","permalink":"http://blog.langpz.com/解决node-sass安装失败.html","excerpt":"解决node-sass安装失败node-sass 安装时需要下载一个node-sass …binding.node 文件，所以设置了淘宝源还是经常安装失败。还需要配置 sass_binary_site","text":"解决node-sass安装失败node-sass 安装时需要下载一个node-sass …binding.node 文件，所以设置了淘宝源还是经常安装失败。还需要配置 sass_binary_site最新方案mirror-config-china 为中国内地的Node.js开发者准备的镜像配置，大大提高node模块安装速度。特性支持Windows和其他操作系统自动配置各个node模块的安装源为淘宝镜像1npm install -g mirror-config-china --registry=https://registry.npmmirror.comhttps://github.com/gucong3000/mirror-config-china不推荐使用https://registry.npmmirror.com/mirrors/node-sass 无法正常获取到模块了使用新地址https://registry.npmmirror.com/binary.html?path=node-sass/12345yarn config set registry https://registry.npmmirror.comyarn config set sass_binary_site https://registry.npmmirror.com/binary.html?path=node-sass/或者npm set registry https://registry.npmmirror.comnpm set sass_binary_site https://registry.npmmirror.com/binary.html?path=node-sass/","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.langpz.com/tags/yarn/"}]},{"title":"Git版本回退","slug":"Git版本回退","date":"2019-06-09T18:04:28.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Git版本回退.html","link":"","permalink":"http://blog.langpz.com/Git版本回退.html","excerpt":"Git版本回退在工作中会碰见这个功能不要了，回退到上一个版本、或者merge错分支，下面简单记录下如何解决这些问题。","text":"Git版本回退在工作中会碰见这个功能不要了，回退到上一个版本、或者merge错分支，下面简单记录下如何解决这些问题。回退指定commit12git loggit reset --hard 版本号git log 查看之前提交的commit版本号，然后执行回退。回退命令12git refloggit reset --hard 版本号git reflog 查看之前执行命令版本号，然后执行回退。cherry-pick还有一种场景， 比如有三个commit，保留1和3，2舍去这个时候就要用到 cherry-pick123git reflog git reset --hard 1的版本号git cherry-pick 3的版本号git reflog 找到commit 1和3的版本号 回退到第一个版本，然后再执行cherry-pick把3的修改合并到1里，如果有冲突就解决冲突。已经提交远端仓库12git reset --hard 版本号git push -f origin/远端分支先回退版本，然后强制推送到远端仓库。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"给项目加一个骨架屏吧","slug":"给项目加一个骨架屏吧","date":"2019-04-27T16:07:19.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"给项目加一个骨架屏吧.html","link":"","permalink":"http://blog.langpz.com/给项目加一个骨架屏吧.html","excerpt":"给项目加一个骨架屏吧骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径。用户会看到一个样式简单，描绘了当前页面的大致框架的骨架屏页面，然后骨架屏中各个占位部分被实际资源完全替换，这个过程中用户会觉得内容正在逐渐加载即将呈现，降低了用户的焦躁情绪，使得加载过程主观上变得流畅。","text":"给项目加一个骨架屏吧骨架屏可以理解为是当数据还未加载进来前，页面的一个空白版本，一个简单的关键渲染路径。用户会看到一个样式简单，描绘了当前页面的大致框架的骨架屏页面，然后骨架屏中各个占位部分被实际资源完全替换，这个过程中用户会觉得内容正在逐渐加载即将呈现，降低了用户的焦躁情绪，使得加载过程主观上变得流畅。安装这里采用饿了么开源的方案page-skeleton-webpack-plugin。12npm install --save-dev page-skeleton-webpack-pluginnpm install --save-dev html-webpack-plugin安装过程中报错提示如下12ERROR: Failed to download Chromium r515411! Set \"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD\" env variable to skip download.执行这个命令1npm config set puppeteer_download_host=https://storage.googleapis.com.cnpmjs.org使用我这个项目是基于vue-cli3脚手架开发的。第一步配置插件创建一个vue.config.js文件。123456789101112131415161718192021222324const &#123; SkeletonPlugin &#125; = require('page-skeleton-webpack-plugin')const path = require('path')module.exports = &#123; configureWebpack: &#123; plugins: [ new SkeletonPlugin(&#123; pathname: path.resolve(__dirname, './shell'), // 用来存储 shell 文件的地址 staticDir: path.resolve(__dirname, './dist'), // 最好和 `output.path` 相同 routes: ['/'], // 将需要生成骨架屏的路由添加到数组中 excludes: ['.van-nav-bar', '.van-tabbar'] // 需要忽略的css选择器 &#125;) ], &#125;, chainWebpack: (config) =&gt; &#123; // 解决vue-cli3脚手架创建的项目压缩html 干掉&lt;!-- shell --&gt;导致骨架屏不生效 if (process.env.NODE_ENV !== 'development') &#123; config.plugin('html').tap(opts =&gt; &#123; opts[0].minify.removeComments = false return opts &#125;) &#125; &#125;,&#125;;在项目根目录下面创建一个shell文件夹。chainWebpack配置 这个是解决vue-cli3打包的骨架屏不生效的BUG第二步修改 HTML Webpack Plugin 插件的模板在你启动 App 的根元素内部添加1234&lt;body&gt; &lt;div id=\"app\"&gt;&lt;!-- shell --&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;第三步：界面操作生成、写入骨架页面在开发页面中通过 Ctrl|Cmd + enter 呼出插件交互界面，或者在在浏览器的 JavaScript 控制台内输入toggleBar 呼出交互界面。点击交互界面中的按钮，进行骨架页面的预览，这一过程可能会花费 20s 左右时间，当插件准备好骨架页面后，会自动通过浏览器打开预览页面扫描预览页面中的二维码，可在手机端预览骨架页面，可以在预览页面直接编辑源码，通过点击右上角写入按钮，将骨架页面写入到 shell 文件夹中。通过 webpack 重新打包应用，当页面重新启动后，就能够在获取到数据前看到应用的骨架结构了。最终效果参考https://github.com/cnpm/cnpmjs.org/issues/1246https://github.com/ElemeFE/page-skeleton-webpack-plugin","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"骨架屏","slug":"骨架屏","permalink":"http://blog.langpz.com/tags/骨架屏/"}]},{"title":"发布一个自己的NPM包","slug":"发布一个自己的NPM包","date":"2019-04-18T20:01:57.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"发布一个自己的NPM包.html","link":"","permalink":"http://blog.langpz.com/发布一个自己的NPM包.html","excerpt":"发布一个自己的NPM包用了这么多次别人发布的包，今天咱们自己发布一个npm包","text":"发布一个自己的NPM包用了这么多次别人发布的包，今天咱们自己发布一个npm包首先检查npm源123npm get registry# 如果不是这个地址https://registry.npmjs.org 需要设置官网源npm config set registry https://registry.npmjs.org如果是使用第三方源请设置npm官方源 (注)：第三方源只提供下载功能创建模块1234567891011121314151617181920212223242526272829303132npm init # package.json 内容&#123; \"name\": \"isnumber-lpz\", \"version\": \"1.0.0\", \"description\": \"Number\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[D\\u001b[C\\u001b[C\\u001b[Cis\\u001b[C\\u001b[C\\u001b[Number\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/lanpangzhi/isNumber-lpz.git\" &#125;, \"author\": \"lanpangzhi\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/lanpangzhi/isNumber-lpz/issues\" &#125;, \"homepage\": \"https://github.com/lanpangzhi/isNumber-lpz#readme\"&#125;# 创建 index.jstouch index.jsfunction isNumber(number) &#123; number = parseFloat(number) return number === number &amp;&amp; typeof number === 'number' &#125;module.exports = isNumbernpm使用介绍里面有里面的字段，这里就省略了，(注)：包的name不要重名建议先去[https://www.npmjs.com/](https://www.npmjs.com/)搜索下注册npm账号（有账号跳过这步）npm adduser用于在npmjs.com注册一个用户。1234567npm adduser# Username: 用户名# Password: 密码# Email: 邮箱# 登录npm login发布包1npm publish(注)：发布的时候版本号要和上次的不一样，默认的发布标签是latest、前模块是一个beta版，比如2.1.1-beta，那么发布的时候需要使用tag参数安装并使用12345678npm i isnumber-lpzconst isNumber = require('isnumber-lpz')console.log('12', isNumber(12)) trueconsole.log('12.2', isNumber(12.2)) trueconsole.log('x12.2', isNumber('x12.2')) falseconsole.log('xacsa', isNumber('xacsa')) falsedemo 地址https://github.com/lanpangzhi/isNumber-lpz","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"Hexo博客从Coding迁移到腾讯云COS","slug":"Hexo博客从Coding迁移到腾讯云COS","date":"2019-03-30T17:34:07.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Hexo博客从Coding迁移到腾讯云COS.html","link":"","permalink":"http://blog.langpz.com/Hexo博客从Coding迁移到腾讯云COS.html","excerpt":"Hexo博客从Coding迁移到腾讯云COS最近coding的Pages 服务一直不稳定，这两天访问还出现404，重新部署也无法解决。国内访问GitHub Pages 不是很快，而且百度SEO也爬不到。码云自定义域名收费，只好迁移到腾讯云COS上了。","text":"Hexo博客从Coding迁移到腾讯云COS最近coding的Pages 服务一直不稳定，这两天访问还出现404，重新部署也无法解决。国内访问GitHub Pages 不是很快，而且百度SEO也爬不到。码云自定义域名收费，只好迁移到腾讯云COS上了。创建存储桶https://console.cloud.tencent.com/cos5/bucket 首先要创建存储桶。区域看各自情况任选，访问权限必须要选择公有读私有写。在基础设置开启静态网站索引文档一定要填index.html，错误文档就看自定义的是什么文件了。在域名管理开启自定义加速域名（CDN加速）填写上自己的域名就可以了。域名解析在域名解析这里添加上刚才配置的自定义加速域名的CNAME地址。安装发布COS插件1npm install hexo-deployer-cos-enhanced-dev --save配置_config.yml把之前deploy的配置替换掉1234567891011121314deploy: type: cos bucket: blog-1251123456 region: ap-shanghai secretId: AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX secretKey: qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdR cdnConfig: enable: true cdnUrl: http://yourCdnSite.com bucket: static-1251123456 region: ap-shanghai folder: static-1251123456 secretId: AKIDIgxxxxxxxxxxxxxxxxxxxx0SepjX secretKey: qXPCbxxxxxxxxxxxxxxxxxxxxsJZfdRsecretId secretKey 包括cdnConfig下面这两个字段都可以不用填写， 直接从环境变量取type： 是固定死的，只能是 cos。cdnUrl： 是你的对象存储绑定的CDN域名，没有启用 CDN的话，推荐使用 https://github.com/sdlzhd/hexo-deployer-cosbucket 和 region： 在腾讯云的对象存储中，新建或找到你的 bucket，然后找到 默认域名 信息，会看到一个类似这样的域名: blog-1251123456.cos.ap-shanghai.myqcloud.com，第一个点前面的 blog-1251123456 就是 bucket 名称，第二个点和第三个点之间的 ap-shanghai，就是你的 COS 所在地域，填写到 region 中。secretId 和 secretKey：在 COS控制台中，找到左侧的密钥管理，点进去，按照提示添加子账号，并设置秘钥。同时要给子账号赋予 COS相关的权限，还有CDN刷新的权限。不会配置的可以参考 官方示例1hexo d直接就发布到腾讯云COS上了，访问速度相当快，对SEO也好。添加持续集成自动发布到COS（Travis CI）我的博客使用Travis CI，而且备份也是在GitHub公开仓库， secretId secretKey 这两个字段我只能写到Travis CI环境变量里面。123456script - hexo denv: global: - SecretId: $&#123;SecretId&#125; - SecretKey: $&#123;SecretKey&#125;只需要在.travis.yml 文件 script 下面加 hexo d 全局变量增加SecretId和SecretKey 这两个变量。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"},{"name":"COS","slug":"COS","permalink":"http://blog.langpz.com/tags/COS/"}]},{"title":"vue-cli3设置默认打开浏览器","slug":"vue-cli3设置默认打开浏览器","date":"2019-03-24T11:11:19.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue-cli3设置默认打开浏览器.html","link":"","permalink":"http://blog.langpz.com/vue-cli3设置默认打开浏览器.html","excerpt":"vue-cli3设置默认打开浏览器vue-cli3设置默认打开浏览器","text":"vue-cli3设置默认打开浏览器vue-cli3设置默认打开浏览器项目根目录找到package.json文件， 找到scripts 里 serve 后面加上 –open, 本地开发的时候就会自动打开浏览器了。","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"cli","slug":"cli","permalink":"http://blog.langpz.com/tags/cli/"}]},{"title":"centos7安装MySQL","slug":"centos7安装MySQL","date":"2019-03-17T18:09:33.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"centos7安装MySQL.html","link":"","permalink":"http://blog.langpz.com/centos7安装MySQL.html","excerpt":"centos7安装MySQL先去MySQL官网找到下载链接(https://dev.mysql.com/downloads/repo/yum/)","text":"centos7安装MySQL先去MySQL官网找到下载链接(https://dev.mysql.com/downloads/repo/yum/)下载安装执行下面的命令下载并安装MySQL1234wget http://repo.mysql.com/mysql80-community-release-el7-2.noarch.rpmrpm -Uvh mysql80-community-release-el7-2.noarch.rpmyum updateyum install mysql-community-server启动MySQL服务器执行下面的命令启动MySQL1service mysqld start执行下面的命令检测MySQL状态1service mysqld status参考https://dev.mysql.com/downloads/repo/yum/","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"在vue使用clipboard.js","slug":"在vue使用clipboard-js","date":"2018-12-23T11:30:36.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"在vue使用clipboard-js.html","link":"","permalink":"http://blog.langpz.com/在vue使用clipboard-js.html","excerpt":"在vue使用clipboard.js上一篇写了怎么使用clipboard.js，今天就写下怎么在vue里面使用clipboard.js","text":"在vue使用clipboard.js上一篇写了怎么使用clipboard.js，今天就写下怎么在vue里面使用clipboard.js安装有人已经封装好vue插件了我们直接安装使用就好1npm install --save vue-clipboard2使用1234import Vue from 'vue'import VueClipboard from 'vue-clipboard2'Vue.use(VueClipboard)例子指令形式的123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;template id=\"t\"&gt; &lt;div class=\"container\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;button type=\"button\" v-clipboard:copy=\"message\" v-clipboard:success=\"done\"&gt;Copy!&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;new Vue(&#123; el: '#app', template: '#t', data: function () &#123; return &#123; message: 'vbook.langpz.com' &#125; &#125;, methods: &#123; done: function () &#123; alert('Copied成功!') &#125; &#125;&#125;)&lt;/script&gt;v-clipboard:copy 这里放你要复制的内容v-clipboard:success 复制成功调用的回调方法形式的12let container = this.$refs.containerthis.$copyText(\"Text to copy\", container) // 返回一个Promise你可以通过use的时候设置container为当前元素12345import Vue from 'vue'import VueClipboard from 'vue-clipboard2'VueClipboard.config.autoSetContainer = true // 默认falseVue.use(VueClipboard)参考https://github.com/Inndy/vue-clipboard2","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog.langpz.com/tags/移动端/"},{"name":"vue2.0，clipboard.js","slug":"vue2-0，clipboard-js","permalink":"http://blog.langpz.com/tags/vue2-0，clipboard-js/"}]},{"title":"移动端js复制内容到剪贴板","slug":"移动端js复制内容到剪贴板","date":"2018-12-19T20:14:17.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"移动端js复制内容到剪贴板.html","link":"","permalink":"http://blog.langpz.com/移动端js复制内容到剪贴板.html","excerpt":"移动端js复制内容到剪贴板clipboard.js是一个没有Flash。没有框架。只需3kb gzipped，实现了将文本复制到剪贴板。兼容性做得好，不兼容的话clipboard.js会优雅地降级，会自动选中文本，用户可以自己选择复制。","text":"移动端js复制内容到剪贴板clipboard.js是一个没有Flash。没有框架。只需3kb gzipped，实现了将文本复制到剪贴板。兼容性做得好，不兼容的话clipboard.js会优雅地降级，会自动选中文本，用户可以自己选择复制。兼容性42+ ✔12+ ✔41+ ✔9+ ✔29+ ✔10+ ✔安装1npm install clipboard --save或者可以用cdn地址使用12345678910111213141516171819202122从属性复制文本&lt;button class=\"btn\" data-clipboard-text=\"http://blog.langpz.com\"&gt; 复制&lt;/button&gt;从另一个元素复制文本&lt;input id=\"foo\" value=\"https://github.com/lanpangzhi\"&gt;&lt;button class=\"btn\" data-clipboard-target=\"#foo\"&gt; 复制&lt;/button&gt;从另一个元素剪切文本&lt;input id=\"xxx\" value=\"https://api.langpz.com\"&gt;&lt;button class=\"btn\" data-clipboard-action=\"cut\" data-clipboard-target=\"#xxx\"&gt; 复制&lt;/button&gt;&lt;script&gt; new ClipboardJS('.btn') // 传入dom节点实例化ClipboardJS&lt;/script&gt;data-clipboard-text: 需要复制的内容data-clipboard-target: 需要复制内容的选择器data-clipboard-action: 默认copy, 复制的动作，仅适用于input或textarea元素demo地址clipboard 还可以绑定success 和 error 事件1234567891011121314151617181920&lt;button class=\"btn\" data-clipboard-text=\"http://blog.langpz.com\"&gt; 复制&lt;/button&gt; &lt;script&gt; var clipboard = new ClipboardJS('.btn');clipboard.on('success', function(e) &#123; console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); e.clearSelection();&#125;);clipboard.on('error', function(e) &#123; console.error('Action:', e.action); console.error('Trigger:', e.trigger);&#125;);&lt;/script&gt;e.action: 复制的动作e.text: 复制的内容e.trigger: 触发的domdemo地址clipboard 还有一些高级用法，建议去官网查看。参考https://clipboardjs.com/","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog.langpz.com/tags/移动端/"},{"name":"javascript，clipboard.js","slug":"javascript，clipboard-js","permalink":"http://blog.langpz.com/tags/javascript，clipboard-js/"}]},{"title":"centos7安装MongoDB","slug":"centos7安装mongodb","date":"2018-12-16T19:22:11.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"centos7安装mongodb.html","link":"","permalink":"http://blog.langpz.com/centos7安装mongodb.html","excerpt":"centos7安装MongoDB先去MongoDB官网的文档中的Install on Red Hat，检查是否有更新，当前MongoDB版本4.0。","text":"centos7安装MongoDB先去MongoDB官网的文档中的Install on Red Hat，检查是否有更新，当前MongoDB版本4.0。配置包管理系统（yum）12cd /etc/yum.repos.d/ // 进入这个目录touch mongodb-org-4.0.repo // 创建一个新的YUM存储库配置文件vim 编辑 mongodb-org-4.0.repo 然后把如下代码复制到文件里123456[mongodb-org-4.0]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-4.0.ascESC :wq 退出并保存安装1sudo yum install -y mongodb-orgmongodb-org-server- mongod守护程序，以及相应的init脚本和配置。mongodb-org-mongos- mongos守护进程。mongodb-org-shell - mongo shell，一个MongoDB的交互式JavaScript接口，用于执行命令行的管理任务。mongodb-org-tools - 包含几个MongoDB工具，用于导入和导出数据，统计信息以及其他实用程序。启动MongoDB安装完成后，启动MongoDB123sudo service mongod start // 启动sudo service mongod stop // 停止sudo service mongod restart // 重启设置MongoDB将在系统重新启动后启动1sudo chkconfig mongod on验证是否安装成功12mongodb.version() // 会出现版本号，我这里是4.0.4参考https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/#configure-the-package-management-system-yumhttps://linuxize.com/post/how-to-install-mongodb-on-centos-7/","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.langpz.com/tags/MongoDB/"}]},{"title":"pm2开机自启","slug":"pm2开机自启","date":"2018-11-20T09:40:00.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"pm2开机自启.html","link":"","permalink":"http://blog.langpz.com/pm2开机自启.html","excerpt":"pm2开机自启123pm2 start # 你要启动的程序，如果有多个都要先启动pm2 savepm2 startup执行代码，重启服务器pm2会自动启动。","text":"pm2开机自启123pm2 start # 你要启动的程序，如果有多个都要先启动pm2 savepm2 startup执行代码，重启服务器pm2会自动启动。https://cnodejs.org/topic/556f02a98ce3684b284b55ad","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"pm2","slug":"pm2","permalink":"http://blog.langpz.com/tags/pm2/"}]},{"title":"centos7开机自启nginx","slug":"centos7开机自启nginx","date":"2018-11-20T09:39:26.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"centos7开机自启nginx.html","link":"","permalink":"http://blog.langpz.com/centos7开机自启nginx.html","excerpt":"centos7开机自启nginx1sudo systemctl enable nginx.service执行代码，会有提示然后重启服务器nginx会自动启动。","text":"centos7开机自启nginx1sudo systemctl enable nginx.service执行代码，会有提示然后重启服务器nginx会自动启动。参考https://segmentfault.com/q/1010000002889260","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://blog.langpz.com/tags/nginx/"}]},{"title":"element-ui里Table组件多选，翻页记忆选中复选框","slug":"element-ui里Table组件多选，翻页记忆选中复选框","date":"2018-11-13T21:42:31.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"element-ui里Table组件多选，翻页记忆选中复选框.html","link":"","permalink":"http://blog.langpz.com/element-ui里Table组件多选，翻页记忆选中复选框.html","excerpt":"element-ui里Table组件分页记忆选中复选框需求分析：Table组件复选框选中后切换页码重新获取数据之前选中不丢失。","text":"element-ui里Table组件分页记忆选中复选框需求分析：Table组件复选框选中后切换页码重新获取数据之前选中不丢失。使用Table组件里面reserve-selection和row-key来实现需求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;template&gt; &lt;el-table ref=\"multipleTable\" :data=\"tableData3\" // 这里设置row-key :row-key=\"getRowKeys\" style=\"width: 100%\" @selection-change=\"handleSelectionChange\"&gt; &lt;el-table-column type=\"selection\" // 这里设置reserve-selection为 true :reserve-selection=\"true\" width=\"55\"&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"日期\" width=\"120\"&gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; scope.row.date &#125;&#125;&lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"name\" label=\"姓名\" width=\"120\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"address\" label=\"地址\" show-overflow-tooltip&gt; &lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; tableData3: [&#123; date: '2016-05-03', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-04', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-01', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-08', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-06', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;, &#123; date: '2016-05-07', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' &#125;] &#125;, // 返回id设置row-key getRowKeys(row) &#123; return row.id; &#125;, &#125; &#125;&lt;/script&gt;在使用 reserve-selection 功能的情况下 row-key这个属性是必填的。上面的代码就可以实现翻页选中状态不消失，分页的逻辑我就不写了。参考https://element.eleme.io/#/zh-CN/component/table","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"element-ui","slug":"element-ui","permalink":"http://blog.langpz.com/tags/element-ui/"}]},{"title":"Git拉取远程分支到本地","slug":"Git拉取远程分支到本地","date":"2018-10-25T20:42:31.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Git拉取远程分支到本地.html","link":"","permalink":"http://blog.langpz.com/Git拉取远程分支到本地.html","excerpt":"Git拉取远程分支到本地经常会碰见拉取远端的分支到本地，步骤和命令经常记不住所以只好做个笔记。","text":"Git拉取远程分支到本地经常会碰见拉取远端的分支到本地，步骤和命令经常记不住所以只好做个笔记。拉取分支首先你得先查看你是否和远端的仓库建立连接。1git remote -v如果没有的话那就自行添加一下1git remote add origin xxxx(你远程分支的git仓库地址)如果每天要提交代码 ，可以绕过上面这一步，直接切换分支1git checkout -b Q3 origin/Q3这个时候操作失败提示如下：fatal: ‘origin/Q3’ is not a commit and a branch ‘Q3’ cannot be created from it代表你本地没有Q3这个远程分支。可以执行 git branch -r 来检查本地是否有Q3远程分支。拉取远程分支到本地并切换分支。12git fetch origin Q3git checkout -b Q3 origin/Q3拉取远程分支到本地1git pull origin Q3参考https://curder.gitbooks.io/blog/git/remote_repository_pull.html","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"vue（scoped）修改UI库组件样式","slug":"vue修改UI库组件样式","date":"2018-09-15T16:40:59.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue修改UI库组件样式.html","link":"","permalink":"http://blog.langpz.com/vue修改UI库组件样式.html","excerpt":"vue修改UI库组件样式在工作中经常会碰见设计稿和UI库的组件样式不一样，在style标签加了scoped，就无法修改UI组件的样式了，因为当前组件样式只应用到这个组件上。","text":"vue修改UI库组件样式在工作中经常会碰见设计稿和UI库的组件样式不一样，在style标签加了scoped，就无法修改UI组件的样式了，因为当前组件样式只应用到这个组件上。深度作用选择器如果你想修改组件的样式就可以使用 &gt;&gt;&gt; 操作符：123&lt;style scoped&gt;.langpz &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt;上述代码将会编译成：1.langpz[data-v-f3f3eg9] .b &#123; /* ... */ &#125;如果你用的是SCSS或者LESS需要把 &gt;&gt;&gt; 替换成 /deep/如果组件的样式是js动态生成的，深度作用选择器前面就不要跟class了。参考https://vue-loader.vuejs.org/zh/guide/scoped-css.html#%E6%B7%B7%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%92%8C%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"}]},{"title":"node定时任务","slug":"node定时任务","date":"2018-07-08T18:09:23.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"node定时任务.html","link":"","permalink":"http://blog.langpz.com/node定时任务.html","excerpt":"node定时任务我们再开发过程中，会经常碰见这样的场景例如每天早上八点执行一个操作或者执行一个爬虫，下面就说一下如何用node-cron处理这些定时任务。","text":"node定时任务我们再开发过程中，会经常碰见这样的场景例如每天早上八点执行一个操作或者执行一个爬虫，下面就说一下如何用node-cron处理这些定时任务。安装node-cron1npm i cron -S使用cron值的范围。Seconds: 0-59 (秒)Minutes: 0-59 (分钟)Hours: 0-23 (小时)Day of Month: 1-31 (天)Months: 0-11 (Jan-Dec) (月)Day of Week: 0-6 (Sun-Sat) (星期)每隔十秒执行一次123456789var CronJob = require('cron').CronJob;var job = new CronJob('*/10 * * * * *', function() &#123; console.log(\"执行了\") &#125;, function () &#123; /* 定时任务停止时执行此功能 */ &#125;, true /* 马上开始定时任务 */);每个工作日早上7点执行一次123456789var CronJob = require('cron').CronJob;var job = new CronJob('00 00 7 * * 1-5', function() &#123; console.log(\"执行了\") &#125;, function () &#123; /* 定时任务停止时执行此功能 */ &#125;, true /* 马上开始定时任务 */);手动执行定时任务1234567891011121314var cron = require('cron');var job1 = new cron.CronJob(&#123; cronTime: '* * * * * *', onTick: function() &#123; console.log('开始工作'); &#125;, onComplete: function() &#123; console.log('停止工作') &#125;, start: false&#125;);// 执行job1定时任务job1.start();手动停止定时任务123456789101112131415161718var cron = require('cron');var job1 = new cron.CronJob(&#123; cronTime: '* * * * * *', onTick: function() &#123; console.log('开始工作'); &#125;, onComplete: function() &#123; console.log('停止工作') &#125;, start: false&#125;);job1.start()setTimeout(() =&gt; &#123; // 五秒钟后停止定时任务并触发停止回调 job1.stop();&#125; ,5002);捕获异常1234567try &#123; new CronJob('invalid cron pattern', function() &#123; console.log('this should not be printed'); &#125;)&#125; catch(ex) &#123; console.log(\"cron pattern not valid\");&#125;以上提供了几种常用场景，更多使用可以去github查看api。参考https://github.com/kelektiv/node-cron","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"定时任务","slug":"定时任务","permalink":"http://blog.langpz.com/tags/定时任务/"}]},{"title":"ES6系列-let和const变量","slug":"ES6系列-let和const变量","date":"2018-06-26T17:08:51.000Z","updated":"2025-09-06T12:42:50.048Z","comments":true,"path":"ES6系列-let和const变量.html","link":"","permalink":"http://blog.langpz.com/ES6系列-let和const变量.html","excerpt":"ES6系列-let和const变量ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。","text":"ES6系列-let和const变量ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。首先说说var声明变量的弊端。1.可以重复声明2.无法限制修改3.没有块级作用域4.变量会被提升letlet不可以重复声明。123let a = 2;let a = 3;alert(a)如果重复声明会直接报错。let有块级作用域。123456&#123; let a = 2; var b = 3;&#125;console.log(b);console.log(a);会报错 a is not defined。let不存在变量提升。1234console.log(a)console.log(b)var a = 1;let b = 2;会打印出 a undefined b is not defined。constconst常量是不可以被修改的。123const a = 'lanpangzhi';a = 11;alert(a)修改会直接报错，但是如果是对象数据类型可以在对象下添加新得属性。123const a = &#123;&#125;;a.b = 2;console.log(a)这样写不会报错，常量a存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把a指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。const不可以重复声明。123const a = 2;const a = 3;alert(a)如果重复声明会直接报错。const有块级作用域。123456&#123; const a = 2; var b = 3;&#125;console.log(b);console.log(a);会报错 a is not defined。const不存在变量提升。1234console.log(a)console.log(b)var a = 1;const b = 2;会打印出 a undefined b is not defined。例子让i从0输出到5，按顺序输出，es5版本需要闭包来实现。12345for (var i = 0; i &lt;= 5; i++)&#123; (function(i)&#123; console.log(i) &#125;)(i)&#125;es6版本123for (let i = 0; i &lt;= 5; i++)&#123; console.log(i)&#125;let和const解决了var的弊端，瞬间开发变简单了很多。参考http://es6.ruanyifeng.com/#docs/let","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://blog.langpz.com/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"}]},{"title":"解决移动端click事件300毫秒延迟和点透问题","slug":"解决移动端click事件300毫秒延迟和点透问题","date":"2018-06-21T10:53:59.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"解决移动端click事件300毫秒延迟和点透问题.html","link":"","permalink":"http://blog.langpz.com/解决移动端click事件300毫秒延迟和点透问题.html","excerpt":"解决移动端click事件300毫秒延迟和点透问题click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。","text":"解决移动端click事件300毫秒延迟和点透问题click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。fastclick老项目建议用fastclick解决，这样改动起来成本比较小。https://github.com/ftlabs/fastclick引用fastclick库就可以解决300毫秒延迟和点透问题12345678910// 原生js调用if ('addEventListener' in document) &#123; document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body); &#125;, false);&#125;// jquery调用$(function() &#123; FastClick.attach(document.body);&#125;);使用移动端事件代替click例如touchstart 等事件，建议使用Hammer手势库https://github.com/hammerjs/hammer.js12345var a = document.querySelector('.a');var hammer = new Hammer(a);hammer.on('tap', function(e) &#123; console.log(\"2222!\");&#125;);参考https://github.com/ftlabs/fastclickhttps://github.com/hammerjs/hammer.js","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://blog.langpz.com/tags/移动端/"},{"name":"点透","slug":"点透","permalink":"http://blog.langpz.com/tags/点透/"}]},{"title":"vue2.0的生命周期","slug":"vue的生命周期","date":"2018-06-14T09:48:11.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"vue的生命周期.html","link":"","permalink":"http://blog.langpz.com/vue的生命周期.html","excerpt":"vue2.0的生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。","text":"vue2.0的生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。生命周期钩子函数代码演示地址beforeCreate 在实例初始化之后调用，数据和事件都没绑定。所以在beforeCreate访问不到任何东西。created 在实例创建完成后被立即调用。数据和事件已经绑定，但是模板没有渲染，$el属性不可见 。在created数据和事件都可以访问了，就能打印出数据。beforeMount 模板渲染前调用beforeMount的时候可以访问到 $el 但是并没有渲染到页面上（virtual DOM）数据也还是这样的格式，所以不能操作DOM。mounted 模板渲染到页面上调用mounted 的时候就可以操作dom，可以把dom操作放到这个生命周期。beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。在控制台执行 vm.lanpangzhi = 3beforeUpdate 这个钩子函数可以访问更新前的dom元素。这里的dom元素并没有更新掉。updated 数据更新完触发。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。beforeDestroy 实例销毁之前调用。在控制台执行 vm.$destroy()当这个钩子被调用时实例还可以用。destroyed 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。个人总结created （实例创建完） 这个钩子函数可以用来请求数据发ajax。mounted （模板渲染完） 这个钩子函数可以用来操作dom一些方法，如果你用了jQuery需要把代码放到这个钩子函数里面。updated （数据更新完） 这个钩子函数通常最好使用计算属性或 watcher 取而代之。beforeDestroy （实例销毁之前调用） 这个钩子函数触发的时候可以用来清理定时器变量。还有几个钩子函数没有说到，建议自行去官网查看。生命周期图示beforeCreate在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。created在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。mountedel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted该钩子在服务器端渲染期间不被调用。beforeUpdate数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。updated由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated该钩子在服务器端渲染期间不被调用。beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。destroyedVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。参考https://cn.vuejs.org/v2/api/#beforeCreate","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"生命周期","slug":"生命周期","permalink":"http://blog.langpz.com/tags/生命周期/"}]},{"title":"webpack4.0入门指南（二）转换es7语法解析静态资源","slug":"webpack4-0入门指南（二）转换es7语法解析静态资源","date":"2018-06-13T13:30:47.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"webpack4-0入门指南（二）转换es7语法解析静态资源.html","link":"","permalink":"http://blog.langpz.com/webpack4-0入门指南（二）转换es7语法解析静态资源.html","excerpt":"webpack4.0入门指南（二）转换es7语法解析静态资源之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。","text":"webpack4.0入门指南（二）转换es7语法解析静态资源之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。转换es7语法把之前demo3文件夹一份命名为demo4。修改demo4/src/index.js文件1234let obj = &#123;name: 'lanpangzhi'&#125;;let obj2 = &#123;blog: 'http://blog.langpz.com'&#125;;let newObj = &#123;...obj, ...obj2&#125;; // es7语法console.log(newObj);安装babel插件，在项目根目录执行命令1npm install babel-preset-stage-0 -D // ES7不同阶段语法提案的转码规则（共有4个阶段）stage-0 包含 stage-1 stage-2 stage-3 阶段 还包含 babel-plugin-transform-do-expressionsbabel-plugin-transform-function-bind 两个插件的功能，阶段标准修改demo4/.babelrc文件123&#123; \"presets\": [\"env\",\"stage-0\"]&#125;在demo4路径下执行 webpack，就看到打包成功了打开demo4/index.js文件控制台就输出。{name: “lanpangzhi”, blog: “http://blog.langpz.com&quot;}解析CSS为了从 JavaScript 模块中 import 一个 CSS 文件，你需要配置如下loader。安装babel插件，在项目根目录执行命令。1npm install --save-dev style-loader css-loader修改demo4/webpack.config.js文件 在rules数组里添加一个规则。1234567&#123; test: /\\.css$/, // 匹配所有.css结尾的文件 use: [ // use要从右往左写，先转成样式，再打包到style标签 'style-loader', 'css-loader' ]&#125;创建css文件1cd src &amp;&amp; touch index.css修改demo4/src/index.css文件123body &#123; background: red;&#125;引入css文件修改demo4/src/index.js文件12// 最上面添加一行import './index.css';在demo4路径下执行 webpack，就看到打包成功。打开demo4/index.html就有红色的背景色了。解析sass为了从 JavaScript 模块中 import 一个 scss 文件，你需要配置如下loader。安装babel插件，在项目根目录执行命令。1npm install sass-loader node-sass webpack --save-dev修改demo4/webpack.config.js文件，在rules数组里添加一个规则。12345678&#123; test: /\\.scss$/, // 匹配所有.scss结尾的文件 use: [ 'style-loader', // 将 JS 字符串生成为 style 节点 'css-loader', // 将 CSS 转化成 CommonJS 模块 'sass-loader' // 将 Sass 编译成 CSS ]&#125;创建scss文件1cd src &amp;&amp; touch index.scss修改demo4/src/index.scss文件1234$body-color: yellow;body &#123; background: $body-color;&#125;修改demo4/src/index.js文件12// 最上面一行替换如下代码import './index.scss';在demo4路径下执行 webpack，就看到sass编译成功。打开demo4/index.html就有绿色的背景色了。!()[http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613163909.png]如果你想解析其他预处理css语言安装对应loader，添加规则就可以编译了。如less less-loader。解析图片假想，现在我们正在下载 CSS，但是我们的背景和图标这些图片，要如何处理呢？使用 file-loader，我们可以轻松地将这些内容混合到 CSS 中。安装babel插件，在项目根目录执行命令。1npm install --save-dev file-loader随意再网上下载一个png图片放到demo4/src/目录下，命名为1.png修改demo4/src/index.scss文件123body &#123; background: url(./1.png);&#125;修改demo4/webpack.config.js文件，在rules数组里添加一个规则。1234567891011&#123; test: /\\.(png|svg|jpg|gif)$/, // 匹配所有.png和.svg和.jpg和.gif结尾的文件 use: [ &#123; loader: 'file-loader', options: &#123; publicPath: 'dist/' // 设置public 发布目录。 &#125; &#125; ]&#125;在demo4路径下执行 webpack，就看到图片编译成功。打开demo4/index.html就有背景图。加载字体像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，包括字体。让我们更新 webpack.config.js 来处理字体文件。修改demo4/webpack.config.js文件，在rules数组里添加一个规则。123456&#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ]&#125;如果样式文件里面引入了字体就会被打包，这里就不演示了。demo仓库地址https://github.com/lanpangzhi/webpack-demo","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.langpz.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://blog.langpz.com/tags/打包工具/"}]},{"title":"yarn使用介绍","slug":"yarn使用介绍","date":"2018-06-12T14:19:09.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"yarn使用介绍.html","link":"","permalink":"http://blog.langpz.com/yarn使用介绍.html","excerpt":"yarn使用介绍Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。","text":"yarn使用介绍Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。安装1npm install -g yarn初始化新项目1yarn init等同于 npm init， -y参数也是一样。添加依赖包安装全局包需要先执行yarn global bin 然后把获取到的路径添加到环境变量path里面，感觉很麻烦也可以用 npm i -g 安装1yarn global add create-react-app // 全局安装等同于 npm i -g create-react-app安装包信息将加入到dependencies（生产阶段的依赖）12yarn add forever // 等同于 npm install forever -S yarn add forever@2.0.0 // 安装2.0.0版本将依赖项添加到不同依赖项类别分别添加到 devDependencies、peerDependencies 和 optionalDependencies123yarn add express --dev // 等同于 npm install forever -D yarn add express --peeryarn add express --optionalpeerDependencies “同伴依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装包的用户也需要和包同样的依赖。 这对于像 react 这样也被人安装的、需要单一 react-dom 副本的包很有用。optionalDependencies 这是可选依赖，意味着依赖是……可选的。这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。升级包12yarn upgrade express // 等同于 npm update expressyarn global upgrade express // 等同于 npm update npm update express -g删除包12yarn remove express // 等同于 npm uninstall expressyarn global remove express // 等同于 npm uninstall -g express安装项目的全部依赖1yarn or yarn install // 等同于 npm install查看包安装信息12yarn list // 等同于 npm listyarn global list // npm list -g上面就是比较常用的方法了，可以快速从npm切换到yarn上，更多方法可以去官网查看。参考https://yarnpkg.com/zh-Hans/","categories":[],"tags":[{"name":"yarn","slug":"yarn","permalink":"http://blog.langpz.com/tags/yarn/"}]},{"title":"webpack4.0入门指南（一）安装和转换es6语法","slug":"webpack入门指南","date":"2018-06-08T10:35:24.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"webpack入门指南.html","link":"","permalink":"http://blog.langpz.com/webpack入门指南.html","excerpt":"webpack4.0入门指南（一）安装和转换es6语法webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。","text":"webpack4.0入门指南（一）安装和转换es6语法webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。安装12npm install -g webpacknpm install -g webpack-cli需要先全局安装你才可以使用webpack命令，然后再安装到你的项目依赖。如果你使用 webpack 4+ 版本，你还需要安装 CLI。新建项目123mkdir webpack-demo &amp;&amp; cd webpack-demo //创建并进入webpack-demo文件夹npm init -y // 初始化项目package.json文件npm install -D webpack webpack-cli // 本地安装 webpack和webpack-cli使用默认配置去构建1234mkdir demo1 &amp;&amp; cd demo1touch index.htmlmkdir src &amp;&amp; cd srctouch index.jsindex.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- webpack会把src/index.js文件打包到dist目录mian.js --&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;src/index.js12let a = 1;alert(a);执行 webpack 命令。就可以看到文件被打包到dist文件夹了。打开index.html文件就会弹出1。webpack4.0可以不用写配置文件，然而大多数项目会需要很复杂的设置，需要你自己去配置。使用配置文件123456cd .. // 返回到webpack-demo文件夹touch webpack.config.js // 创建配置文件touch index.htmlmkdir demo2 &amp;&amp; cd demo2 // 创建demo2文件夹mkdir src &amp;&amp; cd srctouch index.jswebpack.config.js123456789const path = require('path');module.exports = &#123; entry: './src/index.js', // 入口文件 output: &#123; // 出口文件 filename: 'bundle.js', // 打包后命名为bundle.js path: path.resolve(__dirname, 'dist') // 输出的路径 &#125;&#125;;在项目的demo2目录执行webpack。如下图就代表打包成功。打开demo2下面的index.html 就可以弹出我的博客地址。使用babel转换es6语法 =&gt; es5安装babel在webpack-demo路径下执行命令1npm install --save-dev babel-loader babel-core babel-preset-env把demo2复制一份命名为demo3，在src目录下再新建a.js。src/a.js1export default lanpangzhi = \"blog.langpz.com\";src/index.js12import lanpz from \"./a.js\";console.log(lanpz);webpack.config.js1234567891011121314151617181920const path = require('path');module.exports = &#123; entry: './src/index.js', // 入口文件 output: &#123; // 出口文件 filename: 'bundle.js', // 打包后命名为bundle.js path: path.resolve(__dirname, 'dist') // 输出的路径 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, // 匹配所有.js结尾的文件 exclude: /node_modules/, // 忽略node_modules文件夹 use: &#123; loader: 'babel-loader' // 使用babel-loader转义 &#125; &#125; ] &#125;&#125;;新建 .babelrc 文件1touch .babelrc.babelrc123&#123; \"presets\": [\"env\"]&#125;执行webpack就可以看见打包成功了。babel-polyfill由于 Babel 只转换语法(如箭头函数)， 你可以使用 babel-polyfill 支持新的全局变量，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。在webpack-demo路径下执行命令1npm install --save babel-polyfill // 安装babel-polyfill在 webpack.config.js 中，将 babel-polyfill 加到你的 entry 数组中。123module.exports = &#123; entry: [\"babel-polyfill\", \"./src/index.js\"]&#125;;执行webpack命令，如下图就成功了。demo仓库地址https://github.com/lanpangzhi/webpack-demo参考https://www.babeljs.cn/https://webpack.docschina.org/","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.langpz.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://blog.langpz.com/tags/打包工具/"}]},{"title":"部署小说api服务到腾讯云","slug":"部署小说api服务到腾讯云","date":"2018-05-29T11:00:08.000Z","updated":"2025-09-06T12:42:50.054Z","comments":true,"path":"部署小说api服务到腾讯云.html","link":"","permalink":"http://blog.langpz.com/部署小说api服务到腾讯云.html","excerpt":"部署小说api服务到腾讯云小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。","text":"部署小说api服务到腾讯云小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。服务器配置: CentOS 7.4 64位 1 核 2 GB 1 Mbpsnode版本: 8.9.0nvm版本: 0.33.11npm版本： 5.5.1nginx版本：1.12.2git版本: 2.9.5第一步添加pm2配置文件在小说api项目的根目录创建一个pm2.json的文件。12345678910111213141516171819202122232425&#123; \"name\": \"novel-api\", // 服务名 \"script\": \"./bin/www\", // 启动脚本 \"cwd\": \"./\", // 当前工作路径 \"watch\": [ // 监控变化的目录，一旦变化，自动重启 \"bin\", \"routers\" ], \"ignore_watch\": [ // 从监控目录中排除 \"node_modules\", \"logs\", \"public\", \"log\" ], \"watch_options\": &#123; \"followSymlinks\": false &#125;, \"max_memory_restart\": \"1G\", // 根据内存限制重新启动应用程序。 \"error_file\": \"./logs/novel-apierr.log\", // 错误日志路径 \"out_file\": \"./logs/novel-api-out.log\", // 普通日志路径 \"env\": &#123; \"DEBUG\": \"novel-api\", // 环境变量参数，debug名字为novel-api，8080端口监听 \"PORT\": \"8080\" &#125;&#125;package.json文件添加npm run deploy部署命令。1\"deploy\": \"pm2 start pm2.json\"pm2 常用命令。pm2 save 保存当前进程列表。pm2 resurrect 启动之前保存的进程列表。pm2 restart app.js|app_name 重启进程pm2 start app.js 启动进程pm2 list 查看进程列表pm2 stop app_name |app_id 停止指定的应用。 all 停止所有应用第二步购买服务器和域名购买服务器https://buy.cloud.tencent.com/cvm?tab=lite，我买的是CentOS 7.4 64位 1 核 2 GB 1 Mbps的服务器。如果只是尝试部署流程，可以选择按时计费。购买域名https://dnspod.cloud.tencent.com/?from=qcloudProductDns建议选.com的域名。第三步设置子域名添加一个api开头的子域名https://console.cloud.tencent.com/domain，然后添加解析。第四步登陆服务器安装软件登陆到服务器然后执行以下安装命令。安装nginx12yum install -y nginxnginx -v安装nvm12curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bashnvm --version安装node和pm2、apidoc12345nvm install 8.9.0nvm use 8.9.0node -vnpm -vnpm install -g pm2 apidoc安装git123456789101112131415yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel taryum install -y gcc-c++ perl-ExtUtils-MakeMakercd /usr/srcwget https://www.kernel.org/pub/software/scm/git/git-2.9.5.tar.gztar xf git-2.9.5.tar.gzcd git-2.9.5make configuremake profix=/usr/gitmake installecho \"export PATH=$PATH:/usr/git/bin\" &gt;&gt; /etc/profilesource /etc/profilegit --version // 配置gitgit config --global user.name \"用户名称\"git config --global user.email 电子邮件地址在服务器上克隆git仓库先进入home路径创建wwwroot文件夹。1234567cd /home &amp;&amp; mkdir wwwrootcd wwwrootgit clone https://github.com/lanpangzhi/novel-api.gitcd novel-apinpm installnpm run docnpm run deploy这个应用就pm2被启动了。配置nginx先启动nginx。1nginxhttp://123.206.45.87 在浏览器输入服务器ip就可以看到nginx已经启动了。进入nginx配置目录，新建文件。12cd /etc/nginx/conf.dtouch api.langpz.com-8080.conf如果一台服务器的server比较多，建议用域名和端口做配置文件名。编辑api.langpz.com-8080.conf 配置文件。1vi api.langpz.com-8080.conf把下面代码复制粘贴过去。12345678910111213141516upstream novel-api &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; server_name 你自己的域名; location / &#123; proxy_pass http://novel-api; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_redirect off; &#125;&#125;ctrl + c 输入:wq 退出并保存。再执行nginx -s reload 在浏览器输入你的域名就可以看到文档，http://api.langpz.comgzip压缩12cd /etc/nginx/vi nginx.conf把下面代码复制粘贴过去。123456789101112## gzip压缩gzip on;# ie6不启用gzipgzip_disable \"msie6\";gzip_vary on;gzip_proxied any;# 压缩等级 1-9gzip_comp_level 2;gzip_buffers 16 8k;gzip_http_version 1.1;# 为除“text/html”之外的MIME类型启用压缩gzip_types text/plain text/css application/json application/x-javascript image/gif image/jpeg image/png image/tiff image/x-icon application/font-woff application/vnd.ms-fontobject text/javascript;ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。可以去站长之家看你的压缩率http://tool.chinaz.com/gzips/隐藏nginx版本号还是修改nginx.conf这个文件12345vi nginx.conf// 把下面代码复制过去# 隐藏nginx版本号server_tokens off;ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。这里就不显示nginx版本号了。配置ssl证书https，给你的网站加个小绿锁我用的是腾讯云的免费证书，也可以自己生成。https://cloud.tencent.com/product/ssl?from=qcloudHpHeaderSsl，使用域名免费版。申请腾讯云ssl证书直接点下一步，然后用推荐选项验证。申请很快不到十分钟就下来，到时候还会有邮件和短信通知。下载证书上传到服务器找到腾讯云的ssl证书管理去下载证书。压缩包里面有三个文件夹找到Nginx这个文件夹。在服务器进入nginx所在目录新建一个文件夹。12cd /etc/nginx/mkdir api.langpz.com然后把Nginx文件夹里面两个文件上传到服务器/etc/nginx/api.langpz.com 这个文件夹里面。可以下载一个FileZilla软件或者下载一个别的ftp工具，还可以用命令行，我这里下载了FileZilla使用它去上传。加强 HTTPS 安全性首先在目录 /etc/nginx/api.langpz.com 运行以下代码生成 dhparam.pem 文件12cd /etc/nginx/api.langpz.com openssl dhparam -out dhparam.pem 2048修改配置文件12cd /etc/nginx/conf.dtouch api.langpz.com-8080.conf把下面代码覆盖api.langpz.com-8080.conf文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950upstream novel-api &#123; server 127.0.0.1:8080;&#125;# 配置共享会话缓存大小ssl_session_cache shared:SSL:10m;# 配置会话超时时间ssl_session_timeout 10m;# 强制跳转httpsserver &#123; listen 80; server_name api.langpz.com; return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl; server_name api.langpz.com; # 证书文件 ssl_certificate /etc/nginx/api.langpz.com/1_api.langpz.com_bundle.crt; # 私钥文件 ssl_certificate_key /etc/nginx/api.langpz.com/2_api.langpz.com.key; # 设置长连接 keepalive_timeout 70; # 优先采取服务器算法 ssl_prefer_server_ciphers on; # 使用DH文件 ssl_dhparam /etc/nginx/api.langpz.com/dhparam.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 定义算法 ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\"; # HSTS策略 add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains;preload\" always; # 防XSS攻擊 add_header X-Xss-Protection 1; # 禁止服务器自动解析资源类型 add_header X-Content-Type-Options nosniff; location / &#123; proxy_pass http://novel-api; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_redirect off; &#125;&#125;ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。现在就可以访问https://api.langpz.com。如果访问http协议就会强制跳转到https协议。SSL安全测试输入你的域名。之前在nginx配置加强 HTTPS 安全性，所以结果是A+。总结这种部署比较麻烦，部署完发现pm2也有部署功能，2.0用koa.js重构的时候用pm2部署，docker 生成镜像。参考https://nginx.org/en/docs/https://github.com/creationix/nvmhttps://www.thinkjs.org/zh-cn/doc/3.0/deploy.htmlhttps://www.cnblogs.com/chyingp/p/pm2-documentation.htmlhttp://www.runoob.com/git/git-install-setup.htmlhttps://nginx.rails365.net/chapters/install.htmlhttps://www.cnblogs.com/nuccch/p/7681592.htmlhttps://aotu.io/notes/2016/08/16/nginx-https/index.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"},{"name":"部署","slug":"部署","permalink":"http://blog.langpz.com/tags/部署/"}]},{"title":"使用apidoc文档神器，快速生成api文档","slug":"使用apidoc文档神器，快速生成api文档","date":"2018-05-26T11:13:37.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用apidoc文档神器，快速生成api文档.html","link":"","permalink":"http://blog.langpz.com/使用apidoc文档神器，快速生成api文档.html","excerpt":"使用apidoc文档神器，快速生成api文档写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。","text":"使用apidoc文档神器，快速生成api文档写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。安装第一步先安装全局模块apidoc。1npm install apidoc -g修改接口的注释找到novel-api项目routes下面的index.js文件，注释修改成如下123456789101112131415161718192021222324252627282930313233343536373839/** * @api &#123;get&#125; /index 请求首页数据 * @apiVersion 1.0.0 * @apiName 获取首页数据 * @apiGroup index * * * @apiSuccess &#123;Number&#125; flag 是否获取到数据 1成功 0失败 * @apiSuccess &#123;Array&#125; books 返回书籍内容 * @apiSuccess &#123;String&#125; msg 返回信息 * * @apiSuccessExample &#123;json&#125; Success-Response: * HTTP/1.1 200 OK * &#123; * \"flag\": 1, * \"books\": [ * &#123; * \"_id\": \"5816b415b06d1d32157790b1\", * \"title\": \"圣墟\", * \"author\": \"辰东\", * \"shortIntro\": \"在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭，那一缕幽雾又一次临近大地，世间的枷锁被打开了，一个全新的世界就此揭开神秘的一角……\", * \"cover\": \"http://statics.zhuishushenqi.com/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F1228859%2F1228859_fac7917a960547eb953edf0b740cef3a.jpg%2F\", * \"site\": \"zhuishuvip\", * \"majorCate\": \"玄幻\", * \"minorCate\": \"东方玄幻\", * \"allowMonthly\": false, * \"banned\": 0, * \"latelyFollower\": 283375, * \"retentionRatio\": \"73.42\" * &#125; * ], * \"msg\": \"OK\" * &#125; * * * @apiErrorExample Error-Response: * HTTP/1.1 404 Not Found * &#123; \"flag\": 0, \"msg\": \"rankingId有问题\" &#125; */@api {method} path [title]@api 如果没有@api apidoc会忽略这段注释method 请求的方法path 路径title 标题@apiVersion version设置文档块的版本。version 版本号@apiName name定义方法文档块的名称。名称将用于生成的输出中的子导航。name 方法的名称@apiGroup name定义方法文档块属于哪个组。组将用于生成的输出中的主导航。name 组的名称。也用作导航标题。@apiSuccess [(group)] [{type}] field [description]成功返回参数。(group) 可选 所有参数将按这个名称分组。没有组，默认Success 200设置。{type} 可选 返回类型field 返回标识符description 描述@apiParamExample [{type}] [title]example参数请求示例。{type} 可选 响应格式title 示例的简称example 详细的例子@apiErrorExample [{type}] [title]example错误返回消息的示例，输出为预格式化代码。{type} 可选 响应格式title 示例的简称example 详细的例子配置npm run doc打开package.json文件增加doc命令配置1\"doc\": \"apidoc -i routes/ -o public/\"routes/ 要输出API文档的文件夹。public/ 输出文档到public文件夹，没有回自动创建。执行 npm run doc访问 http://localhost:3000/ 就可以看到生成好的API文档了。参考https://github.com/apidoc/apidoc","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"},{"name":"apidoc","slug":"apidoc","permalink":"http://blog.langpz.com/tags/apidoc/"}]},{"title":"使用Express开发小说API接口服务1.0（三）","slug":"使用Express开发小说API接口服务1-0（三）","date":"2018-05-26T10:54:41.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用Express开发小说API接口服务1-0（三）.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务1-0（三）.html","excerpt":"使用Express开发小说API接口服务1.0（三）之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。","text":"使用Express开发小说API接口服务1.0（三）之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。app.js 增加错误处理1234567891011121314151617// catch 404 and forward to error handlerapp.use(function (req, res, next) &#123; const err = new Error('Not Found'); err.status = 404; next(err);&#125;);// error handlerapp.use(function (err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render('error');&#125;);这些代码放到module.exports = app; 上面就可以了。列表页增加返回ID找到routes/chapter.js 29行替换1res.send(JSON.stringify(&#123; \"flag\": 1,\"id\": body._id, \"chapters\": body.chapters, \"msg\": \"OK\" &#125;));详情页增加上一章和下一章的返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 获取小说文章内容 返回小说文章内容 param link &#123;String&#125; 是小说文章列表接口 chapters[0].link http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;*/router.get('/', function (req, res, next) &#123; if (!req.query.link) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请传入link...\" &#125;)); &#125; // req.query.link 编码转义 let link = encodeURIComponent(req.query.link); request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok)&#123; // 再次请求列表页获取上一页和下一页 if(req.query.id)&#123; // req.query.id 编码转义 let id = encodeURIComponent(req.query.id); let n = parseInt(req.query.n); if (isNaN(n))&#123; n = 0; &#125; request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body2) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; if (body2 == \"wrong param\")&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入错误的ID...\" &#125;)); &#125;else&#123; // 解析返回的数据 body2 = JSON.parse(body2); // 检查页码是否超过小说的章节数 if(n &gt; body2.chapters.length - 1)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入的页码过大\" &#125;)); &#125;else&#123; // 如果有上一页或者下一页就返回link否则返回false let prev,next; body2.chapters[n - 1] ? prev = body2.chapters[n - 1].link : prev = false; body2.chapters[n + 1] ? next = body2.chapters[n + 1].link : next = false; if (body2.chapters.length &gt; 0) &#123; res.send(JSON.stringify(&#123; \"flag\": 1,\"id\": id, \"chapter\": body.chapter, \"prev\": prev,\"next\": next, \"msg\": \"OK\" &#125;)); &#125; &#125; &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 1, \"chapter\": body.chapter, \"msg\": \"OK\" &#125;)); &#125; &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入link有错误\" &#125;)); &#125; &#125;);&#125;);module.exports = router;访问http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037&amp;n=2648&amp;id=577b6c81ccb7bf00499d036c新增n和id参数。n 代表是第几页。id 是书籍ID。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用Express开发小说API接口服务1.0(二)","slug":"使用Express开发小说API接口服务-二","date":"2018-05-18T13:26:05.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用Express开发小说API接口服务-二.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务-二.html","excerpt":"使用Express开发小说API接口服务1.0(二)之前完成了首页和搜索的接口，现在就开始写剩下的接口。","text":"使用Express开发小说API接口服务1.0(二)之前完成了首页和搜索的接口，现在就开始写剩下的接口。获取小说源因为追书神器正版源是收费加密的，所以只能使用盗版源，所以要封装一个获取小说源的接口。修改app.js 文件路由中间件配置，增加一个路由12let sourceRouter = require('./routes/source');app.use('/source', sourceRouter);在routes下面新建 source.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 获取小说源 返回盗版源和正版源 param id &#123;String&#125; 是首页和搜索返回接口 books[i].id param n &#123;Number || String&#125; 使用第几个源，可以不用传参默认 1 http://api.zhuishushenqi.com/atoc?view=summary&amp;book=$&#123;bookID&#125;*/router.get('/', function (req, res, next) &#123; if (!req.query.id) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请传入ID...\" &#125;)); &#125; // req.query.id 编码转义 let id = encodeURI(req.query.id); request.get(`$&#123;common.API&#125;/atoc?view=summary&amp;book=$&#123;id&#125;`, function (err, response, body)&#123; if(err)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); // 判断是否返回内容 if (body.length == 0)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"没有获取到小说源，换个小说看吧\" &#125;)); &#125; // 第一个源是正版源，是收费加密的，所以默认选中第二个源 let n = parseInt(req.query.n); if (isNaN(n) || n == 0)&#123; n = 1; &#125; // 判断n是否大于源数据的长度 if (n &gt;= body.length)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"n的参数值不正确，没有那个源\" &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 1, \"books\": body[n], \"msg\": \"OK\" &#125;)); &#125; &#125;);&#125;);module.exports = router;访问http://localhost:3000/source/?id=50864bf69dacd30e3a000014&amp;n=3 就可以看到返回第四个源的数据。小说文章列表修改app.js 文件路由中间件配置，增加一个路由12let chapterRouter = require('./routes/chapter');app.use('/chapter', chapterRouter);在routes下面新建 chapter.js123456789101112131415161718192021222324252627282930313233343536let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 获取小说文章列表 返回小说文章列表 param id &#123;String&#125; 是小说源接口 books.id http://api.zhuishushenqi.com/atoc/$&#123;id&#125;?view=chapters*/router.get('/', function (req, res, next) &#123; if (!req.query.id)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请传入ID...\" &#125;)); &#125; // req.query.id 编码转义 let id = encodeURIComponent(req.query.id); request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; if (body == \"wrong param\")&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入错误的ID...\" &#125;)); &#125;else&#123; // 解析返回的数据 body = JSON.parse(body); if (body.chapters.length &gt; 0) &#123; res.send(JSON.stringify(&#123; \"flag\": 1, \"chapters\": body.chapters, \"msg\": \"OK\" &#125;)); &#125; &#125; &#125;);&#125;);module.exports = router;访问http://localhost:3000/chapter/?id=57416370ccc94e4b41df80cc 就可以看到数据。id小说源接口返回的id。小说文章内容修改app.js 文件路由中间件配置，增加一个路由12let articleRouter = require('./routes/article');app.use('/article', articleRouter);在routes下面新建 article.js12345678910111213141516171819202122232425262728293031323334let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 获取小说文章内容 返回小说文章内容 param link &#123;String&#125; 是小说文章列表接口 chapters[0].link http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;*/router.get('/', function (req, res, next) &#123; if (!req.query.link) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请传入link...\" &#125;)); &#125; // req.query.link 编码转义 let link = encodeURIComponent(req.query.link); request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok)&#123; res.send(JSON.stringify(&#123; \"flag\": 1, \"chapter\": body.chapter, \"msg\": \"OK\" &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入link有错误\" &#125;)); &#125; &#125;);&#125;);module.exports = router;访问http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037 就可以看到数据。排行榜修改app.js 文件路由中间件配置，增加一个路由12let rankingRouter = require('./routes/ranking');app.use('/ranking', rankingRouter);在routes下面新建 ranking.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 获取排行榜 返回排行榜 param id &#123;String&#125; 没有传参数就是获取全部榜单，否则根据参数获取榜单 http://api.zhuishushenqi.com/ranking/gender http://api.zhuishushenqi.com/ranking/$&#123;id&#125;*/router.get('/', function (req, res, next) &#123; // 获取全部榜单 request.get(`$&#123;common.API&#125;/ranking/gender`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok) &#123; let ranking = &#123; male: body.male, picture: body.picture, epub: body.epub, female: body.female &#125;; res.send(JSON.stringify(&#123; \"flag\": 1, \"ranking\": ranking, \"msg\": \"OK\" &#125;)); &#125; else &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"出错了\" &#125;)); &#125; &#125;);&#125;);router.get('/:id', function (req, res, next) &#123; if (req.params.id) &#123; // req.param.id 编码转义 let id = encodeURIComponent(req.params.id); // 根据id获取榜单 request.get(`$&#123;common.API&#125;/ranking/$&#123;id&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok) &#123; res.send(JSON.stringify(&#123; \"flag\": 1, \"ranking\": body.ranking, \"msg\": \"OK\" &#125;)); &#125; else &#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"传入id错误\" &#125;)); &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"id没有传\" &#125;)); &#125;&#125;);module.exports = router;分别访问http://localhost:3000/ranking/ 和 http://localhost:3000/ranking/54d43437d47d13ff21cad58b 就可以获取到榜单的数据。1.0版本的开发就告于段落了。github仓库访问地址https://github.com/lanpangzhi/novel-api参考https://github.com/expressjs/morganhttps://juejin.im/entry/593a3fdf61ff4b006c737ca4https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用Express开发小说API接口服务1.0（一）","slug":"使用Express开发小说API接口服务","date":"2018-05-17T15:10:56.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用Express开发小说API接口服务.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务.html","excerpt":"使用Express开发小说API接口服务1.0（一）1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。","text":"使用Express开发小说API接口服务1.0（一）1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。github创建仓库先创建一个仓库放文件然后克隆创建好的仓库1git clone https://github.com/lanpangzhi/novel-api.git安装 express-generator 快速生成项目1npm install -g express-generator然后再之前克隆仓库的上一级目录执行12345678express --no-view novel-apicd novel-apinpm install npm install request file-stream-rotator -S// Linux MacOSDEBUG=novel-api:* &amp; npm start// windows set DEBUG=novel-api:* &amp; npm start生成好的目录结构和文件设置cors 跨域打开项目根目录app.js,放在路由上面。12345678app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1') res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next()&#125;);日志写入本地文件按时间分割log日志并写入本地磁盘，需要在app.js文件中引入fs和file-stream-rotator模块。12345678910111213141516171819let fs = require('fs'); let FileStreamRotator = require('file-stream-rotator'); // 日志按时间分割模块// 下面代码写在var app = express();下面let logDir = path.join(__dirname, 'log');// 检查是否存在logDir这个目录没有则创建fs.existsSync(logDir) || fs.mkdirSync(logDir);// 日志分割流let accessLogStream = FileStreamRotator.getStream(&#123; date_format: 'YYYYMMDD', filename: path.join(logDir, 'access-%DATE%.log'), frequency: 'daily', verbose: false&#125;);// 日志中间件app.use(logger('combined', &#123; stream: accessLogStream &#125;));创建公共文件项目根目录创建common文件夹，再里面再新建一个common.json文件12345&#123; \"API\": \"http://api.zhuishushenqi.com\", \"PIC\": \"http://statics.zhuishushenqi.com\", \"CHAPTER\": \"http://chapter2.zhuishushenqi.com\"&#125;API域名: http://api.zhuishushenqi.com图片域名: http://statics.zhuishushenqi.com章节域名: http://chapter2.zhuishushenqi.com首页接口1.0版本首页接口直接返回最热榜前20条数据。修改app.js 文件路由中间件配置1app.use('/index', indexRouter);修改routes/index.js 文件12345678910111213141516171819202122232425262728293031323334let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 首页数据追书最热榜 Top100 获取单一排行榜 http://api.zhuishushenqi.com/ranking/&#123;rankingId&#125;*/router.get('/', function(req, res, next) &#123; // 请求追书最热榜 Top100 request.get(`$&#123;common.API&#125;/ranking/54d42d92321052167dfb75e3`, function (error, response, body) &#123; if (error)&#123; res.send(JSON.stringify(&#123;\"flag\": 0, \"msg\": \"请求出错了...\"&#125;)); &#125; // 解析返回数据取前20条，并添加图片url链接 body = JSON.parse(body); if (body.ok)&#123; let books = body.ranking.books.slice(0, 19); books.forEach(element =&gt; &#123; element.cover = common.PIC + element.cover; &#125;); res.send(JSON.stringify(&#123; \"flag\": 1, \"books\": books, \"msg\": \"OK\" &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"rankingId有问题\" &#125;)); &#125; &#125;);&#125;);module.exports = router;访问http://localhost:3000/index 就可以看到返回的数据了。搜索接口1.0版本的搜索接口只取前40条数据，可以模糊查询。修改app.js 文件路由中间件配置，把users删掉。12let searchRouter = require('./routes/search');app.use('/search', searchRouter);然后把routes文件夹下面的users.js删除，新建search.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546let express = require('express');let request = require('request');let common = require('../common/common.json'); // 引用公共文件let router = express.Router();/** 模糊搜索接口 返回模糊搜索前40条数据 http://api.zhuishushenqi.com/book/fuzzy-search?query=&#123;name&#125;*/router.get('/', function(req, res, next) &#123; // 判断query参数有没有传递过来 if (req.query.query)&#123; // req.query.query 编码转义 let query = encodeURIComponent(req.query.query); request.get(`$&#123;common.API&#125;/book/fuzzy-search?query=$&#123;query&#125;`, function (error, response, body) &#123; if (error)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; // 解析返回数据 body = JSON.parse(body); if (body.ok)&#123; if (body.books.length == 0)&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"没有找到书籍，换个名字试试吧。\" &#125;)); &#125; // 取前40条，并添加图片url链接 let books = body.books.slice(0, 39); books.forEach(element =&gt; &#123; element.cover = common.PIC + element.cover; &#125;); res.send(JSON.stringify(&#123; \"flag\": 1, \"books\": books, \"msg\": \"OK\" &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; \"flag\": 0, \"msg\": \"请求出错了...\" &#125;)); &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123;\"flag\": 0, \"msg\": \"请传入query参数\"&#125;)); &#125; &#125;);module.exports = router;访问http://localhost:3000/search/?query=遮天 就可以看到返回的数据了。参考https://github.com/expressjs/morganhttps://juejin.im/entry/593a3fdf61ff4b006c737ca4https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用travis-ci自动构建Hexo","slug":"使用travis-ci自动构建Hexo","date":"2018-05-15T16:30:49.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用travis-ci自动构建Hexo.html","link":"","permalink":"http://blog.langpz.com/使用travis-ci自动构建Hexo.html","excerpt":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。","text":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。构建流程本地写完文章 =&gt; push github =&gt; GitHub触发Travis CI构建 =&gt; 执行命令 =&gt; 部署 =&gt; 完成。用github登陆travis-cihttps://travis-ci.com然后添加到你要激活的存储库。然后选择你要使用的仓库，我这里选择的是lanpangzhi.github.io，我放hexo博客的仓库。然后生成github和coding的Token。先生成github的Token。https://github.com/settings/tokens点击Generate new token。然后生成Token。开始生成coding的Token。点击新建令牌。复制令牌。登陆travis-ci把github和coding的Token复制到环境变量。https://travis-ci.com/点击Settings。添加CI_TOKEN和CO_TOKEN环境变量。CI_TOKEN是github的Token。CO_TOKEN是coding的Token。在项目根目录新建.travis.yml 文件1234567891011121314151617181920212223242526272829303132333435language: node_jsnode_js:- 8.9.0cache: directories: - node_modulesbefore_install:- npm install hexo-cli -ginstall:- npm installscript:- hexo clean- hexo generateafter_script: - cd ./public - git init - git config user.name \"github用户名\" - git config user.email \"github邮箱\" - git add . - git commit -m \"TravisCI 自动部署\" # Github Pages - git push --force --quiet \"https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;\" master:master # Coding Pages - git push --force --quiet \"https://coding用户名:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;\" master:masterbranches: only: - indigo 这里替换你要监听的分支env: global: # Github Pages - GH_REF: github.com/lanpangzhi/lanpangzhi.github.io 这里替换你的github仓库地址 # Coding Pages - CO_REF: git.coding.net/bule/bule.coding.me.git 这里替换你的coding仓库地址然后提交github，travis-ci就会自动构建了。现在写博客只需要两步操作，第一步 hexo new “新的文章”，第二步提交到github。travis-ci会帮你自动部署的。省去了 hexo clean hexo g -d 的环节。看到这张图就代表成功了。如果使用git子模块的话请使用https地址，或者在.travis.yml文件禁用子模块，否则构建会报错，提示没有权限。参考https://docs.travis-ci.com/user/for-beginnershttps://zh.wikipedia.org/wiki/Travis_CIhttps://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744https://blog.csdn.net/qinyuanpei/article/details/79388983","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"},{"name":"travis-ci","slug":"travis-ci","permalink":"http://blog.langpz.com/tags/travis-ci/"},{"name":"自动构建","slug":"自动构建","permalink":"http://blog.langpz.com/tags/自动构建/"},{"name":"持续集成","slug":"持续集成","permalink":"http://blog.langpz.com/tags/持续集成/"}]},{"title":"使用express-generator快速生成express应用","slug":"使用express-generator快速生成express应用","date":"2018-05-14T16:08:03.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"使用express-generator快速生成express应用.html","link":"","permalink":"http://blog.langpz.com/使用express-generator快速生成express应用.html","excerpt":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。","text":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。安装1npm install -g express-generator需要全局安装。使用在要创建应用的文件夹下面执。1express -e myapp-e： 使用ejs模板myapp： 应用名字然后安装依赖项：12cd myappnpm install执行应用1set DEBUG=myapp:* &amp; npm start生成完应用的时候会有提示因为我是Windows系统所以提示set。MacOS 或 Linux 上不用使用set1DEBUG=myapp:* npm start然后在浏览器中输入 http://localhost:3000/ 以访问此应用程序。可以根据自己的需要修改文件，来满足自己项目的需要。更多参数12345678910 --version 输出版本号-e, --ejs 添加ejs引擎支持 --pug 添加pug引擎支持 --hbs 添加handlebars引擎支持-H, --hogan 添加hogan.js引擎支持-v, --view &lt;engine&gt; 添加以下模板引擎支持(dust|ejs|hbs|hjs|jade|pug|twig|vash) 默认jade --no-view 使用静态HTML代替视图模板引擎-c, --css &lt;engine&gt; 添加样式扩展语言 (less|stylus|compass|sass) 默认css --git 添加 .gitignore 忽略文件-h, --help 输出帮助信息参考https://github.com/expressjs/generator","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"express-generator","slug":"express-generator","permalink":"http://blog.langpz.com/tags/express-generator/"}]},{"title":"node爬虫","slug":"node爬虫","date":"2018-05-12T15:37:42.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"node爬虫.html","link":"","permalink":"http://blog.langpz.com/node爬虫.html","excerpt":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。","text":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。项目分析爬取http://top.zhaopin.com 智联网站上的全国的竞争最激烈三个月内前十的岗位。不需要定时爬取。使用request和cheerio模块。node版本7.6.0、npm版本4.1.2安装1npm install request cheerio -Srequest 模块是一个简化的HTTP客户端。cheerio 模块专为服务器设计的核心jQuery的快速，灵活和精益的实现。可以把爬到的内容和jQuery一样使用。核心代码1234567891011121314151617181920212223// app.jsconst request = require('request');const cheerio = require('cheerio');// 发起请求request('http://top.zhaopin.com', (error, response, body) =&gt; &#123; if(error)&#123; console.error(error); &#125; let json = &#123;&#125;; // 获取到的内容放到cheerio模块 const $ = cheerio.load(body); // jQuery 遍历 #hotJobTop .topList li 是通过http://top.zhaopin.com 分析页面结构得到的 $('#hotJobTop .topList li').each(function (index) &#123; let obj = json[index] = &#123;&#125;; obj.name = $(this).find('.title').text().trim(); obj.num = $(this).find('.paddingR10').text().trim(); &#125;); // 打印数据 console.log(json);&#125;);执行 node app.js 就会得到如下结果。12345678910[ &#123; name: 'Java开发工程师', num: '340538人/天' &#125;, &#123; name: '软件工程师', num: '220873人/天' &#125;, &#123; name: '销售代表', num: '175053人/天' &#125;, &#123; name: '会计/会计师', num: '168225人/天' &#125;, &#123; name: '行政专员/助理', num: '150913人/天' &#125;, &#123; name: 'WEB前端开发', num: '140979人/天' &#125;, &#123; name: '助理/秘书/文员', num: '139098人/天' &#125;, &#123; name: '软件测试', num: '136399人/天' &#125;, &#123; name: '人力资源专员/助理', num: '123482人/天' &#125;, &#123; name: '用户界面（UI）设计', num: '107505人/天' &#125; ]一个简单的爬虫就写好了，看看前十有没有你从事的岗位吧！参考https://github.com/request/requesthttps://github.com/cheeriojs/cheerio","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"爬虫","slug":"爬虫","permalink":"http://blog.langpz.com/tags/爬虫/"}]},{"title":"node连接MySQL","slug":"node连接MySQL","date":"2018-05-10T15:40:04.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"node连接MySQL.html","link":"","permalink":"http://blog.langpz.com/node连接MySQL.html","excerpt":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。","text":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。安装1npm install mysql连接1234567891011121314151617const mysql = require('mysql');let connection = mysql.createConnection(&#123; host : 'localhost', user : 'root', password : 'password', database : 'test'&#125;);connection.connect(function(err) &#123; if (err) &#123; console.error('连接出错: ' + err.stack); return; &#125; console.log('连接成功 id ' + connection.threadId);&#125;);host：连接的服务器user：用户名默认是rootpassword：之前设置的MySQL密码database： 要连接的库常用的SQL语句SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。增1INSERT INTO user (username, pass) VALUES ('blog.langpz.com', '123456');INSERT INTO 表名称 VALUES (值1, 值2,….)指定所要插入数据的列INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)删1DELETE FROM user WHERE id = 0DELETE FROM 表名称 WHERE 列名称 = 值不加WHERE会删除所有行WHERE子句用于规定选择的标准。改1UPDATE user SET pass = 'bbb' WHERE username = '张三'UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值查1SELECT * FROM userSELECT 列名 FROM 表名 注： * 代表全部node操作MySQL查询123456connection.query('SELECT * FROM user WHERE username = \"blog.langpz.com\"', (err, results, fields) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;)删除123456connection.query('DELETE FROM user WHERE id = 1', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;)增加123456connection.query('INSERT INTO user(username, pass) VALUES(?, ?)',['lan', 'abc'], (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;)修改123456connection.query('UPDATE user SET pass = \"bbb\" WHERE username = \"lan\"', (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;)终止连接1234connection.end(function(err) &#123; // The connection is terminated now&#125;);connection.destroy();调用这两个方法都可以。基本操作就是这个流程，可以通过路由封装接口，写一个CRUD应用，mysql模块更多参数可以去看github。参考https://github.com/mysqljs/mysql","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Windows下安装MongoDB","slug":"Windows下安装MongoDB","date":"2018-05-08T15:30:32.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"Windows下安装MongoDB.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MongoDB.html","excerpt":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。","text":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。MongoDB特点和关系型数据库比较，面向文档的数据库不再有“行”（row）的概念，取而代之的是更为灵活的“文档”（document）模型。通过再文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系。另外，不再有预定义模式，文档的键（key）和值（value）不再是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易。可以进行快速迭代，所以开发进程得到加快。MongoDB基本概念文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行。集合(collection)可以看作是一个拥有动态模式(dynamic schema)的表。MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合。每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。下载和安装下载地址点击下载，下载完安装，用默认设置。运行MongoDB命令提示符（cmd）执行，具体路径需要看安装的版本，我的是3.6版本。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongod --dbpath d:\\db控制台会输出一些东西，没有报错MongoDB就启动了。这样启动比较麻烦，每次都要启动，所以可以把它注册成windows 的服务123// 使用管理员权限运行mongod --install --dbpath d:\\data\\db --logpath d:\\data\\log\\log.txtnet start MongoDB // 启动服务12services.msc // 查看服务net stop mongodb // 停止服务删除服务1mongod --remove --serviceName MongoDB // MongoDB是服务名MongoDB 还可以通过配置文件启动可以去官网查看https://docs.mongodb.com/manual/reference/configuration-options/连接MongoDB在打开一个命令提示符（cmd）之前运行的MongoDB那个不要关闭，因为没有注册成windows的服务，关闭就找不到数据库了。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongo这样就链接上数据库了，当然还会输出一大堆东西。操作MongoDB我们先创建一个数据库，再刚才连接MongoDB的cmd执行1use test02创建一个test02的数据库并切换过去。db变量指向当前数据库。向集合里插入文档，之前也讲了MongoDB没有预定义模式，所以不用新建表和表结构了。insert方法 把一条文档保存到集合里。1db.user_table.insert(&#123;\"name\", \"lanpangzhi\", \"age\": 18&#125;)查看集合里面的文档。find和findOne方法可以用于查询集合里的文档。只想查看一个文件，可以用findOne12db.user_table.find()db.user_table.findOne()find和findOne还可以接受一个查询文档作为限定条件。1db.user_table.find(&#123;\"name\": \"lanpangzhi\"&#125;)更新集合里面的文档update方法接受（至少）两个参数：第一个是限定条件（用于匹配待更新的文档），第二个是新的文档。1db.user_table.update(&#123;name: lanpangzhi&#125;,&#123;\"name\": \"lanpangzhi\", \"age\": 18, \"sex\": 1&#125;);删除集合里面的文档remove方法可将数据库的集合永久删除，如果不加参数默认把集合里面所有的文档删除。它可以接受一个限定条件的文档作为参数。1db.user_table.remove(&#123;\"name\": \"aaa\"&#125;)","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.langpz.com/tags/MongoDB/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"}]},{"title":"Windows下安装MySQL","slug":"Windows下安装MySQL","date":"2018-05-08T11:02:20.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"Windows下安装MySQL.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MySQL.html","excerpt":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。","text":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。下载下载地址点击，进入页面。注：MySQL安装程序是32位的，但会安装32位和64位二进制文件。点击download然后跳转到页面。可以不需要登陆和注册也可以下载。再点击，安装程序就下载了。安装打开安装程序，勾选同意协议，点击下一步(Next)现在只安装MySQL的服务端，点击下一步然后安装。设置MySQL密码，继续下一步。然后完成，其余配置都是用默认配置。使用Navicat for MySQL 管理MySQL下载地址可以用它去管理MySQL。新建库，新建表，修改数据删除数据。MySQL基本概念库： 文件夹-用来管理，无法存放数据，一个库可以存放很多张表。表： 文件-存放数据用的。列: 一列(数据元素) 包含了相同的数据, 例如用户的数据。行：一行是一组相关的数据，例如一条用户名和密码的数据。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。MySQL常用数据类型数据类型说明INT整数FLOAT浮点数DATE日期值DATETIME混合日期和时间值TIME时间值或持续时间VARCHAR变长字符串CHAR定长字符串参考https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Express路由","slug":"Express路由","date":"2018-05-07T17:50:08.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Express路由.html","link":"","permalink":"http://blog.langpz.com/Express路由.html","excerpt":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。","text":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。一个网站下面可能有很多地址例如:www.langpz.com/aaauser/www.langpz.com/user/aaawww.langpz.com/user/bbbwww.langpz.com/user/cccvip/www.langpz.com/vip/aaawww.langpz.com/vip/bbbwww.langpz.com/vip/ccc等等。。。咱们可以拆分成vip和user两个目录目录下再放子路由。先安装express 然后在项目根目录建一个app.js和routers文件夹，routers文件夹里面再建一个index.js文件和vip、user两个目录，两个目录下面分别建立index.js文件。1234567891011// app.jsconst express = require('express');const routers = require('./routers'); //引入路由let app = express();app.use('/vip', routers.vip); // 设置/vip路由中间件app.use('/user', routers.user); // 设置/user路由中间件app.listen(8000);12345678// routers/index.jslet vip = require('./vip'); // 引入vip文件下面的路由let user = require('./user'); // 引入user文件下面的路由// 导出路由module.exports = &#123; vip, user&#125;;12345678910111213141516171819// routers/vip/index.jsconst express = require('express'); // 必须要引入expresslet routerVip = express.Router(); // 创建router实例// 添加路由配置routerVip.get('/', (req, res) =&gt; &#123; res.send('我是vip根目录')&#125;);routerVip.get('/aaa', (req, res) =&gt; &#123; res.send('我是vip/aaa目录')&#125;);routerVip.get('/bbb', (req, res) =&gt; &#123; res.send('我是vip/bbb目录')&#125;);// 导出路由module.exports = routerVip;1234567891011121314151617181920// routers/user/index.jsconst express = require('express'); // 必须要引入expresslet routerUser = express.Router(); // 创建router实例// 添加路由配置routerUser.get('/', (req, res) =&gt;&#123; res.send('我是user根目录')&#125;);routerUser.get('/aaa', (req, res) =&gt; &#123; res.send('我是user/aaa目录')&#125;);routerUser.get('/bbb', (req, res) =&gt; &#123; res.send('我是user/bbb目录')&#125;);// 导出路由module.exports = routerUser;然后执行 node app.js 再浏览器输入http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"路由","slug":"路由","permalink":"http://blog.langpz.com/tags/路由/"}]},{"title":"Express框架cookie和session","slug":"Express框架cookie和session","date":"2018-05-06T17:32:54.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Express框架cookie和session.html","link":"","permalink":"http://blog.langpz.com/Express框架cookie和session.html","excerpt":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。","text":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。cookiecookie存在浏览器端，每次请求都会带上。缺点：不安全(用户可以随便串改)，大小（4k）。sessionsession只存在服务器端。优点：容量不限，比较安全（用户接触不到）。session实现是基于cookie的。风险：session_id 被泄露漏 session劫持。提醒用户不在在控制台输入(console)输入代码。session_id 足够复杂，定期更换。Express操作cookie先安装cookie-parser。1npm install cookie-parser -S123456789101112131415// app.jsconst express = require('express');const cookieParser = require('cookie-parser');let app = express();app.use(cookieParser()); // 设置cookieParser 中间件app.get('/', (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie res.cookie('user', 'lanpangzhi'); // 设置cookie res.send('OK');&#125;);app.listen(8000);在cmd执行 node app.js 浏览器输入http://localhost:8000/ 第一次控制台输出{}，再刷新就输出{user: ‘lanpangzhi’ }。现在就能获取和设置cookie了，但是有个问题，浏览器执行document.cookie = “user=aaa”,浏览器再刷新控制台就会输出{user: ‘aaa’ }。这样使用cookie不安全，敏感信息容易被篡改，所以要使用带签名的cookie。带签名的cookie123456789101112131415161718// app.jsconst express = require('express');const cookieParser = require('cookie-parser');let app = express();app.use(cookieParser('abc123456abc')); // 设置cookieParser 中间件 使用签名必须要设置字符串。app.get('/', (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie console.log(req.signedCookies); // 获取带签名的cookie res.cookie('user', 'lanpangzhi', &#123; signed: true // 设置带签名的cookie &#125;); res.send('OK');&#125;);app.listen(8000);再执行，就会发现浏览器cookie的值变成了s%3Alanpangzhi.i6hEUuhD%2Fd0miBMsGyRdktiDFmi%2BYfiJhQTcqKpQqIc ，再修改cookie的值，控制台就会输出{ user: false }，这样cookie就不会被简单的篡改了。req.cookies 获取cookie。res.cookie(name, value [, options]);name: cookie的名称(string)。value: cookie的值，(string or object)。options：options参数是一个可以具有以下属性的对象。如下值类型说明domainStringcookie的域名。 默认为网站的域名。encodeFunction用于cookie值编码的同步函数。 默认为encodeURIComponent。expiresDatecookie的有效期（如果未指定或设置为0），则创建会话cookie。httpOnlyBoolean将cookie标记为仅可由Web服务器访问。默认falsemaxAgeNumber设置cookie的到期时间、相对于当前时间的到期时间（以毫秒为单位）。pathStringcookie的路径。 默认为“/”secureBoolean将cookie标记为仅与HTTPS一起使用。默认falsesignedBoolean对cookie进行签名。默认falseExpress操作session先安装cookie-session。1npm install cookie-session -S1234567891011121314151617181920// app.jsconst express = require('express');const cookieSession = require('cookie-session');let app = express();app.use(cookieSession(&#123; secret: 'aaaa'&#125;)); // 设置cookieSession中间件app.get('/', (req, res) =&gt; &#123; if (req.session['num']) &#123; req.session['num']++; &#125;else&#123; req.session['num'] = 1; // 设置session &#125; res.send(`访问$&#123;req.session[\"num\"]&#125;次`);&#125;);app.listen(8000);在cmd执行 node app.js 浏览器输入http://localhost:8000/ 刷新浏览器就可以看到访问几次，把所有浏览器都关闭session就失效了，再进入页面就从第一次开始了。更多方法还有详细参数可以去github自行参考。参考http://expressjs.com/en/4x/api.htmlhttps://github.com/expressjs/cookie-parserhttps://github.com/expressjs/cookie-session","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"cookie","slug":"cookie","permalink":"http://blog.langpz.com/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://blog.langpz.com/tags/session/"}]},{"title":"javascript数据类型转换","slug":"javascript数据类型转换","date":"2018-05-05T17:14:25.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"javascript数据类型转换.html","link":"","permalink":"http://blog.langpz.com/javascript数据类型转换.html","excerpt":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。","text":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。默认是false的五个值1null undefined NaN 0 ''记住只有这五个值是假的剩下的全部是真的。转换规则如果是一个值判断是否是真假，除了默认是false的五个值剩下的全部是true。如果是两个值比较是否相等，遵循如下规则。val1 == val2 如果两个值可能不是同一数据类型，如果是==比较的话，会默认进行数据转换。2.1 object == object，比较永远不相等。2.2 object == string 先将对象转换成字符串（调用toString方法），然后再比较。[] 转换成字符串 &quot;&quot; {} 转换成字符串 &quot;[object Object]&quot; 2.3 object == boolean 先将对象转换成字符串（toString），再把字符串转换成数字（Number）、布尔值转换成数字（true 转换成 1 false 换成成 0）然后让两个数字进行比较。Number(&quot;&quot;) 会输出 0 2.4 object == number 先将对象转换成字符串（toString），再把字符串转换成数字（Number），再进行比较。2.5 number == boolean 布尔值转换成数字，然后再比较。2.6 number == string 字符串转换成数字，然后再比较。2.7 string == boolean 都转换成数字，，然后再比较。2.8 null == undefined 结果是true。2.9 null 或者 undefined 比较另外的所有值，结果都是false，不相等。例如：[] == false 返回 true 2.3规则。[] == [] 返回 false 2.1规则。2 == true 返回 false 2.5规则。=== 三个等号还会比较数据类型。这些规则背下来，就能完美的应付这样的面试题了，加油！","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"http://blog.langpz.com/tags/数据类型转换/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.langpz.com/tags/面试题/"}]},{"title":"Git生成SSH公钥","slug":"Git生成SSH公钥","date":"2018-05-05T16:40:31.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Git生成SSH公钥.html","link":"","permalink":"http://blog.langpz.com/Git生成SSH公钥.html","excerpt":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。","text":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。查看公钥是否生成过12cd ~/.sshls # 在Git bash下执行或者 C:\\Users\\Administrator.ssh 访问这个目录。看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。如果有公钥直接打开 id_rsa.pub 文件添加到GitHub和coding的SSH公钥里面，建议coding有效期选永久。生成公钥执行下面的命令。1ssh-keygen它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。直接回车就行。然后去C:\\Users\\Administrator.ssh目录 找到id_rsa.pub 文件就是生成好的公钥，添加到GitHub和coding。公钥的大概样子，全部复制。123456ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local测试公钥是否添加成功测试GitHub。1ssh git@github.com现在就添加成功了。测试Coding1ssh -T git@git.coding.net参考https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"},{"name":"SSH公钥","slug":"SSH公钥","permalink":"http://blog.langpz.com/tags/SSH公钥/"}]},{"title":"Express文件上传","slug":"Express文件上传","date":"2018-05-04T15:58:58.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Express文件上传.html","link":"","permalink":"http://blog.langpz.com/Express文件上传.html","excerpt":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。","text":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。安装Multer第一步先安装Multer到你的项目里。1npm install --save multer创建一个form表单这里就不用ajax去上传了。12345678910111213141516// index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8000\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"image\" /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;form表单enctype属性值说明application/x-www-form-urlencoded在发送前编码所有字符（默认）multipart/form-data不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。text/plain空格转换为 “+” 加号，但不对特殊字符编码。引用配置multer123456789101112131415161718192021222324252627282930// app.jsconst express = require('express');const multer = require('multer');const fs = require('fs');const path = require('path');const uploda = multer(&#123; dest: './uploads/' // 服务接收文件的路径&#125;);let app = express();app.use(uploda.any()); // multer放到express中间件里app.post('/', (req, res) =&gt; &#123; console.log(req.files); // req.files接收到的文件信息一个数组 // 添加后缀名，只支持一个文件上加后缀名，多文件改成递归 let newName = req.files[0].path + path.extname(req.files[0].originalname); console.log(newName, req.files[0].path); fs.rename(req.files[0].path, newName, (err) =&gt; &#123; if(err)&#123; console.log(err); res.sendStatus(500).send('error'); &#125;else&#123; res.send('OK，上传成功。'); &#125; &#125;);&#125;);app.listen(8000);在cmd执行 node app.js 打开index.html 选择文件上传，服务端就可以成功接收文件了。multer 还有一些别的方法和参数，可自行去github查看。参考https://github.com/expressjs/multer","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"文件上传","slug":"文件上传","permalink":"http://blog.langpz.com/tags/文件上传/"}]},{"title":"javascript数组去重(ES6版)","slug":"javascript数组去重-ES6版","date":"2018-05-02T16:49:44.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"javascript数组去重-ES6版.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重-ES6版.html","excerpt":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。","text":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。123var arr = [1,2,3,4,5,'1','2',3,3,'1'];arr = Array.from(new Set(arr));console.log(arr);Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。jsBin 地址","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://blog.langpz.com/tags/ES6/"},{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"}]},{"title":"css实现元素垂直水平居中-包括未知宽高的元素","slug":"css实现元素垂直居中-包括未知宽高的元素","date":"2018-04-28T13:14:04.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"css实现元素垂直居中-包括未知宽高的元素.html","link":"","permalink":"http://blog.langpz.com/css实现元素垂直居中-包括未知宽高的元素.html","excerpt":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。","text":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。第一种已知宽高（定位加负边距解决）兼容到IE6123456789position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;margin-left: -100px;margin-top: -100px;background: red;demo地址 JSBin第二种未知宽高 (定位加margin解决) 兼容到IE8 移动端推荐使用12345678910position: absolute;z-index: 8;left: 0;top: 0;bottom: 0;right: 0;width: 200px;height: 200px;margin: auto;background: red;如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin第三种未知宽高 (定位加transform解决) 兼容到IE9 移动端推荐使用12345678position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;transform: translate(-50%, -50%);background: red;如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin第四种未知宽高 (弹性盒子模型解决) 兼容到IE101234display: flex;display: -webkit-flex;align-items:center;justify-content: center;如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin第五种未知宽高 (table特性解决的) 兼容到IE6 PC端推荐使用12345678910111213141516171819202122232425#box&#123; width: 100px; height:100px; text-align:center; font-size:0; background: red&#125;#box:after,#box span&#123; display:inline-block; *display:inline; *zoom:1; width:0; height:100%; vertical-align:middle;&#125;#box:after&#123; content:'';&#125;#box p&#123; display:inline-block; *display:inline; *zoom:1; vertical-align:middle; font-size:16px;&#125;demo地址 JSBin参考http://demo.doyoe.com/css/alignment/","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"EJS模板引擎","slug":"ejs模板引擎","date":"2018-04-27T13:36:44.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"ejs模板引擎.html","link":"","permalink":"http://blog.langpz.com/ejs模板引擎.html","excerpt":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。","text":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。安装EJS1npm install ejsExpress设置EJS模板12app.set('view engine', 'ejs'); # view engine, 模板引擎app.set('views', './views'); # views, 放模板文件的目录将值输出到模板（HTML转义）12345// index.ejs&lt;%= arr %&gt;// Noderes.render('index', &#123;arr: [1,2,3,4]&#125;);判断123&lt;% if (user) &#123; %&gt; &lt;p&gt; &lt;%= user %&gt; &lt;/p&gt;&lt;% &#125; %&gt;循环123&lt;% for (var i = 0; i &lt; arr.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= arr[i] %&gt;&lt;/li&gt;&lt;% &#125; %&gt;include（不转义）1&lt;%- include('./common/header.ejs') %&gt;EJS标签&lt;% ‘脚本’ 标签，用于流程控制，无输出。&lt;%_ 删除其前面的空格符&lt;%= 输出数据到模板（输出是转义 HTML 标签）&lt;%- 输出非转义的数据到模板&lt;%# 注释标签，不执行、不输出内容&lt;%% 输出字符串 ‘&lt;%’%&gt; 一般结束标签-%&gt; 删除紧随其后的换行符_%&gt; 将结束标签后面的空格符删除","categories":[],"tags":[{"name":"EJS","slug":"EJS","permalink":"http://blog.langpz.com/tags/EJS/"}]},{"title":"Express中间件body-parser简单实现","slug":"Express中间件body-parser简单实现","date":"2018-04-18T11:49:16.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Express中间件body-parser简单实现.html","link":"","permalink":"http://blog.langpz.com/Express中间件body-parser简单实现.html","excerpt":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。","text":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。首先通过命令提示输入 mkdir lib &amp;&amp; cd lib。再输入touch body-parser.js。把下面的代码在body-parser.js 敲一遍。1234567891011121314151617// lib/body-parser.jsconst querystring = require('querystring');module.exports.urlencoded = function (req, res, next) &#123; let chunks = []; req.on('data', data =&gt; &#123; chunks.push(data); &#125;); req.on('end', () =&gt; &#123; // 合并Buffer。 let buf = Buffer.concat(chunks).toString(); // 把querystring解析过的json 放到 req.body上。 req.body = querystring.parse(buf); next(); &#125;);&#125;下面是主程序代码。1234567891011121314// app.jsconst express = require('express');const bodyParser = require('./lib/body-parser');let app = express();app.use(bodyParser.urlencoded);app.post('/', (req, res) =&gt; &#123; res.send(req.body);&#125;);app.listen(8000);现在就完成和body-parser中间件类似的功能了，req.body上面有请求过来的post数据。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"Express处理数据请求","slug":"Express处理数据请求","date":"2018-04-02T17:28:39.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Express处理数据请求.html","link":"","permalink":"http://blog.langpz.com/Express处理数据请求.html","excerpt":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。","text":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。处理get请求这个比较简单(不需要使用中间件)直接req.query就能获取到。1234567891011// 服务端代码const express = require('express');let app = express();app.get('/', (req, res) =&gt; &#123; console.log(req.query);&#125;);app.listen(8000);1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8000\" method=\"get\"&gt; &lt;input type=\"text\" name=\"user\" /&gt; &lt;/br&gt; &lt;input type=\"password\" name=\"pass\" /&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘123’, pass: ‘abc’ } 方便操作。处理post请求处理post请求需要用到body-parser这个中间件。这个中间件可以解析JSON、Raw、文本、URL-encoded格式的请求体。先安装中间件1npm install body-parser在项目中引用body-parser中间件。123456789101112131415// 服务端代码const express = require('express');const bodyParser = require('body-parser');let app = express();// 引用body-parser中间件app.use(bodyParser.urlencoded());app.post('/', (req, res) =&gt; &#123; // req.body post 提交过来的数据 console.log(req.body);&#125;);app.listen(8000);1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8000\" method=\"post\"&gt; &lt;input type=\"text\" name=\"user\" /&gt; &lt;/br&gt; &lt;input type=\"password\" name=\"pass\" /&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘lanpangzhi’, pass: ‘123456’ } 方便操作。这样我们就通过Express获取到get和post提交过来的数据了。urlencoded() 方法配置参数 (options)extended 设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true。但使用默认已被弃用。 请研究qs和querystring之间的差异并选择适当的设置。inflate 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。limit 设置最大请求头大小， 如果这是一个数字，那么该值指定字节数; 如果它是一个字符串，则将该值传递给字节库解析。默认为100kb。parameterLimit 用于设置URL编码值的最大参数数量， 如果请求包含的参数多于此值，那么413将返回给客户端。默认为1000。type 用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。verify 这个选项仅在verify(req, res, buf, encoding)时受支持。body-parser里面还有另外几个方法，可以自行去github看下。参考[https://github.com/expressjs/body-parser]","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"express简单入坑","slug":"express简单入坑","date":"2018-03-19T13:38:00.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"express简单入坑.html","link":"","permalink":"http://blog.langpz.com/express简单入坑.html","excerpt":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。","text":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。安装12npm init npm install express --save创建第一个应用12345678910// app.jsconst express = require('express');let app = express();app.get('/',(req,res) =&gt; &#123; res.send('express');&#125;);app.listen(8000);在命令行执行 node app.js 浏览器输入 http://localhost:8000/就可以访问了。路由控制app.get(path, (request, response) =&gt; {})根据path处理客户端发过来的GET请求。第一个参数：path请求的路径。第二个参数：回调函数，request(请求),response(响应)123456app.get('/',(req,res) =&gt; &#123; res.send('home');&#125;);app.get('/hello',(req,res) =&gt; &#123; res.send('hello');&#125;);app.post(path, (request, response) =&gt; {})根据path处理客户端发过来的POST请求。参数和app.get()方法一样。123456app.post('/', (req, res) =&gt; &#123; res.send('home');&#125;);app.post('/hello', (req, res) =&gt; &#123; res.send('hello');&#125;);app.all(path, (request, response) =&gt; {})根据path处理客户端发过来的所有http(GET,POST,PUT,DELETE,HEAD)请求。参数和app.get()方法一样。res.send() 发送各种类型的响应。res.download() 提示下载文件。res.redirect() 重定向请求。res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。静态文件Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。只需要把文件目录作为参数传给express.static，之后就可以访问到静态文件。1app.use(express.static('./public'))注： 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。中间件Express应用就是在调用各种中间件完成功能的，如cookie解析、文件上传、静态文件等。中间件（Middleware） 是一个函数。它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。12345678910111213app.use((req, res, next) =&gt; &#123; console.log('aaa'); next();&#125;)app.use((req, res, next) =&gt; &#123; console.log('bbb'); next()&#125;)app.use((req, res, next) =&gt; &#123; console.log('ccc');&#125;)可以看到next 的作用，把控制器交给下一个中间件。可以利用中间件特性来处理登陆用户。检查数据是否合法。检查数据是否存在。检查数据密码是否正确。1234567891011121314151617181920212223app.get('/login', (req, res, next) =&gt; &#123; if(合法)&#123; next() &#125;else&#123; res.send('用户名不合法') &#125;&#125;)app.get('/login', (req, res, next) =&gt; &#123; if(存在)&#123; next() &#125;else&#123; res.send('用户名不存在') &#125;&#125;)app.get('/login', (req, res, next) =&gt; &#123; if(密码正确)&#123; res.send('登陆成功') &#125;else&#123; res.send('密码不正确') &#125;&#125;)中间件的大概用法就是这样。模板引擎先安装ejs模板npm install ejs -S12app.set('view engine', 'ejs'); # view engine, 模板引擎app.set('views', './views'); # views, 放模板文件的目录1234567891011121314// index.jsconst express = require('express');const ejs = require('ejs');let app = express();app.set('view engine', 'ejs');app.set('views', './views');app.get('/', (req, res) =&gt; &#123; res.render('index',&#123;title: 'hello'&#125;);&#125;);app.listen(8000);12345678910111213// index.ejs&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= title %&gt;&lt;/body&gt;&lt;/html&gt;在命令行里执行node index.js，就可以看到模板了。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"node处理前台get请求","slug":"node处理前台get请求","date":"2018-03-02T10:07:32.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"node处理前台get请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台get请求.html","excerpt":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。","text":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。服务端代码123456789101112const http = require('http');const url = require('url');let app = http.createServer((req, res) =&gt; &#123; let getUrl = url.parse(req.url, true); if (getUrl.pathname === '/getUser')&#123; console.log(url.parse(req.url, true).query); res.end(url.parse(req.url, true).query.user); &#125;&#125;);app.listen(8000);先搭一个服务器监听8000端口，再把请求的链接用URL模块解析成对象，判断请求路径，返回user。客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8000/getUser\" method=\"get\"&gt; &lt;input type=\"text\" name=\"user\" /&gt; &lt;/br&gt; &lt;input type=\"password\" name=\"pass\" /&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。前台页面会显示你输入的user。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"url模块","slug":"url模块","date":"2018-03-01T16:03:22.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"url模块.html","link":"","permalink":"http://blog.langpz.com/url模块.html","excerpt":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。","text":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。url结构说明网址：http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash从node.js 中文网拿的图。url.parse(urlString[, parseQueryString[, slashesDenoteHost]])123let url = require('url');console.log(url.parse('http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top'))把url字符串解析成url对象。输出:12345678910111213&#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'langpz.com:80', port: '80', hostname: 'langpz.com', hash: '#top', search: '?callback=fn', query: 'callback=fn', pathname: '/aaa/ccc/ddd', path: '/aaa/ccc/ddd?callback=fn', href: 'http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top' &#125;protocol: 请求协议。slashes: slashes 属性是一个 boolean，如果 协议 中的冒号后面跟着两个 ASCII 斜杠字符（/），则值为 true。auth： URL的用户名与密码部分。host: URL的主机部分包括端口号。port：主机的端口号。hostname：主机名部分。hash： 锚点部分。search： 整个查询字符串部分，包括前面的?号query: 查询字符串部分，不包括前面的?号pathname：URL 的整个路径部分。path： pathname 与 search 组成部分的串接。href： 解析后的完整的 URL 字符串，protocol 和 host 都会被转换为小写的。第二个参数是布尔值，如果是 true，query值是一个对象。 默认为 false。第三个参数是布尔值，如果是 true，则 // 之后至下一个 / 之前的字符串会被解析作为 host。 例如，//foo/bar 会被解析为 {host: ‘foo’, pathname: ‘/bar’} 而不是 {pathname: ‘//foo/bar’}。 默认为 false。url.format(urlObject)12345678910111213141516let url = require('url');console.log(url.format(&#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'langpz.com:80', port: '80', hostname: 'langpz.com', hash: '#top', search: '?callback=fn', query: 'callback=fn', pathname: '/aaa/ccc/ddd', path: '/aaa/ccc/ddd?callback=fn', href: 'http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top'&#125;));url.parse()的反向操作，把url对象解析成url字符串url.resolve(from, to)12345let url = require('url');console.log(url.resolve('/one/two/three','four')) # 输出 /one/two/fourconsole.log(url.resolve('http://blog.langpz.com/', 'aaa')) # 输出 http://blog.langpz.com/aaaconsole.log(url.resolve('http://blog.langpz.com/aaa', 'bbb')) # 输出 http://blog.langpz.com/bbb把最后一个/没有内容后面追加to参数，有内容则替换。参考http://nodejs.cn/api/url.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"node处理前台post请求","slug":"node处理前台post请求","date":"2018-03-01T10:29:37.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"node处理前台post请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台post请求.html","excerpt":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。","text":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。服务端代码123456789101112131415161718// http.jslet http = require('http');let querystring = require('querystring');let app = http.createServer((req, res) =&gt; &#123; let str = ''; if (req.url === '/post')&#123; req.on('data', (data) =&gt; &#123; str += data; &#125;); req.on('end', () =&gt; &#123; console.log(querystring.parse(str)); &#125;); &#125;&#125;);app.listen(8000)先搭一个服务器监听8000端口，判断请求路径，再绑定data事件接收客户端发过来的post请求，接受用querystring模块处理接收的数据。客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://localhost:8000/post\" method=\"post\"&gt; &lt;input type=\"text\" name=\"user\" /&gt; &lt;/br&gt; &lt;input type=\"password\" name=\"pass\" /&gt; &lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"stream模块","slug":"stream模块","date":"2018-02-27T13:27:30.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"stream模块.html","link":"","permalink":"http://blog.langpz.com/stream模块.html","excerpt":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。","text":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。为什么使用stream我们之前读文件用的是readFile()把整个文件读入到内存，如果文件小还可以，假如你读取的文件有几个G就会把内存撑爆，这个时候就需要stream(流)了，收到一块数据，就读取一块。这样占用内存就会小很多。流的类型Node.js 中有四种基本的流类型：Readable - 可读的流Writable - 可写的流Duplex - 可读写的流Transform - 在读写过程中可以修改和变换数据的 Duplex 流可读流的常用事件data 当有数据可读时触发end 没有更多的数据可读时触发。error 在接收和写入过程中发生错误时触发。可读流12345678910111213let fs = require('fs');let rs = fs.createReadStream('./hello.txt',&#123; encoding: 'utf8'&#125;);rs.on('data', data =&gt; &#123; console.log('读取中--------' + data +'--------') # 如果文件过大会分几次输出数据。&#125;);rs.on('end', () =&gt; &#123; console.log('读取完毕'); # data读取完触发 end 事件。&#125;)第一个参数是路径。第二个参数是可配置对象。flags: 读取模式默认为r（只读）encoding: 设置编码默认nullmode: 设置文件模式默认0o666start: 用整数表示文件开始读取字节数的索引位置end: 用整数表示文件结束读取字节数的索引位置highWaterMark: 最高水位线，停止从底层资源读取前，内部缓存区最多存放的字节数。默认64kb暂停流对象触发 ‘data’ 事件1rs.pause()重新流对象触发 ‘data’ 事件1rs.resume()可写流12345678910let fs = require('fs');let stream = fs.createWriteStream('./1.txt')stream.write('lan') # 写入数据stream.write('pang') # 写入数据stream.end('zi') # 写入数据stream.on('finish', function() &#123; console.log(\"写入完成。\");&#125;);第一个参数是路径。第二个参数是可配置对象。flags: 读取模式默认为wencoding: 设置编码默认utf8mode: 设置文件模式默认0o666start: 用整数表示文件开始写入字节数的索引位置highWaterMark: 最高水位线，内部缓存区最多存放的字节数。默认16kbstream.write(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。返回一个boolean值。写入数据的时候内部缓冲区的大小小于创建流时设定的 highWaterMark 阈值，函数将返回 true 。如果返回值为 false ，应该停止向流中写入数据，直到 ‘drain’ 事件被触发。123456789101112131415161718192021let fs = require('fs');let stream = fs.createWriteStream('./1.txt',&#123; highWaterMark: 10&#125;);let i = 0;let max = 100;let write = () =&gt; &#123; let flag = true; while (i &lt; max &amp;&amp; flag)&#123; console.log('写入' + i); i++; flag = stream.write(String(i)); &#125;&#125;write();stream.on('drain',() =&gt; &#123; console.log('继续写入'+ i); write();&#125;);drain事件如果调用 stream.write(chunk) 方法返回 false，’drain’ 事件会在适合恢复写入数据到流的时候触发。stream.end(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。调用 writable.end() 方法表明接下来没有数据要被写入 Writable。通过传入可选的 chunk 和 encoding 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 callback 函数，它将作为 ‘finish’ 事件的回调函数。在调用了 stream.end() 方法之后，再调用 stream.write() 方法将会导致错误。pipe()12345let fs = require('fs');let rs = fs.createReadStream('./1.txt');let ws = fs.createWriteStream('./2.txt');rs.pipe(ws)readable.pipe(destination[, options])readable 可读流对象destination 可写流对象readable.pipe() 绑定一个 Writable 到 readable 上， 将可写流自动切换到 flowing 模式并将所有数据传给绑定的 Writable。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。pipe 方法是使用流最简单的方式。通常的建议是要么使用 pipe 方法、要么使用事件来读取流，要避免混合使用两者。一般情况下使用 pipe 方法时你就不必再使用事件了。但如果你想以一种更加自定义的方式读取流，就要用到事件了。参考http://nodejs.cn/api/stream.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"path模块","slug":"path模块","date":"2018-02-26T11:17:42.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"path模块.html","link":"","permalink":"http://blog.langpz.com/path模块.html","excerpt":"path模块path模块是Node.js提供用于处理文件与目录的路径。","text":"path模块path模块是Node.js提供用于处理文件与目录的路径。连接路径123let path = require('path');console.log(path.join(__dirname,'lan','pang','zi')) # 输出c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi为什么要使用这个方法，因为Windows和liunx系统路径分隔符不一样，liunx系统是”/“，Windows系统是”\\”，path.join()会正确使用当前系统的路径分隔符。获取路径扩展名123let path = require('path');console.log(path.extname(__filename)) # 输出 .js从 path 的最后一部分中的最后一个 . 字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名的第一个字符是 .，则返回一个空字符串。1234console.log(path.extname('.lanpangzhi')) # 输出空字符串console.log(path.extname('lanpangzhi.github.exe')) # 输出 .execonsole.log(path.extname('lanpangzhi.')) # 输出 .console.log(path.extname('lanpangzhi')) # 输出空字符串获取绝对路径123let path = require('path');console.log(path.resolve('lan/pang','zi')) # 输出 c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi路径的序列是从右往左被处理的。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。如果不传参数会得到当前所在的目录判断是否是绝对路径1234let path = require('path');console.log(path.isAbsolute('/lanpangzhi')) # 输出 trueconsole.log(path.isAbsolute('lanpangzhi/')) # 输出 false如果 path 不是一个字符串，则抛出 TypeError。获取路径中的文件名1234let path = require('path');console.log(path.basename(__filename)) # 输出 http.jsconsole.log(path.basename(__filename,'.js')) # 输出 http第一个参数是路径。第二个参数是文件扩展名，如果加上只返回文件名。path.sep 文件路径分隔符path.delimiter 环境变量路径分隔符参考http://nodejs.cn/api/path.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"fs模块","slug":"fs模块","date":"2018-02-22T14:32:19.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"fs模块.html","link":"","permalink":"http://blog.langpz.com/fs模块.html","excerpt":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。","text":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。读取文件同步方法 readFileSync()12345678let fs = require('fs');try&#123; let buf = fs.readFileSync('./hello.txt', &#123; encoding: 'utf-8' &#125;); console.log(buf); # 输出: 入坑了..&#125;catch(err)&#123; console.log('读取失败了: ' + err.message)&#125;readFileSync方法的第一个参数是文件路径可以是（string|Buffer|URL|integer）类型，第二个参数可以是一个表示配置的对象。默认的配置对象是{ encoding: null, flag: ‘r’ }，encoding：文件编码默认为null，flag：读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回原始的 buffer。异步方法 readFile()1234567let fs = require('fs');fs.readFile('./hello.txt', &#123; encoding: 'utf-8' &#125;, (err,data) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(data); # 输出: 入坑了..&#125;);和readFileSync方法参数一样，只多了一个回调函数。回调有两个参数 (err, data)，其中 data 是文件的内容。写入文件同步方法 writeFileSync()123let fs = require('fs');fs.writeFileSync('./1.txt','node入坑指南...',&#123;encoding: 'utf8'&#125;)第一个参数是路径第二的参数是写入的数据第三个参数是一个可配置的对象{encoding：utf8, mode: 0o666, flag: ‘w’}encoding: 文件编码默认为utf8mode： 设置文件模式(权限)，文件创建默认权限为 0o666(可读，可写)。flag： 文件打开模式默认为w(写入)如果 options 是一个字符串，则它指定了字符编码。例如：1fs.writeFileSync('./1.txt', '111...', 'utf8')异步方法 writeFile()12345678let fs = require('fs');fs.writeFile('./2.txt','蓝胖纸',(err) =&gt; &#123; if(err)&#123; throw err; &#125; console.log('写入成功');&#125;)异步地写入数据到文件，如果文件已经存在，则替代文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。和writeFileSync方法参数一样，只多了一个回调函数。创建目录同步方法 mkdirSync()1fs.mkdirSync('./hello',0o777);在当前目录下面创建一个hello的文件夹。第一个参数是路径。第二个参数是设置文件模式(权限)，默认为0o777。异步方法 mkdir()123fs.mkdir('./lanpangzhi', 0o777, function (err) &#123; if (err) throw err;&#125;);和mkdirSync方法参数一样，只多了一个回调函数。注： 所有的异步方法最后一个参数都是回调函数，回调函数的第一个参数都是异常。读取目录同步方法 readdirSync()12let a = fs.readdirSync(process.cwd())console.log(a)输出当前工作目录下的文件数组列表。第一个参数是路径。第二个参数是设置编码。异步方法 readdir()123456fs.readdir(process.cwd(),(err, files) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(files)&#125;)和readdirSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是文件数组列表。查看文件信息同步方法 statSync()12let stats = fs.statSync('./a.js');console.log(stats)接受一个路径参数，返回一个 fs.Stats 实例。fs.Stats 实例的方法方法描述stats.isFile()如果是文件返回 true，否则返回 false。stats.isDirectory()如果是目录返回 true，否则返回 false。stats.isBlockDevice()如果是块设备返回 true，否则返回 false。stats.isCharacterDevice()如果是字符设备返回 true，否则返回 false。stats.isSymbolicLink()如果是软链接返回 true，否则返回 false。stats.isFIFO()如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。stats.isSocket()如果是 Socket 返回 true，否则返回 false。Stat 时间值属性描述atime“访问时间” - 文件数据最近被访问的时间。mtime“修改时间” - 文件数据最近被修改的时间。ctime“变化时间” - 文件状态最近更改的时间。birthtime“创建时间” - 文件创建的时间。异步方法 stat()12345678let fs = require('fs');fs.stat('./hello', (err, stats)=&gt;&#123; if(err)&#123; throw err; &#125; console.log(stats);&#125;);和statSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是fs.Stats实例。删除文件同步方法 unlinkSync()123let fs = require('fs');fs.unlinkSync('./1.txt');删除当前目录下的1.txt文件，返回undefined。第一个参数是路径。异步方法 unlink()1234567let fs = require('fs');fs.unlink('./2.txt', (err) =&gt; &#123; if(err)&#123; console.log(err) &#125;&#125;)和unlinkSync方法参数一样。参考http://nodejs.cn/api/fs.htmlhttp://www.runoob.com/nodejs/nodejs-fs.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"querystring模块","slug":"querystring模块","date":"2018-02-09T13:10:53.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"querystring模块.html","link":"","permalink":"http://blog.langpz.com/querystring模块.html","excerpt":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。","text":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。把字符串转换成对象 querystring.parse(str[, sep[, eq[, options]]])12345678910111213141516171819202122232425262728let querystring = require('querystring');let query = querystring.parse('name=lanpangzhi&amp;age=18');console.log(query); # 输出&#123; name: 'lanpangzhi', age: '18' &#125;// 添加第二个参数 seplet query2 = querystring.parse('name=lanpangzhi@age=18','@');console.log(query2); # 输出&#123; name: 'lanpangzhi', age: '18' &#125;// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 '&amp;'。// 添加第三个参数 eqlet query3 = querystring.parse('name|lanpangzhi@age|18','@','|');console.log(query3); // eq: 用于界定查询字符串中的键与值的子字符串。默认为 '='。// sep eq 可以替换割分字符串的关键字，在某些特定的场景会用的。// 第四个参数用得比较少let query = querystring.parse('name|lanpangzhi@age|18@age2|20@age3|21@age4|555','@','|',&#123; decodeURIComponent: function test(str) &#123; return str+= '1' &#125;, maxKeys: 4&#125;);console.log(query); # 输出 &#123; name1: 'lanpangzhi1', age1: '181', age21: '201', age31: '211' &#125;// 第四个参数是一个对象， 里面有 decodeURIComponent 和 maxKeys 两个参数。// decodeURIComponent: 解码查询字符串的字符时使用的函数。默认为 querystring.unescape()。// maxKeys: 指定要解析的键的最大数量。默认为 1000。指定为 0 则不限制。// 我刚才指定是4 所以 age4 这个参数没输出。把对象转换成字符串 querystring.stringify(obj[, sep[, eq[, options]]])1234567891011121314151617181920let querystring = require('querystring');let obj = &#123; name: 'lanpangzhi', baz: ['qux', 'quux'], age: '18' &#125;;let str = querystring.stringify(obj);console.log(str); # 输出 name=lanpangzhi&amp;baz=qux&amp;baz=quux&amp;age=18// 添加第二个参数 seplet obj = &#123; name: 'lanpangzhi', age: '18' &#125;;let str = querystring.stringify(obj,'@');console.log(str); # 输出 name=lanpangzhi@age=18// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 '&amp;'。// 添加第三个参数 eqlet obj = &#123; name: 'lanpangzhi', age: '18' &#125;;let str = querystring.stringify(obj,'@','|');console.log(str);// eq: 用于界定查询字符串中的键与值的子字符串。默认为 '='。// 第四个参数 options 基本上用不到// encodeURIComponent &lt;Function&gt; : 把对象中的字符转换成查询字符串时使用的函数。默认为 querystring.escape()。querystring.stringify 和 querystring.parse 功能正好是对应的， 基本上第四个参数用不到，第二和第三个参数只有在某些特定的场景才会使用，指定切割默写字符，或者输出某些字符。querystring 这个模块还有两个方法，但是基本上不会用到，更多可以去node中文网或者官网查看。新年快乐2018参考http://nodejs.cn/api/querystring.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Buffer对象","slug":"Buffer对象","date":"2018-02-06T13:43:40.000Z","updated":"2025-09-06T12:42:50.048Z","comments":true,"path":"Buffer对象.html","link":"","permalink":"http://blog.langpz.com/Buffer对象.html","excerpt":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。","text":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。创建一个Buffer对象Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。Buffer.from(array) 返回一个新建的包含所提供的字节数组的副本的 Buffer。Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。Buffer.from(buffer) 返回一个新建的包含所提供的 Buffer 的内容的副本的 Buffer。Buffer.from(string[, encoding]) 返回一个新建的包含所提供的字符串的副本的 Buffer。Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的被填满的 Buffer 实例。这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝不会包含旧的和潜在的敏感数据。Buffer.allocUnsafe(size)与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。123456789101112131415161718192021// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);buf3.fill(0)// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。数组里一定是0-255的数，否则会不识别，返回00const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1');在 Node.js v6 之前的版本中Buffer 实例是通过 new Buffer 构造函数创建的，因为 new Buffer() 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 new Buffer() 的参数、或未能正确地初始化新分配的 Buffer 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。为了使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被 废弃，并由 Buffer.from()、Buffer.alloc()、和 Buffer.allocUnsafe() 方法替代。Node.js 建议开发者们应当把所有正在使用的 new Buffer() 构造函数迁移到这些新的 API 上。Buffer 的转换Buffer对象与普通的 JavaScript 字符串的互相转换，需要指定编码格式。目前Node.js 目前支持以下的字符编码。‘ascii’ - 仅支持 7 位 ASCII 数据。‘utf8’‘utf16le’‘ucs2’‘base64’‘latin1’‘binary’‘hex’12345678// 字符串转Bufferconst buf = Buffer.from('node', 'ascii'); // Buffer转hex编码字符串 - 输出 6e6f6465console.log(buf.toString('hex'));// Buffer转base64编码字符串 - 输出 bm9kZQ==console.log(buf.toString('base64'));字符串转BufferBuffer.from(string[, encoding])encoding 不传参数会默认utf8编码进行转码和存储。字符串转Buffer实例方法buf.toString([encoding[, start[, end]]])encoding 解码使用的字符编码。默认: ‘utf8’。start 开始解码的字节偏移量。默认: 0。end 结束解码的字节偏移量（不包含）。 默认: buf.length。注：如果Buffer对象由多种编码写入，就需要在局部指定定不同的编码，才能转换回正常的编码。判断一个对象是否是Buffer对象Buffer.isBuffer(obj)如果 obj 是一个 Buffer 则返回 true ，否则返回 false 。12const buf1 = Buffer.alloc(10);console.log(Buffer.isBuffer(buf1)) # 返回true合并BufferBuffer.concat(list[, totalLength])list &lt;Array&gt; 要合并的 Buffer 或 Uint8Array 实例的数组totalLength &lt;integer&gt; 合并时 list 中 Buffer 实例的总长度返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。12345678const buf1 = Buffer.from('蓝');const buf2 = Buffer.from('胖');const buf3 = Buffer.from('纸');const len = buf1.length + buf2.length + buf3.length;console.log(len) # 输出9 一个汉字三个字节console.log(Buffer.concat([buf1, buf2, buf3], len).toString())获取字符长度Buffer.byteLength(string[, encoding])encoding 不传参数会默认utf8编码1console.log(Buffer.byteLength('蓝胖')) # 输出6 一个汉字三个字节参考http://nodejs.cn/api/buffer.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"global对象","slug":"global对象","date":"2018-02-02T14:33:27.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"global对象.html","link":"","permalink":"http://blog.langpz.com/global对象.html","excerpt":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。","text":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。全局变量在所有模块中均可使用。 但以下变量的作用域只在模块内12345__dirname__filenameexportsmodulerequire()__dirname1console.log(__dirname) # 获取当前模块的文件所在的文件夹名称的绝对路径__filename1console.log(__filename) # 获取当前模块的文件名称-解析后的绝对路径setImmediate(callback[, …args])123setImmediate(() =&gt; &#123; console.log('坑呀') # 把参数函数放到下一个时间环中执行&#125;);clearImmediate(immediate)1234let a = setImmediate(() =&gt; &#123; console.log('坑呀') # 取消一个由 setImmediate() 创建的 Immediate 对象&#125;);clearImmediate(a)process 进程process.cwd()1console.log(process.cwd()) # 方法返回 Node.js 进程当前工作的目录。process.argv1234567891011// a.jsconsole.log(process.argv) // 执行node a.js a=1 b=2// 输出[ 'C:\\\\Program Files\\\\nodejs\\\\node.exe', 'c:\\\\Users\\\\windows\\\\Desktop\\\\新建文件夹\\\\a.js', 'a=1', 'b=2' ]process.argv 属性返回一个数组，这个数组包含了启动Node.js进程时的命令行参数。第一个元素为process.execPath。如果需要获取argv[0]的值请参见 process.argv0。第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。process.env1console.log(process.env) # 返回一个包含用户环境信息的对象可以修改这个对象12process.env.foo = 'bar';console.log(process.env.foo); # 输出bar但是不可以用这种方法去修改1node http.js 'process.env.foo = \"bar\"'用 delete从process.env中删除一个属性123process.env.foo = 'bar';delete process.env.foo;console.log(process.env.foo); # 输出 undefined注: 在process.env中新增一个属性，会将属性值转换成字符串、 在Windows系统下，环境变量是不区分大小写的。process.memoryUsage()1234567console.log(process.memoryUsage()) # 返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。// 输出&#123; rss: 23588864, heapTotal: 7708672, heapUsed: 4430656, external: 8224 &#125;rss（resident set size）：所有内存占用，包括指令区和堆栈。heapTotal：”堆”占用的内存，包括用到的和没用到的。heapUsed：用到的堆的部分。external： V8 引擎内部的 C++ 对象占用的内存。process.chdir(directory)1234567console.log(process.cwd())process.chdir('..') # 方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。console.log(process.cwd())// 输出 '..'切换到上一级目录C:\\Users\\windows\\Desktop\\新建文件夹C:\\Users\\windows\\Desktopprocess.nextTick(callback[, …args])123process.nextTick(function()&#123; console.log('nextTick'); # 放到当前任务末尾执行&#125;)参考http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttp://nodejs.cn/api/process.html#process_processhttp://nodejs.cn/api/globals.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"http模块","slug":"http模块","date":"2018-01-15T17:05:37.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"http模块.html","link":"","permalink":"http://blog.langpz.com/http模块.html","excerpt":"http模块http模块是node提供搭建http客户端和服务端的核心模块。","text":"http模块http模块是node提供搭建http客户端和服务端的核心模块。什么是客户端和什么是服务端客户端（Client），是指与服务器相对应，为客户提供本地服务的程序。一般安装在普通的用户机上，需要与服务端互相配合运行。互联网发展以后，较常用的客户端包括了如万维网使用的网页浏览器，收寄电子邮件时的电子邮件客户端，以及即时通信的客户端软件等。服务端(Server)，是为客户端服务的，服务的内容诸如向客户端提供资源，保存客户端数据。是实现游戏特色化的重要途径，也是最直接可以通过游戏表现出来的技术，比如你要修改某个NPC的参数，重加载后，在游戏内立刻体现出来。搭建一个服务器123456789var http = require('http');var app = http.createServer(function(request,response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.write('入坑了...'); response.end();&#125;);app.listen(8000);http.createServer() 创建一个服务器的实例，它的参数是一个函数，函数里有两个参数request和response，request是从客户端的请求、response是服务端的响应。输入 http://localhost:8000 就可以看到（入坑了…）这几个字。代表创建成功。response.writeHead() 发送一个http响应头给请求。response.write() 向客户端发送响应体。response.end() 结束响应。listen() 监听的端口。客户端向HTTP服务器发起请求http.request(options[, callback])12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// request.jsvar http = require('http');var querystring = require('querystring');const postData = querystring.stringify(&#123; 'msg': 'Hello World!'&#125;);const options = &#123; hostname: 'localhost', port: 80, path: '/', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`状态码: $&#123;res.statusCode&#125;`); console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding('utf8'); res.on('data', (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on('end', () =&gt; &#123; console.log('响应中已无数据。'); &#125;);&#125;);req.on('error', (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`);&#125;);// 写入数据到请求主体req.write(postData);req.end();// sever.jslet http = require('http');let querystring = require('querystring');let app = http.createServer( (res,req) =&gt; &#123; let str = ''; res.on('data', (data) =&gt; &#123; str += data &#125;); res.on(\"end\", () =&gt; &#123; str = querystring.parse(str) console.log(str) // 向客户端返回数据 req.end(`提交成功了: $&#123;str.msg&#125;`) &#125;) &#125;);app.listen(80);客户端会输出1234状态码: 200响应头: &#123;\"date\":\"Fri, 02 Feb 2018 03:37:39 GMT\",\"connection\":\"close\",\"content-length\":\"29\"&#125;响应主体: 提交成功了: Hello World!响应中已无数据。我们可以写个定时器用request方法，一直向某个网站提交信息。options: Object | string | URLprotocol &lt;string&gt; 使用的协议。默认为 http:。host &lt;string&gt; 请求发送至的服务器的域名或 IP 地址。默认为 localhost。hostname &lt;string&gt; host 的别名。为了支持 url.parse()，hostname 优先于 host。family &lt;number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。port &lt;number&gt; 远程服务器的端口。默认为 80。localAddress &lt;string&gt; 为网络连接绑定的本地接口。socketPath &lt;string&gt; Unix 域 Socket（使用 host:port 或 socketPath）。method &lt;string&gt; 指定 HTTP 请求方法的字符串。默认为 ‘GET’。path &lt;string&gt; 请求的路径。默认为 ‘/‘。 应包括查询字符串（如有的话）。如 ‘/index.html?page=12’。 当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。headers &lt;Object&gt; 包含请求头的对象。auth &lt;string&gt; 基本身份验证，如 ‘user:password’ 用来计算 Authorization 请求头。agent &lt;http.Agent&gt; | &lt;boolean&gt; 控制 Agent 的行为。 可能的值有：undefined (默认): 对该主机和端口使用 http.globalAgent。Agent 对象：显式地使用传入的 Agent。false: 创建一个新的使用默认值的 Agent。createConnection &lt;Function&gt; 当不使用 agent 选项时，为请求创建一个 socket 或流。 这可以用于避免仅仅创建一个自定义的 Agent 类来覆盖默认的 createConnection 函数。详见 agent.createConnection()。timeout &lt;number&gt;: 指定 socket 超时的毫秒数。 它设置了 socket 等待连接的超时时间。发起get请求 http.get(options[, callback])123456789101112131415161718192021222324252627var http = require('http');http.get('http://blog.langpz.com', (res) =&gt; &#123; const &#123; statusCode &#125; = res; let str = \"\"; let error; if (statusCode !== 200) &#123; error = new Error('请求失败。\\n' + `状态码: $&#123;statusCode&#125;`); &#125; res.on(\"data\", (data) =&gt; &#123; str += data &#125;); if (error) &#123; console.error(error.message); // 消耗响应数据以释放内存 res.resume(); return; &#125; res.on(\"end\", () =&gt; &#123; console.log(str) &#125;) &#125;).on('error', (e) =&gt; &#123; console.error(`出错了: $&#123;e.message&#125;`);&#125;);网站内容就爬下来了。该方法与 http.request() 唯一的区别是它设置请求方法为 GET 且自动调用 req.end()。参考https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AFhttps://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AFhttp://nodejs.cn/api/http.html#http_http_request_options_callback","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Node模块机制","slug":"Node模块机制","date":"2018-01-08T16:11:02.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Node模块机制.html","link":"","permalink":"http://blog.langpz.com/Node模块机制.html","excerpt":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。","text":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。一个Node应用由模块组成，每个js文件就是一个独立模块。npm基于commonjs实现包的管理使我们开发Node.js更方便。commonjs规范引用模块在commonjs规范中，定义了 require() 方法，这个方法接受一个模块的标识。1var math = require('math');定义模块模块有自己的作用域。在模块里面定义的变量、函数、类，都是私有的，对其他文件不可见。上下文中提供了一个 exports 对象可以导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表当前模块，exports 是 module 的属性。12345// math.jsfunction add(a,b)&#123; return a + b;&#125;exports.add = add; # 导出一个add的方法再新建一个文件就可以用 require()引用这个模块了123// app.jsvar math = require('math');console.log(math.add(1,2)); # 3模块标识模块标识就是传递给 require() 方法的参数，它必须是符合小驼峰命名的规范，或者以 .. 开头的相对路径，或者绝对路径。它可以没有文件后缀名.js。模块缓存加载模块后会被缓存,多次加载还是同一个对象。查看模块缓存 require.cache查看模块绝对路径 require.resolve(./math.js)删除模块的缓存 require.cache[require.resolve(./math.js)]模块的循环加载123456789101112131415161718192021// a.jsconsole.log('a 开始');exports.done = false;const b = require('./b.js');console.log('在 a 中，b.done = %j', b.done);exports.done = true;console.log('a 结束');// b.jsconsole.log('b 开始');exports.done = false;const a = require('./a.js');console.log('在 b 中，a.done = %j', a.done);exports.done = true;console.log('b 结束');// main.jsconsole.log('main 开始');const a = require('./a.js');const b = require('./b.js');console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);当 main.js 加载 a.js 时，a.js 又加载 b.js。 此时，b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：123456789node main.jsmain 开始a 开始b 开始在 b 中，a.done = falseb 结束在 a 中，b.done = truea 结束在 main 中，a.done=true，b.done=truemodule对象module.children 被该模块引用的模块对象。module.id 模块的标识符。 通常是完全解析后的文件名。module.parent 最先引用该模块的模块。module.paths 模块的搜索路径。… 更多去官网查询Node的模块在Node中，模块分为两类：一类是Node提供的模块，称为核心模块。另外一类是用户编写的模块，称为文件模块。核心模块定义在 Node.js 源代码的 lib/ 目录下。require() 总是会优先加载核心模块。 例如，require(‘http’) 始终返回内置的 HTTP 模块，即使有同名文件。module.exports和exports区别exports是module.exports对象的引用12345678910111213function require(/* ... */) &#123; const module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // 模块代码在这。在这个例子中，定义了一个函数。 function someFunc() &#123;&#125; exports = someFunc; // 此时，exports 不再是一个 module.exports 的快捷方式， // 且这个模块依然导出一个空的默认对象。 module.exports = someFunc; // 此时，该模块导出 someFunc，而不是默认对象。 &#125;)(module, module.exports); return module.exports;&#125;参考http://nodejs.cn/api/modules.html#modules_cycles","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"什么是Node.js","slug":"什么是Node-js","date":"2018-01-08T13:29:21.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"什么是Node-js.html","link":"","permalink":"http://blog.langpz.com/什么是Node-js.html","excerpt":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。","text":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。I/O输入(Input)： 从系统写入文件输出(Output)： 从系统读取文件同步和异步同步是指发起一个调用之后主线程挂起，调用者主动等待调用返回结果。异步是指发起一个调用之后主线程还可以发起别的调用，被调用者通知调用者返回结果。阻塞式和非阻塞式非阻塞式是指发起一个调用不会阻塞主线程的执行，非阻塞式是实现异步的前提。阻塞式是指发起一个调用主线程是被挂起，调用完成后才可以执行其他操作。单线程和多线程单线程是指程序按顺序执行,前面的程序执行完后面才程序可以执行。多线程是指同时执行多个程序，当前程序执行不影响其他程序执行。事件驱动这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"VSCode 配置Node调试环境","slug":"VSCode-配置Node调试环境","date":"2018-01-05T17:17:59.000Z","updated":"2025-09-06T12:42:50.050Z","comments":true,"path":"VSCode-配置Node调试环境.html","link":"","permalink":"http://blog.langpz.com/VSCode-配置Node调试环境.html","excerpt":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。","text":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。首先下载VSCodehttps://code.visualstudio.com/下载对应系统的安装包下载VSCode新建文件打开VSCode新建一个文件夹hello，在里面再新建一个app.js新建文件app.js的代码12345for (let index = 0; index &lt; 5; index++) &#123; console.log(index) &#125;console.log('Hello Word')开始调试再点调试，快捷键（Ctrl+Shift+D）,添加配置选择Node.js。注： “program”: “${workspaceFolder}/app.js” /app.js 可以是任何名字，但是一定要是你入口文件。调试打断点开始打断点。打断点执行app.js操作和浏览器调试类似。执行app.js","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://blog.langpz.com/tags/VSCode/"}]},{"title":"Git配置https免用户名和密码提交","slug":"Git配置https免用户名和密码提交","date":"2018-01-03T14:15:36.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Git配置https免用户名和密码提交.html","link":"","permalink":"http://blog.langpz.com/Git配置https免用户名和密码提交.html","excerpt":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。","text":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。 在Git Bash 里面输入命令。1git config --global credential.helper store然后再提交输入用户名和密码提交完成后，用户名和密码就被保存了，下次再提交就不用再输入了。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"javascript数组去重","slug":"javascript数组去重","date":"2018-01-02T10:25:35.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"javascript数组去重.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重.html","excerpt":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。","text":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。1234567891011Array.prototype.removal = function removal()&#123; var hash = &#123;&#125;, arr = []; for(var i = 0; i &lt; this.length; i++)&#123; if(!hash[this[i]])&#123; arr.push(this[i]); &#125; hash[this[i]] = 1; &#125; return arr;&#125;javascript数组去重","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"}]},{"title":"Hexo博客多端同步问题","slug":"Hexo博客多端同步问题","date":"2017-12-29T16:38:22.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Hexo博客多端同步问题.html","link":"","permalink":"http://blog.langpz.com/Hexo博客多端同步问题.html","excerpt":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。","text":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。博客源文件同步在博客根目录执行123456git initgit remote add origin git@github.com:lanpangzhi/lanpangzhi.github.io.git # 添加远程仓库 注意这里要添加你自己的仓库 lanpangzhi 换成你自己的用户名git checkout -b hexo # 新建hexo分支并切换到hexo分支git add . # 所有变化提交到暂存区git commit -m \"解决同步问题\" # 提交文件git push origin hexo # 推送hexo分支这就成功了，github上已经有博客的源文件了。github查看提交成功推荐把hexo设置为默认分支。hexo设置为默认分支git submodule 实现第三方主题同步因为之前是直接把第三方主题克隆到博客目录，有什么改动是无法推送到作者Git仓库的，这个时候需要把第三方主题的项目Fork到自己仓库，自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下仓库的url。Fork第三方主题执行如下操作。1git submodule add git@github.com:lanpangzhi/hexo-theme-next.git themes/next把自己仓库下面第三方主题添加到Git子模块， 注 : themes/next 这里的目录是因为我用的next主题才会写themes/next 如果你用的不是next请把next替换成你的第三方主题文件夹名字。博客的根目录会多一个.gitmodules文件,这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录。.gitmodules文件这就添加成功了，然后执行如下操作。123git add . # 所有变化提交到暂存区git commit -m \"添加第三方主题Git子模块\" # 提交文件git push origin hexo # 推送hexo分支更换电脑同步博客和第三方主题同步博客电脑上一定要先node和git，执行如下操作。1234npm install hexo-cli -g # 先安装hexo的脚手架git clone git@github.com:lanpangzhi/lanpangzhi.github.io.git # 下载项目，因为hexo 是默认分支，所以这里直接会下载hexo分支npm i # 安装依赖hexo s # 启动服务器剩下的就自行操作了。博客已经完成了同步。注：每次写完文章部署网站后，记得再执行如下操作。123git add . # 所有变化提交到暂存区git commit -m \"新增xxx文章\" # 提交文件git push origin hexo # 推送hexo分支同步第三方主题在博客根目录执行如下操作。12git submodule init # 初始化本地配置文件git submodule update # 拉取子模块如果第三方主题有修改的，修改完成后在第三方主题目录执行。123git add . # 所有变化提交到暂存区git commit -m \"修改主题xxxx\" # 提交文件git push origin master # 推送master分支这样就会把修改的主题推送到自己的仓库。修改的主题推送到自己的仓库这样就实现多端同步了。参考http://devtian.me/2015/03/17/blog-sync-solutionhttps://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm install 报错提示请使用管理员","slug":"npm-install-报错提示请使用管理员","date":"2017-12-27T11:07:20.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"npm-install-报错提示请使用管理员.html","link":"","permalink":"http://blog.langpz.com/npm-install-报错提示请使用管理员.html","excerpt":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误","text":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误Please try running this command again as root/Administrator解决方案: 后面加上–no-optional 或者降级 5.3 版本 升级更高版本npm install hexo-cli -g --no-optional 参考https://stackoverflow.com/questions/46020018/error-eperm-operation-not-permitted-unlink-d-sources-node-modules-fseven","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"nvm管理node.js版本（Windows系统）","slug":"nvm管理node-js版本（Windows系统）","date":"2017-12-26T14:03:59.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"nvm管理node-js版本（Windows系统）.html","link":"","permalink":"http://blog.langpz.com/nvm管理node-js版本（Windows系统）.html","excerpt":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows）","text":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows）先去下载nvm-windows下载链接地址 注：目前版本1.1.6。如果你之前安装过node，先卸载掉。安装nvm-windows刚才下载的是 nvm-setup.zip 这个文件1输入 nvm这就安装成功了。安装node安装最新稳定版 node1nvm install latest安装指定版本 node1nvm install 8.9.0切换node版本1nvm use 9.3.0nvm list 显示当前安装node版本列表 * 代表当前使用的版本注: 安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 nvm基本命令nvm arch [32|64]: 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm install[arch]: version 版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm list [available]: 显示当前安装node版本列表 * 代表当前使用的版本，在末尾输入 available 显示可供下载的所有版本列表。nvm on: 使用Node.js版本管理。nvm off: 禁用node.js版本管理（不会卸载任何东西）。nvm proxy [url]: 设置下载的代理，将[url]留空以查看当前代理。 将[url]设置为 none 以删除代理。nvm uninstall: 卸载指定的node版本。nvm use[arch]: 切换指定的node版本，可选[arch]32和64位版本。nvm root: 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录。nvm version: 显示Windows的NVM的当前运行版本。nvm node_mirror: 设置node节点镜像。国内可以使用 https://npm.taobao.org/mirrors/node/nvm npm_mirror: 设置npm节点镜像。国内可以使用 https://npm.taobao.org/mirrors/npm/参考https://github.com/coreybutler/nvm-windows","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hexo+Next集成Algolia搜索","slug":"Hexo-Next集成Algolia搜索","date":"2017-12-22T13:13:18.000Z","updated":"2025-09-06T12:42:50.049Z","comments":true,"path":"Hexo-Next集成Algolia搜索.html","link":"","permalink":"http://blog.langpz.com/Hexo-Next集成Algolia搜索.html","excerpt":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后","text":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后首先注册Algolia账户Algolia 登陆页面https://www.algolia.com/users/sign_in，可以使用 GitHub 或者 Google 账户直接登录，也可以注册一个新账户。我直接用谷歌账户登陆了，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 index name 之后会用到Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：1npm install hexo-algolia --save # 目前最新版本是1.2.4，下面的操作都是基于这个版本的文档获取 Key，更新站点根目录配置前往站点根目录打开_config.yml添加以下代码12345# Algolia Search API Keyalgolia: applicationID: '你的Application ID' apiKey: '你的Search-Only API Key' indexName: '输入刚才创建index name'修改Algolia搜索ACL（访问控制列表）选中后保存。操作完成后执行命令123export(windows 为 set) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API keyset (Mac和git bash 为 export) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY #查看是否设置成功如果没有值就设置失败hexo algolia成功后修改Next主题配置文件更改Next主题配置文件，找到 Algolia Search 配置部分：123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: \"我们没有找到任何搜索结果: $&#123;query&#125;\" hits_stats: \"找到约$&#123;hits&#125;条结果（用时$&#123;time&#125;ms）\"将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。这个是我修改的文本。总结一下集成遇到的BUGPlease provide an Algolia index name in your hexo _config.yml flle原因：Algolia Search API Key indexName 错了解决方案：看下之前新建index的名字Not enough rights to update an object near原因：没有修改Algolia搜索ACL（访问控制列表）解决方案： 按1.4操作勾选上就可以移动端遮罩盖住搜索原因：遮罩的z-index值太高，我的next主题是5.1.3版本可能其他版本没有这个BUG解决方案： 找到\\themes\\next\\source\\css_common\\components\\third-party 下面的algolia-search.styl 文件 第8行追加12+mobile() z-index: 1000参考http://theme-next.iissnan.com/third-party-services.html#algolia-searchhttps://github.com/oncletom/hexo-algolia","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm使用介绍","slug":"npm使用介绍","date":"2017-12-20T14:56:09.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"npm使用介绍.html","link":"","permalink":"http://blog.langpz.com/npm使用介绍.html","excerpt":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com","text":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com创建一个模块1npm init会提示你输入包名等，然后生成一个package.json文件,文件内容如下1234567891011&#123; \"name\": \"xxx\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"lanpang\", \"license\": \"ISC\"&#125;package.json文件属性说明name - 包名version - 包的版本号description - 包的描述，方便在npm search中搜索main - main字段配置一个文件名指向模块的入口程序。如果你包的名字叫xxx，然后用户require(“xxx”)，main配置的模块的exports对象会被返回scripts - 是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令author - 作者license - 许可证，让人知道使用的权利和限制的更多说明请查看https://github.com/ericdum/mujiang.info/issues/6/安装模块1234npm install (Module Name) options # 语法npm install express # 本地安装npm install express -g # 全局安装npm install express@1.0.0 # 安装指定版本npm 的包安装分为本地安装（local）、全局安装（global）两种。本地安装：将安装包放在当前目录下的 ./node_modules 下。本地安装：可以通过 require(Module Name) 来引入本地安装的包。全局安装：node安装目录/node_modules。全局安装：可以直接在命令行里使用。查看全局安装目录1npm list -g --depth=0安装包信息将加入到dependencies（生产阶段的依赖）12npm install express --save # npm5已经将--save变成了默认参数，执行 install 依赖包时默认都会带上，除非加上 --no-save。npm install express -S # 缩写安装包信息将加入到devDependencies（开发和测试阶段的依赖）12npm install gulp --save-devnpm install gulp -D # 缩写注: 包的依赖都被写入了package.json文件后，他人git或者svn下载项目可以通过npm install 安装项目依赖的包。卸载包1npm uninstall gulp # 如果你安装的包带参数 --save 或者 --save-dev 必须npm uninstall gulp 要添加对应参数更新包更新本地包1npm update gulp更新全局包1npm update gulp -g检查包是否已经过时检查本地包1npm outdated检查全局包1npm outdated -g --depth=0搜索包1npm search express查看包安装信息查看本地包1npm list查看全局包1npm list -gnpm-scripts可以修改package.json文件scripts增加自定义命令，执行一些操作123\"scripts\": &#123; \"start\" : \"gulp\"&#125;此时在cmd或git bash中输入npm start 就会执行gulp命令包版本号默认1.0.0bug修复和其他小的变化：修补程序版本，增加最后一个数字，例如1.0.1。不破坏现有功能的新功能：次要版本，增加中间数字，例如1.1.0。主要版本，增加第一个数字，例如2.0.0。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"国内学生云主机优惠整理","slug":"国内学生云主机优惠整理","date":"2017-12-20T10:10:37.000Z","updated":"2025-09-06T12:42:50.053Z","comments":true,"path":"国内学生云主机优惠整理.html","link":"","permalink":"http://blog.langpz.com/国内学生云主机优惠整理.html","excerpt":"腾讯云云+校园扶持计划10元／月链接地址","text":"腾讯云云+校园扶持计划10元／月链接地址阿里云云翼计划9.9元／月 59元／半年 118元／年链接地址美团云云帆校园扶持计划8.8元／月链接地址京东云跃云计划8.8元／月 88 元／年链接地址注： 必须是要在籍大学生进行学生认证才可以购买","categories":[],"tags":[{"name":"云主机","slug":"云主机","permalink":"http://blog.langpz.com/tags/云主机/"}]},{"title":"css实现单行、多行文本溢出显示省略号","slug":"css实现单行、多行文本溢出显示省略号","date":"2017-12-19T10:58:41.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"css实现单行、多行文本溢出显示省略号.html","link":"","permalink":"http://blog.langpz.com/css实现单行、多行文本溢出显示省略号.html","excerpt":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号","text":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号css实现多行文本溢出显示省略号12345display: -webkit-box; // 设置弹性盒子模型overflow : hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号-webkit-line-clamp: 2; // 限制在一个块元素显示的文本的行数-webkit-box-orient: vertical; // 属性规定框的子元素应该被水平或垂直排列。注：因为用了webkit的私有属性，建议只在移动端使用。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"npm设置淘宝镜像","slug":"npm设置淘宝镜像","date":"2017-12-15T16:06:34.000Z","updated":"2025-09-06T12:42:50.052Z","comments":true,"path":"npm设置淘宝镜像.html","link":"","permalink":"http://blog.langpz.com/npm设置淘宝镜像.html","excerpt":"npm设置淘宝镜像我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙）","text":"npm设置淘宝镜像我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙）更新淘宝镜像源最新地址1npm config set registry https://registry.npmmirror.com我们可以通过设置淘宝镜像来解决问题淘宝镜像同步频率目前为10分钟一次以保证尽量与官方服务同步。设置成淘宝镜像12// 旧地址2022年(今年)5月份停止解析npm config set registry http://registry.npm.taobao.org查看设置是否成功1npm get registry注意如果你换成淘宝镜像的话，会影响你发布模块，这时候需要换回npm官网的镜像1npm config set registry https://registry.npmjs.org","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"node.js Windows下安装（笔记）","slug":"node-js-Windows下安装","date":"2017-12-12T16:26:01.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"node-js-Windows下安装.html","link":"","permalink":"http://blog.langpz.com/node-js-Windows下安装.html","excerpt":"首先去Node.js中文网下载安装包偶数位为稳定版本，奇数位为非稳定版本（开发版）稳定版本中已发布的API是不会改变的奇数开头的开发版就是会不断变化更新","text":"首先去Node.js中文网下载安装包偶数位为稳定版本，奇数位为非稳定版本（开发版）稳定版本中已发布的API是不会改变的奇数开头的开发版就是会不断变化更新点这里去下载如下图，选择系统对应的位数下载双击打开你下载node-v8.9.0-x64.msi安装包一路下一步Node.js默认安装目录，你也可以点Change修改目录，点击下一步(Next)点击下一步(Next)点击安装(Install)安装完检测PATH环境变量是否配置Node.js123win + r输入 cmd 回车输入 node -v 和 npm -v会显示你安装node和npm的版本","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-12T16:00:01.000Z","updated":"2025-09-06T12:42:50.051Z","comments":true,"path":"hello-world.html","link":"","permalink":"http://blog.langpz.com/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new \"My New Post\"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment","categories":[],"tags":[]}]}